TITLE: Demonstrating Type Satisfaction with Property Constraints - TypeScript
DESCRIPTION: This snippet defines a `Keys` type and an object `p` that `satisfies` `Partial<Record<Keys, unknown>>`. It illustrates how `satisfies` ensures that `p` only contains properties defined in `Keys`, catching an error for the `x` property. It also shows that type inference for `a` and `b` is preserved, but accessing `p.d` (which is in `Keys` but not on `p`) results in an error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeSatisfaction_propNameConstraining.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
type Keys = 'a' | 'b' | 'c' | 'd';

const p = {
    a: 0,
    b: "hello",
    x: 8 // Should error, 'x' isn't in 'Keys'
} satisfies Partial<Record<Keys, unknown>>;

// Should be OK -- retain info that a is number and b is string
let a = p.a.toFixed();
let b = p.b.substring(1);
// Should error even though 'd' is in 'Keys'
let d = p.d;
```

----------------------------------------

TITLE: Declaring React Component Base Class in TypeScript
DESCRIPTION: This snippet defines the base `Component` class within the `react` module's declaration file. It illustrates how TypeScript provides type definitions for React's core components, allowing for type checking of props (`T`) and state (`U`) in user-defined components.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxDynamicTagName7.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare module 'react' {
	class Component<T, U> { }
}
```

----------------------------------------

TITLE: Instantiating React Component with Missing Required Properties (TS2739)
DESCRIPTION: This example attempts to instantiate `MyComp` without providing any of its required properties (`a` and `b`), leading to a TypeScript error `TS2739`. This error indicates that the type `{}` (inferred from no props) is missing properties from the expected `Prop` interface.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxReactComponentWithDefaultTypeParameter3.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
let x1 = <MyComp />
```

----------------------------------------

TITLE: Importing Undefined Module in app.ts (TypeScript)
DESCRIPTION: This snippet from 'app.ts' also shows a TS2307 error, similar to the one in 'lib.ts'. It highlights a common issue where a required module 'foo' is missing, leading to compilation failure. Resolution involves ensuring 'foo' is available in 'node_modules' or correctly mapped.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/cachedModuleResolution7.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import {x} from "foo";
```

----------------------------------------

TITLE: Calculating Area using Switch Statement with Discriminated Unions in TypeScript
DESCRIPTION: Calculates the area of a `Shape` using a `switch` statement on the `s.kind` property. This demonstrates another common pattern for type narrowing with discriminated unions, where each `case` branch correctly infers the specific type of `s`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
function area2(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.width * s.height;
        case "circle": return Math.PI * s.radius * s.radius;
    }
}
```

----------------------------------------

TITLE: Demonstrating Object Type Narrowing with Truthy Checks in TypeScript
DESCRIPTION: This function illustrates various scenarios of type narrowing in TypeScript when `x` is of type `unknown` and checked for `typeof x === 'object'` combined with truthy checks. It highlights that `typeof x === 'object'` alone does not exclude `null`, leading to TS18047, but combining it with a truthy check (`x && typeof x === 'object'`) correctly narrows `x` to a non-null object.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/narrowingTruthyObject.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function foo(x: unknown, b: boolean) {
    if (typeof x === 'object') {
        x.toString();
    }
    if (typeof x === 'object' && x) {
        x.toString();
    }
    if (x && typeof x === 'object') {
        x.toString();
    }
    if (b && x && typeof x === 'object') {
        x.toString();
    }
    if (x && b && typeof x === 'object') {
        x.toString();
    }
    if (x && b && b && typeof x === 'object') {
        x.toString();
    }
    if (b && b && x && b && b && typeof x === 'object') {
        x.toString();
    }
}
```

----------------------------------------

TITLE: Demonstrating Union Type Assignability and Errors in TypeScript
DESCRIPTION: This snippet defines classes C, D, and E (where D and E extend C and introduce unique methods foo1 and foo2 respectively), along with union types 'number | string' and 'D | E'. It then demonstrates various type assignments, highlighting both valid assignments and common TypeScript errors (TS2741, TS2322) that occur when assigning incompatible types or union types where not all constituent types are assignable to the target.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unionTypesAssignability.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var unionNumberString: number | string;
class C { }
class D extends C { foo1() { } }
class E extends C { foo2() { } }
var unionDE: D | E;

var num: number;
var str: string;
var c: C;
var d: D;
var e: E;

// A union type U is assignable to a type T if each type in U is assignable to T
c = d;
c = e;
c = unionDE; // ok
d = d;
d = e; // error TS2741: Property 'foo1' is missing in type 'E' but required in type 'D'.
d = unionDE; // error TS2322: Type 'D | E' is not assignable to type 'D'. Property 'foo1' is missing in type 'E' but required in type 'D'.
e = d; // error TS2741: Property 'foo2' is missing in type 'D' but required in type 'E'.
e = e;
e = unionDE; // error TS2322: Type 'D | E' is not assignable to type 'E'. Property 'foo2' is missing in type 'D' but required in type 'E'.
num = num;
num = str; // error TS2322: Type 'string' is not assignable to type 'number'.
num = unionNumberString; // error TS2322: Type 'string | number' is not assignable to type 'number'. Type 'string' is not assignable to type 'number'.
str = num; // error TS2322: Type 'number' is not assignable to type 'string'.
str = str;
str = unionNumberString; // error TS2322: Type 'string | number' is not assignable to type 'string'. Type 'number' is not assignable to type 'string'.

// A type T is assignable to a union type U if T is assignable to any type in U
d = c; // error TS2741: Property 'foo1' is missing in type 'C' but required in type 'D'.
e = c; // error TS2741: Property 'foo2' is missing in type 'C' but required in type 'E'.
```

----------------------------------------

TITLE: Assigning Structurally Compatible Types to Class S
DESCRIPTION: This snippet shows that an instance of class 'S' can be assigned values from an interface 'S2' and an object literal 'a2'. This highlights TypeScript's structural typing, where types are compatible if their members match, regardless of their nominal declaration (class, interface, or object literal).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/assignmentCompatWithObjectMembers4.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
s = s2; // ok
s = a2; // ok
```

----------------------------------------

TITLE: Importing Module Causing TS2307 Error (just-types-versions)
DESCRIPTION: This TypeScript import statement illustrates a module path that triggers a TS2307 'Cannot find module' error, specifically for a module under 'just-types-versions'. This error signifies that the TypeScript compiler could not find the specified module or its type declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsBlocksTypesVersions(module=nodenext).errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
import {} from "just-types-versions/foo";
```

----------------------------------------

TITLE: TypeScript: TS2339 Compilation Error Message
DESCRIPTION: The specific TypeScript compilation error TS2339, indicating that the property 'Ghost' does not exist on the type imported from 'intermediate'. This error occurs because `export type * from './ghost'` only re-exports the *type* `Ghost`, not the *value* (class constructor), making `new intermediate.Ghost()` invalid.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportNamespace11.errors.txt#_snippet_3

LANGUAGE: TypeScript Error
CODE:
```
main.ts(2,52): error TS2339: Property 'Ghost' does not exist on type 'typeof import("intermediate")'.
```

----------------------------------------

TITLE: IPromise.then with Correct String Promise Arguments (OK)
DESCRIPTION: This example shows a correct usage of `IPromise.then` where the `sIPromise` callbacks are properly assigned to the `then` method's parameters, ensuring type compatibility and no errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/promisePermutations3.errors.txt#_snippet_38

LANGUAGE: TypeScript
CODE:
```
var r9b = r9.then(sIPromise, sIPromise, sIPromise); // ok
```

----------------------------------------

TITLE: Incorrect TypeScript Module Resolution Configuration
DESCRIPTION: This `tsconfig.json` snippet illustrates a common error (TS5098) where module resolution options like `customConditions`, `resolvePackageJsonExports`, and `resolvePackageJsonImports` are used with an incompatible `moduleResolution` setting, specifically 'classic'. These options require `moduleResolution` to be 'node16', 'nodenext', or 'bundler' to function correctly.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/packageJsonExportsOptionsCompat.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
    {
      "compilerOptions": {
        "moduleResolution": "classic",
        "customConditions": ["webpack", "browser"],
        "resolvePackageJsonExports": true,
        "resolvePackageJsonImports": true,
        "noEmit": true
      }
    }
```

----------------------------------------

TITLE: Creating Object Types from Property Definitions in TypeScript
DESCRIPTION: This snippet defines a `PropDef` type for structured property definitions and a `TypeFromDefs` mapped type that constructs an object type from a union of `PropDef`s. It uses the `as` clause to map `P['name']` to the new property key and `P['type']` to its value, demonstrating how to build types from structured metadata. `TP1` shows how duplicate names are handled, with the last definition overriding previous ones.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeAsClauses.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type PropDef<K extends keyof any, T> = { name: K, type: T };

type TypeFromDefs<T extends PropDef<keyof any, any>> = { [P in T as P['name']]: P['type'] };

type TP1 = TypeFromDefs<{ name: 'a', type: string } | { name: 'b', type: number } | { name: 'a', type: boolean }>;
```

----------------------------------------

TITLE: Main Package.json Export Map Configuration
DESCRIPTION: This `package.json` defines the main package's metadata and its `exports` map. The `"type": "module"` indicates ESM default behavior. The `exports` field specifies how different subpaths (`./cjs`, `./mjs`, `.` for default) resolve to specific files, crucial for module resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageExports(module=nodenext).errors.txt#_snippet_6

LANGUAGE: JSON
CODE:
```
{
        "name": "package",
        "private": true,
        "type": "module",
        "exports": {
            "./cjs": "./index.cjs",
            "./mjs": "./index.mjs",
            ".": "./index.js"
        }
    }
```

----------------------------------------

TITLE: Declaring Function with Implicit Any Parameter - TypeScript
DESCRIPTION: This snippet illustrates a TypeScript error (TS7006) where the parameter 'x' in the `foo` function implicitly receives an 'any' type because no explicit type annotation is provided. This occurs when the `noImplicitAny` compiler option is enabled, enforcing stricter type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/implicitAnyDeclareFunctionWithoutFormalType.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function foo(x) { };
```

----------------------------------------

TITLE: Correct React Component Prop Assignment Example
DESCRIPTION: This example demonstrates the correct way to pass props to the `Poisoned` component, satisfying the `PoisonedProp` interface by providing `x` as a string and `y` as the literal '2'. This usage results in no TypeScript errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadAttributesResolution2.errors.txt#_snippet_1

LANGUAGE: TSX
CODE:
```
// OK
<Poisoned {...{x: "ok", y: "2"}} />;
```

----------------------------------------

TITLE: Array Destructuring with Default Values and Nested Arrays in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates advanced array destructuring. It assigns a default value 'noName' to `nameMA` if the first array element is undefined. It also showcases nested destructuring, where `primarySkillA` and `secondarySkillA` are assigned values from a nested array, defaulting to `['skill1', 'skill2']` if the corresponding element is undefined. This pattern is useful for providing fallback values in complex data structures.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfArrayBindingPatternDefaultValues.sourcemap.txt#_snippet_56

LANGUAGE: TypeScript
CODE:
```
[nameMA = "noName", [primarySkillA = "primary", secondarySkillA = "secondary"] = ["skill1", "skill2"]]
```

----------------------------------------

TITLE: Defining InterfaceY in TypeScript
DESCRIPTION: This snippet defines a TypeScript interface named `InterfaceY`. Interfaces are used to describe the shape of objects, ensuring type safety. This interface declares a single method, `YisIn1_2`, which takes no arguments and returns void.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeResolution.sourcemap.txt#_snippet_70

LANGUAGE: TypeScript
CODE:
```
export interface InterfaceY { YisIn1_2(); }
```

----------------------------------------

TITLE: Declaring Variables, Classes, and Functions in TypeScript (m1.ts)
DESCRIPTION: This snippet from `m1.ts` demonstrates fundamental TypeScript syntax. It includes the declaration of a numeric variable `m1_a1`, a class `m1_c1` with a public number property `m1_c1_p1`, instantiation of `m1_c1`, and a function `m1_f1` that returns the class instance.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/mapRootSourceRootWithNoSourceMapOption/amd/mapRootSourceRootWithNoSourceMapOption.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
    var m1_a1 = 10;
    class m1_c1 {
        public m1_c1_p1: number;
    }
    
    var m1_instance1 = new m1_c1();
    function m1_f1() {
        return m1_instance1;
    }
```

----------------------------------------

TITLE: Type Narrowing with Switch Statement and Mixed Control Flow in TypeScript
DESCRIPTION: Shows type narrowing in a `switch` statement with different control flow exits. If `m.kind` is "A", the function returns. If `m.kind` is "D", an error is thrown. After these branches, `m` is narrowed to only the remaining possible type: `{ kind: "B" | "C", y: number }`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_14

LANGUAGE: TypeScript
CODE:
```
function f8(m: Message) {
    switch (m.kind) {
        case "A":
            return;
        case "D":
            throw new Error();
    }
    m;  // { kind: "B" | "C", y: number }
}
```

----------------------------------------

TITLE: Handling Missing Extensions in ECMAScript Imports (Node16/NodeNext)
DESCRIPTION: These snippets demonstrate TS2835 and TS2834 errors when using ECMAScript `import` statements with relative paths that lack explicit file extensions or refer to directories/implicit index files. This occurs when TypeScript's `--moduleResolution` is set to `node16` or `nodenext`, which requires full specifiers for ES modules. To resolve, add the `.js`, `.mjs`, or `.cjs` extension.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node18).errors.txt#_snippet_24

LANGUAGE: TypeScript
CODE:
```
import * as m18 from "./subfolder2";
import * as m19 from "./subfolder2/";
import * as m20 from "./subfolder2/index";
import * as m21 from "./subfolder2/another";
import * as m22 from "./subfolder2/another/";
import * as m23 from "./subfolder2/another/index";
```

----------------------------------------

TITLE: Logging a Variable in TypeScript
DESCRIPTION: This snippet uses `console.log` to output the value of the `primaryA` variable to the console. It's a standard debugging or output mechanism in JavaScript/TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForObjectBindingPattern2.sourcemap.txt#_snippet_33

LANGUAGE: TypeScript
CODE:
```
console.log(primaryA);
```

----------------------------------------

TITLE: Define and use a generic 'merge' utility type in TypeScript
DESCRIPTION: This snippet defines a TypeScript utility type `merge` that combines two object types, `base` and `props`. If there are no common keys, it simply creates an intersection type (`base & props`). If common keys exist, it uses `Omit` to remove common keys from `base` before intersecting with `props`, effectively overwriting properties from `base` with those from `props`. It also declares a corresponding `merge` function that applies this type logic at runtime. The subsequent code demonstrates a long chain of object merging using this utility, which can lead to complex inferred types and potential `TS2339` errors if properties are accessed incorrectly or type inference becomes too deep.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/longObjectInstantiationChain3.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export type merge<base, props> = keyof base & keyof props extends never
  ? base & props
  : Omit<base, keyof props & keyof base> & props;

declare const merge: <l, r>(l: l, r: r) => merge<l, r>;

const o1 = merge({ p1: 1 }, { p2: 2 });
const o2 = merge(o1, { p2: 2, p3: 3 });
const o3 = merge(o2, { p3: 3, p4: 4 });
const o4 = merge(o3, { p4: 4, p5: 5 });
const o5 = merge(o4, { p5: 5, p6: 6 });
const o6 = merge(o5, { p6: 6, p7: 7 });
const o7 = merge(o6, { p7: 7, p8: 8 });
const o8 = merge(o7, { p8: 8, p9: 9 });
const o9 = merge(o8, { p9: 9, p10: 10 });
const o10 = merge(o9, { p10: 10, p11: 11 });
const o11 = merge(o10, { p11: 11, p12: 12 });
const o12 = merge(o11, { p12: 12, p13: 13 });
const o13 = merge(o12, { p13: 13, p14: 14 });
const o14 = merge(o13, { p14: 14, p15: 15 });
const o15 = merge(o14, { p15: 15, p16: 16 });
const o16 = merge(o15, { p16: 16, p17: 17 });
const o17 = merge(o16, { p17: 17, p18: 18 });
const o18 = merge(o17, { p18: 18, p19: 19 });
const o19 = merge(o18, { p19: 19, p20: 20 });
const o20 = merge(o19, { p20: 20, p21: 21 });
const o21 = merge(o20, { p21: 21, p22: 22 });
const o22 = merge(o21, { p22: 22, p23: 23 });
const o23 = merge(o22, { p23: 23, p24: 24 });
const o24 = merge(o23, { p24: 24, p25: 25 });
const o25 = merge(o24, { p25: 25, p26: 26 });
const o26 = merge(o25, { p26: 26, p27: 27 });
const o27 = merge(o26, { p27: 27, p28: 28 });
const o28 = merge(o27, { p28: 28, p29: 29 });
const o29 = merge(o28, { p29: 29, p30: 30 });
const o30 = merge(o29, { p30: 30, p31: 31 });
const o31 = merge(o30, { p31: 31, p32: 32 });
const o32 = merge(o31, { p32: 32, p33: 33 });
```

----------------------------------------

TITLE: TypeScript Class Property Access Error Example (TS2339)
DESCRIPTION: This code snippet illustrates a TypeScript compilation error (TS2339) where a class method attempts to access 'this.y'. Although 'y' is a parameter in the constructor, it is not declared as a class property (e.g., via 'public y' or 'private y'), causing TypeScript to report that 'Property 'y' does not exist on type 'Foo'. This demonstrates the need for explicit property declaration for class members.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/propertyOrdering2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class Foo {
    constructor(public x, y) { }
       foo() {
        var a = this.x;
        return this.y;
    }
}
```

----------------------------------------

TITLE: Demonstrating Valid and Invalid Await Using Declarations in TypeScript
DESCRIPTION: This `async` function showcases both valid and invalid `await using` declarations. It successfully uses `AsyncIteratorObject` and `AsyncGenerator` as initializers, but fails when attempting to use a plain `AsyncIterator` because it lacks the necessary `[Symbol.asyncDispose]()` or `[Symbol.dispose]()` method, triggering TypeScript error TS2851: 'The initializer of an 'await using' declaration must be either an object with a '[Symbol.asyncDispose]()' or '[Symbol.dispose]()' method, or be 'null' or 'undefined.'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarationsWithAsyncIteratorObject.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
async function f() {
    // should pass
    await using it0 = aio;
    await using it1 = ag;

    // should fail
    await using it2 = ai;
}
```

----------------------------------------

TITLE: Root Package.json Configuration (JSON)
DESCRIPTION: This `package.json` configures the root package as an ECMAScript Module (`"type": "module"`). It defines `exports` to map internal paths (`./cjs`, `./mjs`, `.`) to their respective module files, facilitating consistent module resolution for consumers.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesDeclarationEmitWithPackageExports(module=node16).errors.txt#_snippet_8

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module",
    "exports": {
        "./cjs": "./index.cjs",
        "./mjs": "./index.mjs",
        ".": "./index.js"
    }
}
```

----------------------------------------

TITLE: Calculating Area with Exhaustive Switch and assertNever in TypeScript
DESCRIPTION: Calculates the area of a `Shape` using a `switch` statement, including a `default` case that calls `assertNever(s)`. This pattern ensures that all members of the `Shape` union are explicitly handled, providing a compile-time error if a new `Shape` type is added but not covered.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
function area3(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.width * s.height;
        case "circle": return Math.PI * s.radius * s.radius;
        default: return assertNever(s);
    }
}
```

----------------------------------------

TITLE: Multiple Implicit Any Parameters in Function - TypeScript
DESCRIPTION: This snippet shows how TypeScript generates multiple TS7006 errors when several parameters (a, b, c) in the `func2` function are declared without explicit type annotations, leading to implicit 'any' types for each.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/implicitAnyDeclareFunctionWithoutFormalType.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
function func2(a, b, c) { };
```

----------------------------------------

TITLE: Declaring Async Functions and Methods in TypeScript
DESCRIPTION: This snippet illustrates the diverse syntax for defining asynchronous operations using the 'async' keyword in TypeScript. It covers standard function declarations, function expressions, arrow functions, methods within object literals, instance and static methods in classes, and functions exported from modules. The examples also demonstrate how TypeScript infers return types as 'Promise<void>' or 'Promise<T>' and how to explicitly specify return types, including custom Promise-like types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/asyncAwaitIsolatedModules_es5.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { MyPromise } from "missing";

declare var p: Promise<number>;
declare var mp: MyPromise<number>;

async function f0() { }
async function f1(): Promise<void> { }
async function f3(): MyPromise<void> { }

let f4 = async function() { }
let f5 = async function(): Promise<void> { }
let f6 = async function(): MyPromise<void> { }

let f7 = async () => { };
let f8 = async (): Promise<void> => { };
let f9 = async (): MyPromise<void> => { };
let f10 = async () => p;
let f11 = async () => mp;
let f12 = async (): Promise<number> => mp;
let f13 = async (): MyPromise<number> => p;

let o = {
	async m1() { },
	async m2(): Promise<void> { },
	async m3(): MyPromise<void> { }
};

class C {
	async m1() { }
	async m2(): Promise<void> { }
	async m3(): MyPromise<void> { }
	static async m4() { }
	static async m5(): Promise<void> { }
	static async m6(): MyPromise<void> { }
}

module M {
	export async function f1() { }
}
```

----------------------------------------

TITLE: Incorrect Usage of `MeetAndGreet` Component (Missing Required Prop) in TypeScript JSX
DESCRIPTION: This snippet shows a `TS2741` error because the required `prop-name` is missing when using `MeetAndGreet`. Instead, an `extra-prop-name` is provided, which is not recognized by the component's type definition.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxStatelessFunctionComponents1.errors.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
let h = <MeetAndGreet extra-prop-name="World" />;
```

----------------------------------------

TITLE: Demonstrating 'this' Context Issue in Array.prototype.find (TypeScript)
DESCRIPTION: This method illustrates a common 'this' context problem in TypeScript when using Array.prototype.find with a traditional 'function' expression. Inside the callback, 'this' refers to the global object (or 'undefined' in strict mode) instead of the 'Test' instance, leading to a TS2683 error. It highlights the need to explicitly bind 'this' or use arrow functions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/thisInFunctionCall.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
finderRaw() {
  this.data.find(function (d) {
    return d === this.data.length
  })
}
```

----------------------------------------

TITLE: Configuring Module Exports and Types Versions in package.json
DESCRIPTION: Defines a package.json file demonstrating various configurations for 'exports' and 'typesVersions' fields. It shows how different subpaths are mapped to JavaScript files and TypeScript declaration files, including version-specific type mappings for TypeScript versions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsBlocksTypesVersions(module=nodenext).errors.txt#_snippet_0

LANGUAGE: json
CODE:
```
{
      "name": "exports-and-types-versions",
      "version": "1.0.0",
      "exports": {
        "./foo": "./dist/foo.js",
        "./yep": {
          "types": "./types/foo.d.ts",
          "default": "./dist/foo.js"
        },
        "./versioned-yep": {
          "types@>=4": "./types/foo.d.ts"
        },
        "./versioned-nah": {
          "types@<4": "./types/foo.d.ts"
        }
      },
      "typesVersions": {
        "*": {
          "foo": ["./types/foo.d.ts"],
          "nope": ["./types/foo.d.ts"],
          "versioned-nah": ["./types/foo.d.ts"]
        }
      }
    }
```

----------------------------------------

TITLE: TypeScript Error TS2834/TS2835: Relative ECMAScript Imports Require Extensions
DESCRIPTION: This snippet illustrates TypeScript errors TS2834 and TS2835, which occur when relative ECMAScript 'import' statements lack explicit file extensions (e.g., .js, .mjs) under 'node16' or 'nodenext' module resolution. TypeScript suggests adding an extension or provides a specific '.mjs' suggestion.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node20).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
!!! error TS2834: Relative import paths need explicit file extensions in ECMAScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path.
    import * as m23 from "./subfolder2/another/index";
                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2835: Relative import paths need explicit file extensions in ECMAScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean './subfolder2/another/index.mjs'?
    void m1;
    void m2;
    void m3;
    void m4;
    void m5;
    void m6;
    void m7;
    void m8;
    void m9;
    void m10;
    void m11;
    void m12;
    void m13;
    void m14;
    void m15;
    void m16;
    void m17;
    void m18;
    void m19;
    void m20;
    void m21;
    void m22;
    void m23;
```

----------------------------------------

TITLE: Filtering Mapped Type Keys with Conditional Type in TypeScript
DESCRIPTION: This snippet defines `Mapped5` which conditionally remaps keys, only including those that start with an underscore. The function `f5` demonstrates accessing properties of `Mapped5`, where the type system correctly infers that the accessed values will conform to ``_${string}``.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeConstraints2.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
type Mapped5<K extends string> = {
  [P in K as P extends `_${string}` ? P : never]: P;
};

function f5<K extends string>(obj: Mapped5<K>, key: keyof Mapped5<K>) {
  let s: `_${string}` = obj[key];
}
```

----------------------------------------

TITLE: TypeScript Switch Statement for Valid Response Handling
DESCRIPTION: Illustrates a switch statement handling known string literal responses ('yes', 'no', 'idk') from an 'unknown' input. It returns a 'SomeResponse' type for valid cases or throws an error for unknown values, ensuring type safety.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownType2.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
    function switchResponse(x: unknown): SomeResponse {
        switch (x) {
            case 'yes':
            case 'no':
            case 'idk':
                return x;
            default:
                throw new Error('unknown response');
        }
        // Arguably this should be never.
        type End = isTrue<isUnknown<typeof x>>
    }
```

----------------------------------------

TITLE: Discriminated Union Narrowing with Boolean Property Type Predicate in TypeScript (Issue 58996)
DESCRIPTION: This snippet, related to TypeScript issue #58996, showcases type narrowing using a boolean property as a discriminator in a union type. The 'isAnimal' function acts as a type predicate, narrowing 'Something' to 'Animal' based on the 'breath' property. The 'positive' and 'negative' functions demonstrate how this predicate can be used directly or negated for conditional type narrowing.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/inferTypePredicates.errors.txt#_snippet_37

LANGUAGE: TypeScript
CODE:
```
type Animal = {
  breath: true,
};

type Rock = {
  breath: false,
};

type Something = Animal | Rock;

function isAnimal(something: Something): something is Animal {
  return something.breath
}

function positive(t: Something) {
  return isAnimal(t)
}

function negative(t: Something) { 
  return !isAnimal(t)
}
```

----------------------------------------

TITLE: Importing Modules with Missing Type Declarations in TypeScript
DESCRIPTION: This TypeScript snippet attempts to import default exports from various local files with different extensions. Each import statement results in a `TS2307` error, indicating that the module or its corresponding type declarations cannot be found, highlighting TypeScript's strict module resolution when type definitions are absent.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationFileForTsJsImport(module=nodenext).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import def1 from "./file.js";
import def2 from "./file.jsx";
import def3 from "./file.ts";
import def4 from "./file.tsx";
import def5 from "./file.mjs";
import def6 from "./file.cjs";
import def7 from "./file.mts";
import def8 from "./file.cts";
import def9 from "./file.d.ts";
import def10 from "./file.d.cts";
import def11 from "./file.d.mts";
import def12 from "./file.d.json.ts";
```

----------------------------------------

TITLE: Defining a Class in TypeScript (a.js)
DESCRIPTION: This snippet defines a simple TypeScript class 'A'. This class serves as the original source for both type and value exports, which are then re-exported and consumed by other modules in the example.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportNamespace_js.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export class A {}
```

----------------------------------------

TITLE: Public Arrow Function with Implicit Any and Any[] Rest Parameters (TypeScript)
DESCRIPTION: This snippet defines a public arrow function `pub_f14` with a regular parameter `x` and a rest parameter `r`. Both are implicitly typed, leading to a `TS7006` error for `x` and a `TS7019` error for `r` when `noImplicitAny` is active, emphasizing the need for explicit type declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyParametersInClass.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
public pub_f14 = (x, ...r) => "";
```

----------------------------------------

TITLE: Defining and Exporting a TypeScript Interface
DESCRIPTION: This TypeScript snippet defines a simple interface named `Foo` with a single numeric property `x`. It then exports this interface as the default export, making it available for import and use in other TypeScript modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationEmitToDeclarationDirWithoutCompositeAndDeclarationOptions.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
interface Foo {
    x: number;
}
export default Foo;
```

----------------------------------------

TITLE: Incorrect Value Usage of Type-Only Imports (TS1361)
DESCRIPTION: This snippet highlights common TypeScript errors (TS1361) that occur when attempting to use entities imported with `import type` in value positions, specifically when extending a class. Since `C` was imported as a type and `types` as a type-only namespace, neither can be used as a base class for `U` or `V` respectively, resulting in compilation errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/extendsClause.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
class U extends C {} // Error
class V extends types.C {} // Error
```

----------------------------------------

TITLE: Continuous Paging with Async While Loop in TypeScript
DESCRIPTION: This snippet demonstrates an `async` function `myFunc` that continuously fetches data using `myQuery` in an infinite `while` loop. It implements a common paging pattern by passing the `lastId` from the previous query's results to the next, handling `undefined` for the initial call.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/controlFlowIterationErrorsAsync.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
declare function myQuery(input: { lastId: number | undefined }): Promise<{ entities: number[] }>;

async function myFunc(): Promise<void> {
  let lastId: number | undefined = undefined;

  while (true) {
    const { entities } = await myQuery({
        lastId,
    });

    lastId = entities[entities.length - 1];
  }
}
```

----------------------------------------

TITLE: Implementing Reducer with Discriminated Union Arguments
DESCRIPTION: Defines a `reducer` function that accepts arguments based on a discriminated union type `ReducerArgs`. The `switch` statement on the `op` parameter correctly narrows the type of `args`, enabling type-safe access to properties like `a`, `b`, `firstArr`, and `secondArr`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/dependentDestructuredVariables.errors.txt#_snippet_24

LANGUAGE: TypeScript
CODE:
```
type ReducerArgs = ["add", { a: number, b: number }] | ["concat", { firstArr: any[], secondArr: any[] }];

const reducer: (...args: ReducerArgs) => void = (op, args) => {
    switch (op) {
        case "add":
            console.log(args.a + args.b);
            break;
        case "concat":
            console.log(args.firstArr.concat(args.secondArr));
            break;
    }
}

reducer("add", { a: 1, b: 3 });
reducer("concat", { firstArr: [1, 2], secondArr: [3, 4] });
```

----------------------------------------

TITLE: Destructuring Array Elements in TypeScript
DESCRIPTION: This snippet demonstrates array destructuring assignment in TypeScript. It extracts the first element from the `multiRobotA` array and assigns it to the `multiRobotAInfo` variable. This is a concise way to unpack values from arrays into distinct variables.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementArrayBindingPattern2.sourcemap.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
let [multiRobotAInfo] = multiRobotA;
```

----------------------------------------

TITLE: Defining Type Package Exports (JSON)
DESCRIPTION: This `package.json` defines the exports for the `@types/foo` package. It specifies conditional exports for `import` (pointing to `index.d.mts`) and `require` (pointing to `index.d.cts`), allowing different declaration files to be used based on the module resolution context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/resolutionModeTripleSlash5.errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
  "name": "@types/foo",
  "version": "1.0.0",
  "exports": {
    ".": {
      "import": "./index.d.mts",
      "require": "./index.d.cts"
    }
  }
}
```

----------------------------------------

TITLE: Demonstrating TS2554: Function Call with Too Many Arguments in TypeScript
DESCRIPTION: This snippet showcases TypeScript error TS2554, which occurs when a function is called with more arguments than its signature permits. The `f2` function is defined to accept a single argument (`x`), but it is invoked with three arguments (`1, 2, 3`), triggering the 'Expected 0-1 arguments, but got 3' error. The `f1` method within `foo` is a dependency, but the error specifically targets the `f2` function call.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/argumentsPropertyNameInJsMode1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
const foo = {
   f1: (params) => { }
}

function f2(x) {
  foo.f1({ x, arguments: [] });
}

f2(1, 2, 3);
```

----------------------------------------

TITLE: Demonstrating Private Identifiers and Type Compatibility in Generic TypeScript Classes
DESCRIPTION: This snippet defines a generic TypeScript class C<T> with private fields (#foo), methods (#method), and accessors (#prop). It demonstrates that private members are accessible internally within the class (e.g., bar, bar2, bar3 methods) but are inaccessible from outside the class instance, leading to TS18013 errors. Additionally, it shows TS2322 type compatibility errors when attempting to assign instances of C with different generic type arguments (e.g., C<string> to C<number>).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/privateNamesInGenericClasses.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class C<T> {
    #foo: T;
    #method(): T { return this.#foo; }
    get #prop(): T { return this.#foo; }
    set #prop(value : T) { this.#foo = value; }
    
    bar(x: C<T>) { return x.#foo; }          // OK
    bar2(x: C<T>) { return x.#method(); }    // OK
    bar3(x: C<T>) { return x.#prop; }        // OK

    baz(x: C<number>) { return x.#foo; }     // OK
    baz2(x: C<number>) { return x.#method; } // OK
    baz3(x: C<number>) { return x.#prop; }   // OK

    quux(x: C<string>) { return x.#foo; }    // OK
    quux2(x: C<string>) { return x.#method; }// OK
    quux3(x: C<string>) { return x.#prop; }  // OK
}

declare let a: C<number>;
declare let b: C<string>;
a.#foo;                                   // Error
a.#method;                                // Error
a.#prop;                                  // Error
a = b;                                    // Error
b = a;                                    // Error
```

----------------------------------------

TITLE: Configuring Deprecated Compiler Options in TypeScript
DESCRIPTION: This `tsconfig.json` snippet demonstrates several deprecated TypeScript compiler options, including 'target', 'noImplicitUseStrict', 'keyofStringsOnly', 'suppressExcessPropertyErrors', 'suppressImplicitAnyIndexErrors', 'noStrictGenericChecks', 'charset', and 'out'. Each option triggers a deprecation error (TS5101 or TS5107) in TypeScript 5.5, advising users to specify '"ignoreDeprecations": "5.0"' to silence the errors or use 'outFile' instead of 'out'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/deprecatedCompilerOptions1.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "compilerOptions": {
        "target": "ES3",
        "noImplicitUseStrict": true,
        "keyofStringsOnly": true,
        "suppressExcessPropertyErrors": true,
        "suppressImplicitAnyIndexErrors": true,
        "noStrictGenericChecks": true,
        "charset": "utf8",
        "out": "dist.js"
    }
}
```

----------------------------------------

TITLE: Capturing Let Variable in While Loop - TypeScript
DESCRIPTION: This function demonstrates 'let' variable capture within a 'while' loop. The 'let x' is declared inside the loop, creating a new binding for each iteration. Closures capture this iteration-specific 'x', while 'var v' captures the final value of 'x' (which is always 1 in this case) after the loop's execution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/capturedLetConstInLoop5.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function foo2(x) {
    while (1 === 1) {
        let x = 1;
        var v = x;
        (function() { return x + v });
        (() => x + v);
        if (x == 1) {
            return;
        }
    }
    
    use(v);
}
```

----------------------------------------

TITLE: Using Logical OR Assignment (||=) in TypeScript
DESCRIPTION: This snippet demonstrates the `||=` (logical OR assignment) operator. If `results` is falsy (e.g., `undefined`, `null`, `0`, `''`), it will be assigned the value of `bar?.value ?? []`. Otherwise, `results` retains its original value. The `push(100)` operation then adds an element to the (now guaranteed non-falsy) `results` array.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/logicalAssignment8(target=es2020).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function foo1(results: number[] | undefined) {
    (results ||= bar?.value ?? []).push(100);
}
```

----------------------------------------

TITLE: Configuring @restart/hooks Package Main Entry Points in JSON
DESCRIPTION: This `package.json` defines the entry points for the `@restart/hooks` library, specifying `main` for CommonJS, `types` for TypeScript declaration files, and `module` for ES module builds. It's relevant for how TypeScript resolves modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nestedPackageJsonRedirect(moduleresolution=node16).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "name": "@restart/hooks",
    "version": "0.3.25",
    "main": "cjs/index.js",
    "types": "cjs/index.d.ts",
    "module": "esm/index.js"
}
```

----------------------------------------

TITLE: Root Package.json for ES Modules - JSON
DESCRIPTION: This package.json configures the root project to use ES Modules by setting "type": "module". This declaration influences how Node.js and TypeScript resolve and interpret module imports and exports within the package.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions3(module=nodenext).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Main Package.json Configuration for Module Exports
DESCRIPTION: This `package.json` defines the main package's configuration, setting its `type` to `module` to indicate it's an ECMAScript module. It also specifies `exports` mapping different entry points (`./cjs`, `./mjs`, `.`) to their respective files, enabling conditional exports for CommonJS and ECMAScript modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageExports(module=node18).errors.txt#_snippet_7

LANGUAGE: JSON
CODE:
```
    {
        "name": "package",
        "private": true,
        "type": "module",
        "exports": {
            "./cjs": "./index.cjs",
            "./mjs": "./index.mjs",
            ".": "./index.js"
        }
    }
```

----------------------------------------

TITLE: Destructuring 'unknown' Type in Catch Clauses Leading to Errors in TypeScript
DESCRIPTION: Shows attempts to destructure an 'unknown' type in 'catch' clauses, which results in TypeScript errors. Since 'unknown' cannot be directly destructured as an object or array without prior type narrowing, accessing properties or treating it as an array leads to 'TS2339' (property does not exist on type '{}') or 'TS2461' (not an array type) errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/destructureCatchClause(strict=false,useunknownincatchvariables=false).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
try {} catch ({ x }: unknown) { x }
try {} catch ([ x ]: unknown) { x }

try {} catch ({ a: { x } }: unknown) { x }
try {} catch ({ a: [ x ] }: unknown) { x }

try {} catch ([{ x }]: unknown) { x }
try {} catch ([[ x ]]: unknown) { x }

try {} catch ({ a: { b: { c: { x }} }}: unknown) { x }
```

----------------------------------------

TITLE: Addressing Unknown Property Error (TS2353) in TypeScript Configuration
DESCRIPTION: This snippet illustrates TypeScript error TS2353, indicating that the 'extra' property is not defined in the expected type for the `createXMachine` configuration. This error occurs when an object literal contains properties not specified in its type definition, enforcing strict type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/reverseMappedTypeIntersectionConstraint.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
const config = createXMachine({
  types: {} as {
    actors: {
      src: "str";
      logic: typeof child;
    };
  },
  invoke: {
    src: "str",
  },
  extra: 10
});
```

----------------------------------------

TITLE: Handling TS6133 Unused React Import in TypeScript
DESCRIPTION: This snippet showcases a TypeScript file for a React application where the 'React' import is present but not directly utilized, triggering a TS6133 error. It defines two simple functional components, `Bar` and `Foo`, with `Foo` rendering `Bar`. The error highlights a common scenario where 'React' might be implicitly used by JSX transform, but TypeScript still flags it as unused without proper configuration or explicit usage.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/reactImportUnusedInNewJSXEmit(jsx=react-jsx).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
/// <reference path="/.lib/react16.d.ts" />

import React from "react";

function Bar() {
  return <div />;
}

export function Foo() {
  return <Bar />;
}
```

----------------------------------------

TITLE: Using Logical AND Assignment (&&=) with Possible Undefined in TypeScript
DESCRIPTION: This snippet demonstrates the `&&=` operator. If `results` is truthy, it is assigned the value of `bar?.value ?? []`. However, if `results` is `undefined` (which is falsy), the assignment does not occur, and `results` remains `undefined`. Attempting to call `.push(100)` on a potentially `undefined` `results` leads to a `TS2532` error, 'Object is possibly 'undefined'', as shown in the provided context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/logicalAssignment8(target=es2021).errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function foo3(results: number[] | undefined) {
    (results &&= bar?.value ?? []).push(100);
}
```

----------------------------------------

TITLE: Demonstrating TypeScript Generic Type Constraint Errors
DESCRIPTION: This TypeScript snippet defines interfaces `A`, `B`, and `C` (where `B` extends `A` and `C` extends `B`), along with a generic interface `G<T, U extends B>`. It then declares several variables (`v1` through `v7`) to demonstrate valid and invalid usages of the `G` interface, specifically highlighting common errors such as a type argument not satisfying its constraint (`TS2344`) and providing an incorrect number of type arguments (`TS2314`). The snippet serves as an example for understanding how TypeScript's type checker enforces generic constraints.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/generics2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
    interface A { a: string; }
    interface B extends A { b: string; }
    interface C extends B { c: string; }
    interface G<T, U extends B> {
        x: T;
        y: U;
    }
    
    
    var v1: {
        x: { a: string; }
        y: { a: string; b: string; c: string };
    }; // Ok
    
    
    var v2: G<{ a: string }, C>;   // Ok, equivalent to G<A, C>
    var v3: G<A, A>;               // Error, A not valid argument for U
                 ~
!!! error TS2344: Type 'A' does not satisfy the constraint 'B'.
!!! error TS2344:   Property 'b' is missing in type 'A' but required in type 'B'.
!!! related TS2728 generics2.ts:2:25: 'b' is declared here.
    var v4: G<G<A, B>, C>;         // Ok
    var v5: G<any, any>;           // Error, any does not satisfy constraint B
    var v6: G<any>;                // Error, wrong number of arguments
            ~~~~~~
!!! error TS2314: Generic type 'G<T, U>' requires 2 type argument(s).
    var v7: G;                     // Error, no type arguments
            ~
!!! error TS2314: Generic type 'G<T, U>' requires 2 type argument(s).
```

----------------------------------------

TITLE: Assigning String to Boolean in TypeScript
DESCRIPTION: This snippet demonstrates a TypeScript type error where a variable of type 'string' is assigned to a variable explicitly typed as 'boolean'. TypeScript's strict type checking prevents this assignment, as 'string' is not assignable to 'boolean'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/invalidStringAssignments.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var x = '';
var a: boolean = x;
```

----------------------------------------

TITLE: Project Configuration (package.json)
DESCRIPTION: This 'package.json' file configures the project, setting its name, 'private' status, and crucially, defining the 'type' as 'module'. This "type": "module" setting is essential for enabling ES module syntax and behavior within the project, influencing how TypeScript compiles and resolves imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportAttributes(module=nodenext).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Demonstrating Type Assignment Error in TypeScript
DESCRIPTION: This snippet shows an incorrect type assignment in TypeScript where a variable `x` is explicitly typed as `number` but initialized with a string literal `""`. This leads to a `TS2322` compilation error, enforcing TypeScript's strict type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noEmitOnError.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var x: number = "";
```

----------------------------------------

TITLE: Function Parameter Destructuring with Default Values in TypeScript
DESCRIPTION: This snippet showcases a TypeScript function 'foo1' that utilizes array destructuring for its parameter, including default values for both the destructured element ('skillA') and the entire parameter if not provided. The JavaScript output illustrates how TypeScript compiles this advanced syntax into standard variable assignments and conditional checks within the function body.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringParametertArrayBindingPatternDefaultValues2.sourcemap.txt#_snippet_1

LANGUAGE: JavaScript
CODE:
```
function foo1(_a) {
    var _b = _a === void 0 ? ["name", ["skill1", "skill2"]] : _a, _c = _b[1], skillA = _c === void 0 ? ["noSkill", "noSkill"] : _c;
}
```

LANGUAGE: TypeScript
CODE:
```
function foo1([, skillA = ["noSkill", "noSkill"]]: Robot= ["name", ["skill1", "skill2"]])
```

----------------------------------------

TITLE: Generic Discriminated Union Type Inference Limitation (f60)
DESCRIPTION: Highlights a limitation in TypeScript's type inference when using a generic type parameter `T` that extends a discriminated union. Despite the `if` checks, `payload` is not correctly narrowed, leading to type errors. This is a known reproduction case for a specific TypeScript issue.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/dependentDestructuredVariables.errors.txt#_snippet_29

LANGUAGE: TypeScript
CODE:
```
type Func = <T extends ["a", number] | ["b", string]>(...args: T) => void;

const f60: Func = (kind, payload) => {
    if (kind === "a") {
        payload.toFixed();  // error
    }
    if (kind === "b") {
        payload.toUpperCase();  // error
    }
};
```

----------------------------------------

TITLE: Correct Usage of React Component with Boolean-Returning Prop
DESCRIPTION: This snippet demonstrates the correct usage of the `FieldFeedback` component where the `when` prop is assigned a function that explicitly returns a boolean value, satisfying the component's prop type definition.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/reactDefaultPropsInferenceSuccess.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
const Test1 = () => <FieldFeedback when={value => !!value} />;
```

----------------------------------------

TITLE: Root package.json with Export Map
DESCRIPTION: The `package.json` file for the root 'package', defining its name, private status, module type as 'module' (ESM), and an 'exports' map. The 'exports' map specifies entry points for CommonJS (`./cjs`), ES Modules (`./mjs`), and the default entry (`.`) for the package.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageExports(module=node20).errors.txt#_snippet_6

LANGUAGE: json
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module",
    "exports": {
        "./cjs": "./index.cjs",
        "./mjs": "./index.mjs",
        ".": "./index.js"
    }
}
```

----------------------------------------

TITLE: Avoiding Promise Truthiness Errors with Object Properties in TypeScript
DESCRIPTION: This snippet focuses on TS2801 errors when a Promise is accessed as an object property (e.g., `obj.p`) and used in a conditional expression. It demonstrates that while the property itself is always defined, awaiting its resolution (`await obj.p`) is necessary to evaluate the condition based on the promise's fulfilled value, thus avoiding the error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/truthinessPromiseCoercion.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
async function h() {
    if (obj.p) {} // error
        ~~~~~
// error TS2801: This condition will always return true since this 'Promise<unknown>' is always defined.
// related TS2773 truthinessPromiseCoercion.ts:32:9: Did you forget to use 'await'?
    if (obj.p) {  // ok
        await obj.p;
    }
    if (obj.p && await obj.p) {} // ok
}
```

----------------------------------------

TITLE: Using Object.values in TypeScript with TS2550 Error
DESCRIPTION: This snippet demonstrates the `TS2550` error when attempting to use `Object.values` in TypeScript without the `es2017` or later library. The error indicates that the 'values' property does not exist on 'ObjectConstructor' in the current target library. To resolve this, the `lib` compiler option in `tsconfig.json` must be set to 'es2017' or newer.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/useObjectValuesAndEntries3.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var o = { a: 1, b: 2 };

for (var x of Object.values(o)) {
    let y = x;
}
```

----------------------------------------

TITLE: Simple Variable Declaration in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates a basic variable declaration, initializing `test` with the numeric value `10`. It's a straightforward example of type inference in TypeScript for a number literal.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/jsFileCompilationDifferentNamesNotSpecifiedWithAllowJs/node/jsFileCompilationDifferentNamesNotSpecifiedWithAllowJs.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
var test = 10;
```

----------------------------------------

TITLE: Excess Property in Array of Book Objects in TypeScript
DESCRIPTION: This snippet demonstrates an excess property error within an array of 'Book' objects. The second object literal in the array contains 'forwards', which is not a property of 'Book', resulting in a TS2353 error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/objectLiteralExcessProperties.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
var b3: Book | (Book[]) = [{ foreword: "hello" }, { forwards: "back" }];
```

----------------------------------------

TITLE: Migrating tsconfig.json to Verbatim Module Syntax (JSON)
DESCRIPTION: This snippet demonstrates the updated `tsconfig.json` configuration, showing the removal of deprecated options like `importsNotUsedAsValues` and `preserveValueImports` and the addition of `verbatimModuleSyntax: true`. This change aligns with modern TypeScript module resolution practices, ensuring consistent import behavior.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/verbatimModuleSyntaxCompat3.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "verbatimModuleSyntax": true
    }
}
```

----------------------------------------

TITLE: Using 'await using' in Async Functions and Generators (TypeScript)
DESCRIPTION: Demonstrates the correct usage of the 'await using' statement within asynchronous functions and async generator functions in TypeScript. This syntax is used for asynchronous resource management, ensuring resources are disposed of properly when the scope exits.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarations.1(target=es2015).errors.txt#_snippet_5

LANGUAGE: typescript
CODE:
```
await using d7 = { async [Symbol.asyncDispose]() {} };
};

async am() {
    await using d13 = { async [Symbol.asyncDispose]() {} };
    await null;
}

async * ag() {
    await using d15 = { async [Symbol.asyncDispose]() {} };
    yield;
    await null;
}
```

----------------------------------------

TITLE: Exporting Uninitialized Const in TypeScript If Statement
DESCRIPTION: This TypeScript snippet attempts to declare and export a `const` variable, `cssExports`, without initialization, directly inside an `if` statement. This setup triggers multiple compiler errors: TS1184 (Modifiers cannot appear here) because `export` is not allowed directly within an `if` block, TS1155 ('const' declarations must be initialized) due to the lack of an initial value, and TS2304 (Cannot find name 'CssExports') as the type `CssExports` is undefined in this scope. The code then tries to export `cssExports` as the default.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportNonInitializedVariablesInIfThenStatementNoCrash1(module=commonjs).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// https://github.com/microsoft/TypeScript/issues/59373

if (true)
export const cssExports: CssExports;
export default cssExports;
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options
DESCRIPTION: This snippet defines the TypeScript compiler options in `tsconfig.json`. It enables JavaScript file processing (`allowJs`), disables declaration file generation (`declaration`), sets module resolution to `node`, and limits the depth for JavaScript module resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/nodeModulesImportHigher/node/nodeModulesImportHigher.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "compilerOptions": { 
        "allowJs": true,
        "declaration": false,
        "moduleResolution": "node",
        "maxNodeModuleJsDepth": 2
      }
    }
```

----------------------------------------

TITLE: Example of an ECMAScript Module (ESM) File
DESCRIPTION: A simple TypeScript file demonstrating the basic structure of an ECMAScript module. The `export` keyword makes `x` available for import in other modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node20).errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
const x = 1;
export {x};
```

----------------------------------------

TITLE: Exporting Constants in TypeScript
DESCRIPTION: This TypeScript snippet defines and exports two simple numeric constants, `a` and `b`. These constants are intended to be imported and used by other modules within the same project, demonstrating basic module export syntax.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportAsNamespace2(module=system).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export const a = 1;
export const b = 2;
```

----------------------------------------

TITLE: Updating a Collection Persistently in TypeScript
DESCRIPTION: The `update` method applies a transformation function to the collection, returning a new collection with the changes. This method is designed for immutable data structures, ensuring the original collection remains unchanged.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/complexRecursiveCollections.errors.txt#_snippet_50

LANGUAGE: TypeScript
CODE:
```
update<R>(updater: (value: this) => R): R;
```

----------------------------------------

TITLE: Testing Math.log10 in TypeScript
DESCRIPTION: This snippet demonstrates a TypeScript TS2550 error where the `log10` property is not found on `Math`. This typically occurs when the TypeScript compiler's `lib` option does not include `es2015` or later, which defines the `Math.log10` method. To resolve this, update the `lib` compiler option in `tsconfig.json` to `es2015` or a newer version.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/doYouNeedToChangeYourTargetLibraryES2015.errors.txt#_snippet_35

LANGUAGE: TypeScript
CODE:
```
const testMathLog10 = Math.log10(0);
```

----------------------------------------

TITLE: Dynamic `import()` Behavior with ESM Resolver in TypeScript
DESCRIPTION: This snippet explores the behavior of dynamic `import()` expressions in TypeScript, specifically when using the ESM resolver. It demonstrates that dynamic imports do not automatically resolve file extensions or index files, leading to `TS2307`, `TS2834`, and `TS2835` errors when explicit extensions are missing or paths are ambiguous. This highlights a key difference in resolution logic compared to `require`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=nodenext).errors.txt#_snippet_26

LANGUAGE: TypeScript
CODE:
```
const _m35 = import("./");
const _m36 = import("./index");
const _m37 = import("./subfolder");
const _m38 = import("./subfolder/");
const _m39 = import("./subfolder/index");
const _m40 = import("./subfolder2");
const _m41 = import("./subfolder2/");
const _m42 = import("./subfolder2/index");
```

----------------------------------------

TITLE: Declaring Function with Object Destructuring and Default Initializer (TypeScript)
DESCRIPTION: Shows a function c1 with an object destructuring parameter that has a default initializer, implying z is a number.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/destructuringParameterDeclaration1ES5iterable.errors.txt#_snippet_14

LANGUAGE: TypeScript
CODE:
```
function c1({z} = { z: 10 }) { }
```

----------------------------------------

TITLE: Type Narrowing with 'in' Operator and Custom Guards in TypeScript
DESCRIPTION: This snippet defines Foo and Bar types, where Bar extends Foo. It shows how the 'in' operator can be used within filter to narrow an array of Foo | Bar to Bar[]. Additionally, it defines isBarNonNull as a custom type guard function, demonstrating its use in an if statement to correctly narrow the type of fooOrBar to Bar.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/inferTypePredicates.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
type Foo = {
  foo: string;
}
type Bar = Foo & {
  bar: string;
}

const list: (Foo | Bar)[] = [];
const resultBars: Bar[] = list.filter((value) => 'bar' in value);

function isBarNonNull(x: Foo | Bar | null) {
  return ('bar' in x!);
}
const fooOrBar = list[0];
if (isBarNonNull(fooOrBar)) {
  const t: Bar = fooOrBar;
}
```

----------------------------------------

TITLE: Using `require` for Node.js modules in TypeScript
DESCRIPTION: This code uses the `require` function to import a Node.js module. The `TS2580` error occurs because TypeScript cannot find the global `require` definition, which is common in Node.js environments. To fix this, install the Node.js type definitions: `npm i --save-dev @types/node`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/didYouMeanSuggestionErrors.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
const x = require("fs");
```

----------------------------------------

TITLE: Importing Modules in ES Module (index.js)
DESCRIPTION: This snippet demonstrates how modules are imported in an ECMAScript module (ESM) formatted file (`.js` when `"type": "module"` is set in `package.json`). It imports CommonJS, ES module, and a type-defined module using import map aliases, showcasing standard ESM import syntax without errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageImports(module=node16).errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as cjs from "#cjs";
import * as mjs from "#mjs";
import * as type from "#type";
cjs;
mjs;
type;
```

----------------------------------------

TITLE: Exporting Variable in ESM Format
DESCRIPTION: This snippet demonstrates a basic ECMAScript Module (ESM) export, where a constant 'x' is defined and then exported from the module, making it available for import by other ESM modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=nodenext).errors.txt#_snippet_21

LANGUAGE: JavaScript
CODE:
```
const x = 1;
export {x};
```

----------------------------------------

TITLE: Incorrectly Instantiating Type-Only Import (TypeScript)
DESCRIPTION: This snippet demonstrates the incorrect usage of a type-only import. 'import type A from './a'' imports 'A' solely as a type, but 'new A()' attempts to use 'A' as a constructor (a value), leading to a TS1361 error because type imports cannot be used at runtime.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/importClause_default.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import type A from './a';
new A();
```

----------------------------------------

TITLE: Type Mismatch with 'satisfies' Keyword in TypeScript
DESCRIPTION: This snippet illustrates a TypeScript error (TS2322) where a string literal 'false' is assigned to property 's' in an object 'x2' that `satisfies` the `Facts` type. The `Facts` type expects boolean values for all properties, leading to a type mismatch. It also includes correct boolean assignment and `keyof` type usage for context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeSatisfaction_propertyValueConformance2(nouncheckedindexedaccess=false).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
const m: boolean = x.m;

// Should be 'm'
type M = keyof typeof x;

// Should be able to detect a failure here
const x2 = {
    m: true,
    s: "false"
} satisfies Facts;
```

----------------------------------------

TITLE: Defining and Using React Functional Component Returning JSX Element
DESCRIPTION: This snippet defines `RenderElement`, a functional React component that accepts a `title` prop and renders it within a `div` element. It demonstrates assigning this component to the `Component` variable and shows examples of JSX usage, including cases that would trigger TypeScript errors for missing or excess properties, illustrating robust type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxElementType.errors.txt#_snippet_4

LANGUAGE: TSX
CODE:
```
const RenderElement = ({ title }: { title: string }) => <div>{title}</div>;
Component = RenderElement;
<RenderElement />;
<RenderElement title="react" />;
<RenderElement excessProp />;
```

----------------------------------------

TITLE: Implementing the Render Method with JSX
DESCRIPTION: This snippet defines the `render` method within the `AppComponent`. It illustrates how a simple JSX `div` element in TypeScript (`<div />`) is transpiled into a `createElement` function call in the generated JavaScript (`createElement("div", null)`), which is the core of component rendering.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxFactoryIdentifierAsParameter.sourcemap.txt#_snippet_1

LANGUAGE: JavaScript
CODE:
```
    render(createElement) {
        return createElement("div", null);
    }
```

LANGUAGE: TypeScript
CODE:
```
    render(createElement) {
        return <div />;
    }
```

----------------------------------------

TITLE: Generic Function for Dynamic Nested Property Access
DESCRIPTION: This function provides a more generalized way to access a nested 'x' property. It takes an object 'obj' and a key 'K' (which is a key of 'obj') and returns the 'x' property of the object found at 'obj[key]'. The return type 'T[K]['x']' ensures type safety and correct inference for the dynamically accessed nested property.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess.errors.txt#_snippet_43

LANGUAGE: TypeScript
CODE:
```
function f83<T extends { [x: string]: { x: any } }, K extends keyof T>(obj: T, key: K) {
    return obj[key]['x'] as T[K]['x'];
}
```

----------------------------------------

TITLE: Using 'this' in setTimeout Callback with Arrow Function in TypeScript
DESCRIPTION: This snippet defines a 'messenger' object with a 'message' property and a 'start' method. The 'start' method uses 'setTimeout' with an arrow function callback. The arrow function correctly captures the 'this' context from the 'start' method, allowing access to 'this.message' without binding issues.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/thisBinding2.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
declare function setTimeout(expression: any, msec?: number, language?: any): number;
var messenger = {
    message: "Hello World",
    start: function () {
        return setTimeout(() => { var x = this.message; }, 3000);
    }
};
```

----------------------------------------

TITLE: Defining Conditional Exports in package.json (JSON)
DESCRIPTION: This 'package.json' defines conditional exports for the 'conditions' module, specifying different entry points for 'node' and 'default' (web) environments. It also sets the module type to 'module' and defines main and types fields, influencing how bundlers and Node.js resolve imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/bundlerConditionsExcludesNode(module=preserve).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "name": "conditions",
    "version": "1.0.0",
    "type": "module",
    "main": "index.cjs",
    "types": "index.d.cts",
    "exports": {
      ".": {
        "node": "./index.node.js",
        "default": "./index.web.js"
      }
    }
  }
```

----------------------------------------

TITLE: Base Class with Generic Property Getters and Setters
DESCRIPTION: The 'Base' class provides a foundational structure for other classes to inherit type-safe property access. It defines generic 'get' and 'set' methods using 'keyof this' and 'this[K]', allowing subclasses to manipulate their own properties dynamically while benefiting from TypeScript's type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess.errors.txt#_snippet_50

LANGUAGE: TypeScript
CODE:
```
class Base {
    get<K extends keyof this>(prop: K) {
        return this[prop];
    }
    set<K extends keyof this>(prop: K, value: this[K]) {
        this[prop] = value;
    }
}
```

----------------------------------------

TITLE: CommonJS Module Importing ES Module in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates a CommonJS module (`subfolder/index.ts`) attempting to import an ECMAScript module (`../index.js`) using both standard ES import syntax and CommonJS `require`. It highlights TS1479 and TS1471 errors, indicating incompatibility, and suggests dynamic `import()` as a potential workaround.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesSynchronousCallErrors(module=node18).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// cjs format file
    import {h} from "../index.js";
    import mod = require("../index.js");
    import {f as _f} from "./index.js";
    import mod2 = require("./index.js");
    export async function f() {
        const mod3 = await import ("../index.js");
        const mod4 = await import ("./index.js");
        h();
    }
```

----------------------------------------

TITLE: Assigning Properties to 'this', 'window', and 'globalThis' in JavaScript/TypeScript
DESCRIPTION: This snippet demonstrates various methods of property assignment in JavaScript. It shows assigning 'x' to 'this', declaring 'y' with 'var', assigning 'z' to the global 'window' object (which triggers a TypeScript error due to type safety), and assigning 'alpha' to 'globalThis'. The TypeScript error TS2339 indicates that new properties cannot be directly added to the 'Window' type without explicit declaration.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/globalThisPropertyAssignment.errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
this.x = 1
var y = 2
// should work in JS
window.z = 3
// should work in JS (even though it's a secondary declaration)
globalThis.alpha = 4
```

----------------------------------------

TITLE: Illustrating `using` Declaration Binding Pattern Error in TypeScript
DESCRIPTION: This snippet demonstrates an invalid `using` declaration where a binding pattern (`{b}`) is used. TypeScript disallows binding patterns in `using` declarations, leading to error TS1492. Additionally, attempting to destructure `b` from `null` results in error TS2339, as `null` has no properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/usingDeclarations.7.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
{
        using a = null,
              {b} = null,
              c = null;
    }
```

----------------------------------------

TITLE: Object Destructuring with Nested Defaults in TypeScript
DESCRIPTION: This snippet demonstrates object destructuring with nested default values. It extracts 'primary' and 'secondary' properties from a 'skills' object. If 'skills' is undefined, it defaults to { primary: 'nosKill', secondary: 'noSkill' }. Additionally, 'primaryA' and 'secondaryA' are assigned default string values ('primary', 'secondary') if their respective properties are missing from the 'skills' object.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_16

LANGUAGE: TypeScript
CODE:
```
skills: { primary: primaryA = "primary", secondary: secondaryA = "secondary" } =
    { primary: "nosKill", secondary: "noSkill" }
```

----------------------------------------

TITLE: CommonJS Importing Index File (ESM) without Extension in TypeScript
DESCRIPTION: This snippet demonstrates a static 'import' in a CommonJS module attempting to import an 'index' file without an explicit extension, which resolves to an ECMAScript Module. This triggers a TS1479 error, as CommonJS modules cannot statically import ESMs and require dynamic imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node16).errors.txt#_snippet_31

LANGUAGE: TypeScript
CODE:
```
import * as m14 from "./index";
```

----------------------------------------

TITLE: Defining Package Exports in Node.js (JSON)
DESCRIPTION: This `package.json` defines the `exports` field, crucial for controlling how a package's modules are resolved. It specifies different entry points for `import` (ESM), `require` (CommonJS), and `types` (TypeScript declarations), directing module bundlers and Node.js to the correct files based on the import context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/conditionalExportsResolutionFallback(moduleresolution=nodenext).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "name": "dep",
  "version": "1.0.0",
  "exports": {
    ".": {
        "import": "./dist/index.mjs",
        "require": "./dist/index.js",
        "types": "./dist/index.d.ts"
    }
  }
}
```

----------------------------------------

TITLE: Avoiding Implicit Any with Explicit Types in TypeScript
DESCRIPTION: This snippet demonstrates how to avoid 'implicit any' errors by explicitly declaring types or initializing variables. It shows examples of variables initialized with a value, explicitly typed as 'any', and declared global variables with an 'any' type annotation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/implicitAnyDeclareVariablesWithoutTypeAndInit.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
// this shouldn't be an error
var bar = 3;            
var bar1: any;          
declare var bar2: any; 
var x1: any; var y1 = new x1;
```

----------------------------------------

TITLE: Discriminated Union Narrowing Without Generic Type Parameters (Working)
DESCRIPTION: This snippet shows the correct and expected behavior of type narrowing for discriminated unions when a concrete union type `Pet` is used directly as the parameter type. After the check `if(pet.type === 'dog')`, TypeScript successfully narrows the type of `pet` to `Dog`, allowing direct and safe access to the `saysWoof` property without errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/narrowingOfQualifiedNames.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function handleDogWorking(pet: Pet) {
    if(pet.type === 'dog') {
        const _okay1 = pet.saysWoof;
        const _okay2: typeof pet.saysWoof = pet.saysWoof;
    }
}
```

----------------------------------------

TITLE: Calling Overloaded Method with Mismatched Type in TypeScript
DESCRIPTION: This snippet defines an `EventAggregator` class with two `publish` overloads. The first expects a `string` event and optional `data`, while the second is a generic implementation. The error occurs when attempting to call `ea.publish` with a `number[]` array, which does not match the `string` parameter of the externally visible overload, despite the generic implementation existing. The TS2793 error further clarifies that the implementation signature is not externally visible.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/overloadErrorMatchesImplementationElaboaration.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class EventAggregator
{
    publish(event: string, data?: any): void;
    publish<T>(event: T): void {}
}

var ea: EventAggregator;
ea.publish([1,2,3]);
```

----------------------------------------

TITLE: Array Destructuring with Default Value in TypeScript
DESCRIPTION: This snippet demonstrates array destructuring in TypeScript, assigning elements from the 'robotA' array to variables. It includes a default value for 'numberA3' if the corresponding array element is undefined, and uses a rest element 'robotAInfo' to capture remaining elements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementArrayBindingPatternDefaultValues.sourcemap.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
let [numberA3 = -1, ...robotAInfo] = robotA;
```

----------------------------------------

TITLE: Defining Base and Extended Classes - TypeScript
DESCRIPTION: This snippet defines a base class `A` with a string property `foo` and an extended class `B` that inherits from `A` and adds a string property `bar`. These classes serve as fundamental types used in subsequent type compatibility and member access tests.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/objectTypeHidingMembersOfExtendedObject.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class A {
    foo: string;
}

class B extends A {
    bar: string;
}
```

----------------------------------------

TITLE: Deep Property Type Inference for Object Paths in TypeScript
DESCRIPTION: The `PropType` utility type recursively infers the type of a nested property given an object type `T` and a dot-separated path string `P`. The `getPropValue` function then leverages this type to provide type-safe access to deeply nested properties, returning `unknown` for invalid or dynamic paths.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes1.errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
type PropType<T, Path extends string> =
    string extends Path ? unknown :
    Path extends keyof T ? T[Path] :
    Path extends `${infer K}.${infer R}` ? K extends keyof T ? PropType<T[K], R> : unknown :
    unknown;

declare function getPropValue<T, P extends string>(obj: T, path: P): PropType<T, P>;
declare const s: string;

const obj = { a: { b: {c: 42, d: 'hello' }}};

getPropValue(obj, 'a');  // { b: {c: number, d: string } }
getPropValue(obj, 'a.b');  // {c: number, d: string }
getPropValue(obj, 'a.b.d');  // string
getPropValue(obj, 'a.b.x');  // unknown
getPropValue(obj, s);  // unknown
```

----------------------------------------

TITLE: Illustrating 'this' Shadowing in TypeScript
DESCRIPTION: This snippet demonstrates the TypeScript error TS2683, where 'this' inside a nested regular function implicitly becomes 'any' because it shadows the 'this' context of the outer method. It also highlights the related TS2738 error, which explicitly points out the shadowing issue. To fix this, an arrow function should be used for `f`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/thisShadowingErrorSpans.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class C {
    m() {
        this.m();
        function f() {
            this.m();
        }
    }
}
```

----------------------------------------

TITLE: Implementing JSX Component Overloads with Optional Props in TSX
DESCRIPTION: This snippet demonstrates how to define and use JSX component overloads where properties can be optional or required, and of different types (string, number, boolean). It shows various valid ways to invoke the `TestingOptional` component, highlighting how TypeScript handles optional props and resolves the appropriate overload.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxStatelessFunctionComponentOverload1.errors.txt#_snippet_2

LANGUAGE: TSX
CODE:
```
declare function TestingOptional(a: {y1?: string, y2?: number}): JSX.Element;
declare function TestingOptional(a: {y1: boolean, y2?: number, y3: boolean}): JSX.Element;

// OK
const e1 = <TestingOptional />
const e3 = <TestingOptional y1="hello"/>
const e4 = <TestingOptional y1="hello" y2={1000} />
const e5 = <TestingOptional y1 y3/>
const e6 = <TestingOptional y1 y3 y2={10} />
const e2 = <TestingOptional y1 y3 extra-prop/>
```

----------------------------------------

TITLE: Installing Jest Type Definitions via npm
DESCRIPTION: This command suggests installing the `@types/jest` package as a development dependency. This is a common solution for resolving the `TS2582: Cannot find name 'test'` error when 'test' refers to a Jest-related global or decorator.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/metadataImportType.errors.txt#_snippet_1

LANGUAGE: Shell
CODE:
```
npm i --save-dev @types/jest
```

----------------------------------------

TITLE: Importing and Using TypeScript Type-Only Exports (Error)
DESCRIPTION: This snippet imports `A`, `C` (aliased `B`), and `X` from `./b.ts`. It demonstrates that `A` and `C` (from `export type *`) cannot be instantiated as values, resulting in TS1362 errors, while `X` (from `export { X }`) can be used as a value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportNamespace5.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { A, B as C, X } from "./b";
let _: A = new A();   // Error
let __: C = new C();  // Error
let ___: X = new X(); // Ok
```

----------------------------------------

TITLE: Iterating with For-Of Loop and Destructuring in TypeScript
DESCRIPTION: This snippet shows a modern TypeScript `for...of` loop, iterating directly over an array of objects. It utilizes object destructuring with renaming (`name: nameA`, `skill: skillA`) to extract properties directly into new variables, offering a more concise and readable iteration pattern.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPattern.sourcemap.txt#_snippet_27

LANGUAGE: TypeScript
CODE:
```
for (let {name: nameA, skill: skillA } of [{ name: "mower", skill: "mowing" }, { name: "trimmer", skill: "trimming" }]) {
```

----------------------------------------

TITLE: instanceof Behavior with Inheritance and Structural Types (TypeScript)
DESCRIPTION: The `goo` function illustrates how `instanceof` narrows types based on class inheritance and structural identity. It shows that `x instanceof A` correctly narrows `x` to `A` (and `never` in the `else` branch, as `x` is already known to be `A`). For `A1` and `B` (subclasses of `A`), `instanceof` correctly narrows to the subclass. However, for `A2` (structurally identical but not inheriting from `A`), `instanceof A2` still narrows to `A2` within its block, and `A` in the `else` block, demonstrating that `instanceof` checks the prototype chain, not just structural compatibility.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/instanceofWithStructurallyIdenticalTypes.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
function goo(x: A) {
    if (x instanceof A) {
        x;  // A
    }
    else {
        x;  // never
    }
    if (x instanceof A1) {
        x;  // A1
    }
    else {
        x;  // A
    }
    if (x instanceof A2) {
        x;  // A2
    }
    else {
        x;  // A
    }
    if (x instanceof B) {
        x;  // B
    }
    else {
        x;  // A
    }
}
```

----------------------------------------

TITLE: Logging Variable to Console in JavaScript/TypeScript
DESCRIPTION: This snippet demonstrates how to output the value of a variable to the console using `console.log()`. It's a fundamental debugging and output mechanism in JavaScript and TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForArrayBindingPattern.sourcemap.txt#_snippet_51

LANGUAGE: JavaScript
CODE:
```
console.log(nameMA);
```

----------------------------------------

TITLE: Declaring TRPCBuilder and initTRPC in tRPC Server
DESCRIPTION: This snippet declares the `TRPCBuilder` class, which provides the `create` method for initializing tRPC. It also exports `initTRPC`, an instance of `TRPCBuilder`, serving as the entry point for creating tRPC procedures, middleware, and routers. It imports various internal types for its configuration.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationEmitIsolatedDeclarationErrorNotEmittedForNonEmittedFile.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { RootConfig } from './internals/config';
import { ErrorFormatterShape, PickFirstDefined, ErrorFormatter, DefaultErrorShape } from './internals/utils';
declare class TRPCBuilder<TParams> {
    create<TOptions extends Record<string, any>>(): {
        procedure: {};
        middleware: <TNewParams extends Record<string, any>>(fn: import("./middleware").MiddlewareFunction<{
            _config: RootConfig<{
                errorShape: ErrorFormatterShape<PickFirstDefined<TOptions["errorFormatter"], ErrorFormatter<TParams["ctx"] extends object ? TParams["ctx"] : object, DefaultErrorShape>>>;
            }>;
        }, TNewParams>) => import("./middleware").MiddlewareBuilder<{
            _config: RootConfig<{
                errorShape: ErrorFormatterShape<PickFirstDefined<TOptions["errorFormatter"], ErrorFormatter<TParams["ctx"] extends object ? TParams["ctx"] : object, DefaultErrorShape>>>;
            }>;
        }, TNewParams>;
        router: {};
    };
}

export declare const initTRPC: TRPCBuilder<object>;
```

----------------------------------------

TITLE: Using Pick Utility Type and Accessing Non-Picked Property in TypeScript
DESCRIPTION: This example shows the usage of the `Pick` utility type to select specific properties ('a', 'c') from an object. Attempting to access a property ('b') that was not included in the `Pick` operation results in a `TS2339` error, as 'b' does not exist on the resulting `Pick` type.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofIsLiteralContexualType.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
declare function pick<T, K extends keyof T>(obj: T, propNames: K[]): Pick<T, K};

let x = pick({ a: 10, b: 20, c: 30 }, ["a", "c"]);
let b = x.b;  // Error
```

----------------------------------------

TITLE: Checking Strict Inequality (!==) with NaN in TypeScript
DESCRIPTION: This snippet illustrates strict inequality checks (`!==`) with the global `NaN` constant. TypeScript correctly infers that these conditions will always return `true` because `NaN` is never strictly equal to any value, thus it's always strictly unequal. The compiler suggests using `!Number.isNaN(x)` for proper `NaN` checks.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nanEquality.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
if (x !== NaN) {}
if (NaN !== x) {}
```

----------------------------------------

TITLE: Defining ES Module Type in package.json - JSON
DESCRIPTION: This `package.json` snippet configures a package to be treated as an ES module by setting `"type": "module"`. This influences how Node.js resolves imports and exports within the package, enabling native ES module syntax.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions2(module=nodenext).errors.txt#_snippet_4

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Installing Node.js Type Definitions (Shell)
DESCRIPTION: This shell command uses npm to install the `@types/node` package as a development dependency. This package provides the necessary TypeScript type definitions for Node.js APIs, resolving errors like TS2591 when 'module' or other Node.js globals are used in a TypeScript project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typingsSuggestion1.errors.txt#_snippet_2

LANGUAGE: Shell
CODE:
```
npm i --save-dev @types/node
```

----------------------------------------

TITLE: Sorting Array with ES2023 `toSorted` in TypeScript
DESCRIPTION: This snippet illustrates the use of the ES2023 `toSorted()` array method. Unlike the traditional `sort()` method, `toSorted()` returns a new array with the elements sorted, leaving the original array unchanged. This is a non-mutating alternative for sorting.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/doYouNeedToChangeYourTargetLibraryES2023(target=esnext).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
export let sorted = array.toSorted();
```

----------------------------------------

TITLE: TypeScript Source for Object Destructuring
DESCRIPTION: This TypeScript snippet demonstrates object destructuring, where the property 'x' is extracted from an object literal '{ x: 20 }' and assigned to a variable 'x' using a concise syntax. This is the original source code that compiles into the corresponding JavaScript shown in the emitted file.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementObjectBindingPattern1.sourcemap.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
var { x } = { x: 20 };
```

----------------------------------------

TITLE: Installing Type Declarations for a Module (Shell)
DESCRIPTION: This shell command is a common solution for the TS7016 error. It uses `npm` to install the official type declaration package (`@types/foo`) as a development dependency, providing TypeScript with the necessary type information for the 'foo' module.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/untypedModuleImport_noImplicitAny.errors.txt#_snippet_1

LANGUAGE: Shell
CODE:
```
npm i --save-dev @types/foo
```

----------------------------------------

TITLE: Array Destructuring with Default Values in TypeScript
DESCRIPTION: This snippet demonstrates array destructuring in TypeScript/JavaScript. It assigns values from the right-hand side array `["skill1", "skill2"]` to `primarySkillA` and `secondarySkillA`. Default values (`"primary"` and `"secondary"`) are provided for each variable, ensuring they have a fallback value if the corresponding array element is `undefined`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfArrayBindingPatternDefaultValues2.sourcemap.txt#_snippet_31

LANGUAGE: TypeScript
CODE:
```
[
    primarySkillA = "primary",
    secondarySkillA = "secondary"
] = ["skill1", "skill2"]
```

----------------------------------------

TITLE: Defining and Exporting TypeScript Components
DESCRIPTION: This snippet demonstrates various ways to define and export components in TypeScript, including a class, a named function, and a default function. It showcases common module export patterns for reusability.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unusedImports7.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export class Calculator {
    handleChar() {}
}
    
export function test() {

}
    
export default function test2() {

}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options in tsconfig.json
DESCRIPTION: This `tsconfig.json` file configures the TypeScript compiler. It sets the target to ES5, module system to CommonJS, enables decorator metadata and experimental decorators, and uses `isolatedModules` and `noResolve`. The `files` array explicitly includes `main.ts`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/emitDecoratorMetadataCommonJSISolatedModulesNoResolve/node/emitDecoratorMetadataCommonJSISolatedModulesNoResolve.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "compileOnSave": true,
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "isolatedModules": true,
    "noResolve": true
  },
  "files": [
    "main.ts"
  ]
}
```

----------------------------------------

TITLE: Defining Discriminated Union Types for Shapes in TypeScript
DESCRIPTION: Defines three interfaces (`Square`, `Rectangle`, `Circle`) each with a unique `kind` literal type, and then creates a `Shape` union type from these interfaces. This pattern allows TypeScript to narrow down the type of a `Shape` based on its `kind` property.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
interface Square {
    kind: "square";
    size: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Circle {
    kind: "circle";
    radius: number;
}

type Shape = Square | Rectangle | Circle;
```

----------------------------------------

TITLE: Declaring JSX Global Module in TypeScript
DESCRIPTION: This snippet defines the global `JSX` module, which is essential for TypeScript to understand JSX syntax. It declares `Element` as the type for JSX elements and `IntrinsicElements` to allow any string as a valid intrinsic element, mapping them to `any`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxParsingError2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare module JSX {
	interface Element { }
	interface IntrinsicElements {
		[s: string]: any;
	}
}
```

----------------------------------------

TITLE: Destructuring Nested Object Properties with Defaults - JavaScript
DESCRIPTION: This snippet demonstrates how to destructure nested 'skills' object properties ('primary' and 'secondary') from a 'robotA' object. It assigns default values ('noSkill') if the properties are missing or undefined, and also provides a default empty 'skills' object if 'robotA.skills' itself is undefined, ensuring safe access.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementNestedObjectBindingPatternWithDefaultValues.sourcemap.txt#_snippet_4

LANGUAGE: JavaScript
CODE:
```
var {
    skills: {
        primary: primaryA = "noSkill",
        secondary: secondaryA = "noSkill"
    } = { primary: "noSkill", secondary: "noSkill" }
} = robotA
```

----------------------------------------

TITLE: Exporting a Function in TypeScript
DESCRIPTION: Demonstrates a basic TypeScript module exporting a function named 'foo'. This function logs a message to the console when called, serving as a correct example of module definition.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/importDeferTypeConflict1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export function foo() {
  console.log("foo from a");
}
```

----------------------------------------

TITLE: ESM Imports in index.mts (TypeScript)
DESCRIPTION: This TypeScript file, explicitly marked as an ECMAScript module (.mts), demonstrates various import statements from 'package' and 'inner' modules. It successfully imports CommonJS, ESM, and type-only modules without errors, confirming correct ESM behavior.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackageExports(module=node16).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
// esm format file
    import * as cjs from "package/cjs";
    import * as mjs from "package/mjs";
    import * as type from "package";
    cjs;
    mjs;
    type;
    import * as cjsi from "inner/cjs";
    import * as mjsi from "inner/mjs";
    import * as typei from "inner";
    cjsi;
    mjsi;
    typei;
```

----------------------------------------

TITLE: NPM Package Configuration with Conditional Exports
DESCRIPTION: This `package.json` snippet defines a module with conditional exports for `import` and `require` contexts, directing consumers to different entry points based on their module resolution strategy. This configuration is crucial for packages designed to support both CommonJS and ES module environments.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportModeDeclarationEmitErrors1(module=node20).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Declaring `const` in Arrow Function Expression (TypeScript)
DESCRIPTION: Demonstrates the declaration of a `const` variable within an arrow function expression. The `const` is scoped to the arrow function's body.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/constDeclarations-validContexts.errors.txt#_snippet_16

LANGUAGE: TypeScript
CODE:
```
var F2 = () => {
    const c20 = 0;
};
```

----------------------------------------

TITLE: Nested Array Destructuring with Default Array and Element Values - TypeScript
DESCRIPTION: Demonstrates destructuring a nested array while skipping the first element of the outer array. It also shows how to provide a default array (["skill1", "skill2"]) if the corresponding element in the source array is undefined or null, and how to set default values for individual elements (primarySkillA, secondarySkillA) if they are undefined within the nested array.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfArrayBindingPatternDefaultValues.sourcemap.txt#_snippet_28

LANGUAGE: TypeScript
CODE:
```
[, [
    primarySkillA = "primary",
    secondarySkillA = "secondary"
] = ["skill1", "skill2"]]
```

----------------------------------------

TITLE: Declaring JSX Module Interfaces in TypeScript
DESCRIPTION: Defines the global JSX module interfaces, including 'Element' and 'IntrinsicElements', to enable JSX syntax recognition and type checking in TypeScript files. This is a common setup for projects using React or similar JSX-based libraries.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadChildrenInvalidType(jsx=react,target=es5).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare module JSX {
	interface Element { }
	interface IntrinsicElements {
		[s: string]: any;
	}
}
declare var React: any;
```

----------------------------------------

TITLE: Type Narrowing with Generics and Control Flow in TypeScript
DESCRIPTION: This function `f1` demonstrates how TypeScript's control flow analysis narrows generic types within conditional blocks. It takes a generic type `T` constrained to `string | undefined` and uses `if` statements to check for truthiness, allowing access to `string` properties like `length` and ensuring a `string` return type. It shows narrowing for direct parameters, object properties, and array elements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/controlFlowGenericTypes.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function f1<T extends string | undefined>(x: T, y: { a: T }, z: [T]): string {
    if (x) {
        x;
        x.length;
        return x;
    }
    if (y.a) {
        y.a.length;
        return y.a;
    }
    if (z[0]) {
        z[0].length;
        return z[0];
    }
    return "hello";
}
```

----------------------------------------

TITLE: Creating Scoped Action Types with Template Literals - TypeScript
DESCRIPTION: This snippet demonstrates how to create a factory function `createScopedActionType` that generates action type strings with a predefined scope. It leverages template literal types to infer and enforce the exact string literal type of the resulting action, ensuring type safety for actions like 'MyScope/MY_ACTION'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
const createScopedActionType = <S extends string>(scope: S) => <T extends string>(type: T) => `${scope}/${type}` as `${S}/${T}`;
const createActionInMyScope = createScopedActionType("MyScope");  // <T extends string>(type: T) => `MyScope/${T}`
const MY_ACTION = createActionInMyScope("MY_ACTION");  // 'MyScope/MY_ACTION'
```

----------------------------------------

TITLE: Ignoring Unused Array Destructuring Parameter with Underscore - TypeScript
DESCRIPTION: This snippet demonstrates the common TypeScript pattern of using an underscore `_` as a variable name in destructuring assignments to explicitly indicate that the parameter is intentionally unused. This suppresses the TS6133 error, allowing for cleaner code when a destructured value is not needed.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unusedDestructuringParameters.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
const f3 = ([_]) => { };
```

----------------------------------------

TITLE: Asserting Node is an HTML Element (TypeScript)
DESCRIPTION: This TypeScript type guard function checks if a given Node (or null) is an Element by inspecting its nodeType. It returns true if the node is an element (nodeType === 1), allowing TypeScript to narrow the type of 'node' within conditional blocks.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/intersectionsOfLargeUnions.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export function assertIsElement(node: Node | null): node is Element {
    let nodeType = node === null ? null : node.nodeType;
    return nodeType === 1;
}
```

----------------------------------------

TITLE: Testing Deep Path Type Narrowing with Assertion Functions in TypeScript
DESCRIPTION: This example demonstrates the usage of the `doesValueAtDeepPathSatisfy` function in conjunction with a custom `assert` assertion function. The `test1` and `test2` functions show how `Foo` (a union type) is narrowed based on the `type` property within its nested `value` object, using `isA` and `isB` type predicates. The `assert` function ensures that the type narrowing is applied correctly at compile time.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/strictSubtypeAndNarrowing.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
type Foo = {value: {type: 'A'}; a?: number} | {value: {type: 'B'}; b?: number};

declare function isA(arg: unknown): arg is 'A';
declare function isB(arg: unknown): arg is 'B';

declare function assert(condition: boolean): asserts condition;

function test1(foo: Foo): {value: {type: 'A'}; a?: number} {
    assert(doesValueAtDeepPathSatisfy(foo, ['value', 'type'], isA));
    return foo;
}

function test2(foo: Foo): {value: {type: 'A'}; a?: number} {
    assert(!doesValueAtDeepPathSatisfy(foo, ['value', 'type'], isB));
    return foo;
}
```

----------------------------------------

TITLE: Defining a Component with an Optional Prop and Default Value in TypeScript JSX
DESCRIPTION: This snippet defines a functional component `Meet` that accepts an optional `name` prop with a default value of 'world'. It showcases destructuring assignment for props and providing a default value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxStatelessFunctionComponents1.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
function Meet({name = 'world'}) {
	return <div>Hello, {name}</div>;
}
```

----------------------------------------

TITLE: Declaring JSX Namespace - TypeScript
DESCRIPTION: This TypeScript declaration file snippet defines an empty `JSX` namespace. This is crucial for providing type definitions for JSX elements, enabling TypeScript to correctly type-check JSX syntax in projects that use React or similar libraries, without containing any runtime implementation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/modulePreserve3.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export namespace JSX {}
```

----------------------------------------

TITLE: Re-exporting Types in TypeScript (Pre-Fix)
DESCRIPTION: This snippet attempts to re-export types `A` and `B` using standard `export` syntax. This will result in `TS1205` and `TS1448` errors when `isolatedModules` is enabled, as type-only re-exports require explicit `export type`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/preserveValueImports_errors(isolatedmodules=true).errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
export { A as AA } from "./a";
export { B as BB } from "./b";
```

----------------------------------------

TITLE: TypeScript Compiler Configuration for Module Resolution
DESCRIPTION: This `tsconfig.json` file configures the TypeScript compiler, setting `baseUrl` for relative module resolution, defining `paths` for custom module lookups, enabling `allowJs` for JavaScript files, and specifying `outDir` for compiled output. It's crucial for resolving modules correctly, though it currently lacks the `resolveJsonModule` option.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/requireOfJsonFileWithoutResolveJsonModuleAndPathMapping.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "compilerOptions": {
        "baseUrl": ".",
        "paths": {
            "*": ["node_modules/*", "src/types"]
        },
        "allowJs": true,
        "outDir": "bin"
    }
}
```

----------------------------------------

TITLE: Configuring Root `package.json` for ESM
DESCRIPTION: This `package.json` file configures the root project as an ECMAScript Module (ESM) by setting `"type": "module"`. This declaration affects how TypeScript and Node.js resolve imports and exports within the package, enabling native ESM behavior.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportHelpersCollisions(module=node16).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Illustrating TS17009 Error: 'this' before 'super' in TypeScript
DESCRIPTION: This TypeScript code snippet demonstrates the TS17009 error. It shows a derived class `Foo` attempting to pass `this` to the `super()` constructor call before `super()` itself has been executed, which is a common mistake leading to this specific compilation error. The error highlights that `this` is not yet initialized until the base class constructor has been invoked.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/thisInSuperCall1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class Base { 
    constructor(a: any) {}
}
    
class Foo extends Base {
    constructor(public x: number) {
        super(this);
    }
}
```

----------------------------------------

TITLE: Function Parameters with Explicit Type Annotations - TypeScript
DESCRIPTION: This snippet demonstrates the correct way to declare function parameters 'x' and 'y' in `noError2` by providing explicit type annotations (`number`, `string`). This prevents any implicit 'any' errors and ensures strong typing.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/implicitAnyDeclareFunctionWithoutFormalType.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
function noError2(x: number, y: string) { };
```

----------------------------------------

TITLE: Package.json Module Type Configurations
DESCRIPTION: These `package.json` examples illustrate how the `type` field influences module resolution in TypeScript projects. The `"type": "module"` specifies ES Modules, `"type": "commonjs"` specifies CommonJS, and an absent `type` field typically defaults to CommonJS behavior, affecting how `.ts`, `.mts`, and `.cts` files are interpreted.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesForbidenSyntax(module=node20).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

LANGUAGE: JSON
CODE:
```
{
    "type": "commonjs"
}
```

LANGUAGE: JSON
CODE:
```
{}
```

LANGUAGE: JSON
CODE:
```
{
    "type": "module"
}
```

----------------------------------------

TITLE: Demonstrating TypeScript Function Parameter Types and Errors
DESCRIPTION: This snippet defines a TypeScript function `foo` with an optional string parameter `a` and a rest parameter `b` of type number array. It then shows various calls to `foo`, including correct usages and an incorrect call that triggers a TS2345 error due to a type mismatch where a number is passed to a string parameter.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/functionCall14.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function foo(a?:string, ...b:number[]){}
foo('foo', 1);
foo('foo');
foo();
foo(1, 'bar');
foo('foo', 1, 3);
```

----------------------------------------

TITLE: Defining React Component Props with Union Types - TypeScript
DESCRIPTION: This snippet defines the `TextProps` type using a union, allowing the `editable` property to determine the presence of the `onEdit` callback. If `editable` is `true`, `onEdit` is required; otherwise, it's not present, enforcing type safety based on prop values.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadAttributesResolution6.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type TextProps = { editable: false }
               | { editable: true, onEdit: (newText: string) => void };
```

----------------------------------------

TITLE: Defining and Exporting TypeScript Modules
DESCRIPTION: This snippet illustrates how to define and export a class and functions in TypeScript. It includes a named class export (Calculator), a named function export (test), and a default function export (test2), making them accessible to other modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unusedImports6.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export class Calculator {
    handleChar() {}
}

export function test() {

}

export default function test2() {

}
```

----------------------------------------

TITLE: TypeScript Module Resolution Error Example (TS2307)
DESCRIPTION: This snippet illustrates a TypeScript TS2307 error, indicating that the module 'blah' or its corresponding type declarations could not be found. The code defines a function 'Foo' and then adds an expando property 'bar' to it, demonstrating a common scenario where module imports can lead to compilation errors if dependencies are not correctly resolved or installed.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/expandoFunctionContextualTypesNoValue.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// GH #38532
import Foo from "blah";

export function Foo() { }

Foo.bar = () => { };
```

----------------------------------------

TITLE: Simple TypeScript Module Export Example
DESCRIPTION: This snippet shows a basic TypeScript file (`f1.ts`) that exports a variable `x` with an initial value of 1. It serves as an example of a valid TypeScript module without compilation errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/pathMappingBasedModuleResolution1_node.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export var x = 1;
```

----------------------------------------

TITLE: Installing Latest Stable TypeScript (Bash)
DESCRIPTION: This command installs the latest stable version of TypeScript as a development dependency in your project using npm. It's typically used for setting up TypeScript in new or existing JavaScript projects, ensuring you have the most reliable release.
SOURCE: https://github.com/microsoft/typescript/blob/main/README.md#_snippet_0

LANGUAGE: bash
CODE:
```
npm install -D typescript
```

----------------------------------------

TITLE: `await using` in an Asynchronous Generator Function
DESCRIPTION: Shows how `await using` can be integrated into an asynchronous generator function. This allows for resource cleanup even within the context of yielded values.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarations.1(target=es2015).errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
async function * ag() {
    await using d5 = { async [Symbol.asyncDispose]() {} };
    yield;
    await null;
}
```

----------------------------------------

TITLE: Handling Unescaped `}` in JSX (TS1381)
DESCRIPTION: This example demonstrates `TS1381` when an unescaped `}` character is directly placed within a JSX element's children. TypeScript expects `}` to denote an expression block, so literal `}` characters must be escaped using `{'}'}` or `&rbrace;`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxParsingError3.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
let x1 = <div>}</div>;
```

----------------------------------------

TITLE: React Component Missing Required Props Error (No Props Provided)
DESCRIPTION: This example illustrates another instance of TypeScript error TS2739, where the `Poisoned` component is instantiated without any props. The error highlights that the `x` and `y` properties, defined in `PoisonedProp`, are absent.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadAttributesResolution2.errors.txt#_snippet_3

LANGUAGE: TSX
CODE:
```
let y = <Poisoned />;
```

----------------------------------------

TITLE: Attempting ESM Import in CommonJS (.cjs) Module (TS1479)
DESCRIPTION: This snippet illustrates an attempt to import an ECMAScript module (ESM) using `import` syntax within a CommonJS (`.cjs`) file. This setup results in a `TS1479` error because CommonJS modules produce `require` calls, which are incompatible with direct ESM `import` statements. A dynamic `import()` call is suggested as a workaround.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeAllowJsPackageSelfName(module=node18).errors.txt#_snippet_2

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as self from "package";
self;
```

----------------------------------------

TITLE: Root Package.json for ES Module Configuration
DESCRIPTION: This `package.json` file configures the root package as an ES module by setting `"type": "module"`. This declaration influences how Node.js and TypeScript resolve imports and exports within the package, enabling native ES module syntax.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions1(module=node18).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Destructuring Object Properties with Nested Defaults - TypeScript
DESCRIPTION: This snippet illustrates how to destructure an object, assigning default values to its properties. It specifically shows a nested destructuring for the 'skills' object, where 'primary' and 'secondary' also have default values, and the entire 'skills' object itself has a default fallback if not provided. This ensures that variables always have a defined value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_51

LANGUAGE: TypeScript
CODE:
```
{
            name: nameA = "noName",
            skills: {
                primary: primaryA = "primary",
                secondary: secondaryA = "secondary"
            } = { primary: "noSkill", secondary: "noSkill" }
        }
```

----------------------------------------

TITLE: Defining Package Exports for Conditional Module Resolution
DESCRIPTION: This package.json defines the 'exports' field, which conditionally maps module specifiers to different entry points based on the environment (e.g., 'import' for ESM, 'require' for CommonJS). This configuration dictates how 'foo' and 'bar' are exposed to consuming modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride1(module=nodenext).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Type Compatibility with Required and Optional Properties in TypeScript
DESCRIPTION: This section defines four interfaces (`i1` to `i4`) demonstrating required and optional properties of different types (function and number). It then shows various assignments, highlighting that objects assigned to interfaces with required properties must explicitly provide those properties, while optional properties can be omitted.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/optionalPropertiesTest.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
interface i1 { M: () => void; };
interface i2 { M?: () => void; };
interface i3 { M: number; };
interface i4 { M?: number; };

var test1: i1 = {};
var test2: i3 = {};
var test3: i2 = {};
var test4: i4 = {};
var test5: i1 = { M: function () { } };
var test6: i3 = { M: 5 };
var test7: i2 = { M: function () { } };
test7 = {};
var test8: i4 = { M: 5 }
test8 = {};
```

----------------------------------------

TITLE: TS4113: Unnecessary Override Modifier for Non-Existent Member
DESCRIPTION: This snippet demonstrates the TS4113 error, which arises when the 'override' modifier is used on a member in a derived class that does not exist in its base class. The 'override' modifier should only be applied to members that genuinely override a base class member.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/overrideLateBindableName1(noimplicitoverride=true).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
class Base3 {}

class Derived3 extends Base3 {
  override [prop]() {}
}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options in tsconfig.json
DESCRIPTION: This snippet illustrates a `tsconfig.json` configuration that includes deprecated TypeScript compiler options. It shows `preserveValueImports` and `importsNotUsedAsValues` which have been removed and should be replaced by `verbatimModuleSyntax` to ensure correct module emit behavior and type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/verbatimModuleSyntaxCompat2.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "compilerOptions": {
        "verbatimModuleSyntax": true,
        "isolatedModules": true,
        "preserveValueImports": true,
        "importsNotUsedAsValues": "error"
    }
}
```

----------------------------------------

TITLE: Property Access on Union Types and Type Guards in TypeScript
DESCRIPTION: This snippet defines union types `AA` and `BB` and a `MyUnion` type. The `fn` function illustrates how direct property access (`value.foo`) on a union type `MyUnion` can lead to an error (`TS2339`) if the property doesn't exist on all union members. It then demonstrates correct type narrowing using an `in` operator check and a discriminant property check (`value.tag === 'B'`) to safely access `foo`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/controlFlowGenericTypes.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
type Common = { id: number };
type AA = { tag: 'A', id: number };
type BB = { tag: 'B', id: number, foo: number };

type MyUnion = AA | BB;

const fn = (value: MyUnion) => {
    value.foo;  // Error
    if ('foo' in value) {
        value.foo;
    }
    if (value.tag === 'B') {
        value.foo;
    }
};
```

----------------------------------------

TITLE: Full TypeScript Source for Element and JSX Definitions
DESCRIPTION: This snippet contains the complete TypeScript source code for defining the `JSX.Element` interface and the `Element` namespace. It includes the type definitions for JSX elements, the `isElement` type guard function, and the `createElement` factory function, providing the foundational types and utilities for a JSX rendering system.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxFactoryQualifiedName.sourcemap.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare namespace JSX {
    interface Element {
        name: string;
        isIntrinsic: boolean;
        isCustomElement: boolean;
        toString(renderId?: number): string;
        bindDOM(renderId?: number): number;
        resetComponent(): void;
        instantiateComponents(renderId?: number): number;
        props: any;
    }
}

export namespace Element {
    export function isElement(el: any): el is JSX.Element {
        return el.markAsChildOfRootElement !== undefined;
    }

    export function createElement(args: any[]) {
        return {
        }
    }
}
```

----------------------------------------

TITLE: Capturing Multiple Let Variables in For Loop - TypeScript
DESCRIPTION: This function demonstrates capturing multiple 'let' variables ('x' and 'y') declared in the initializer of a 'for' loop. Closures capture the iteration-specific bindings of both 'x' and 'y'. The 'var v' captures the final value of 'x' after the loop completes.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/capturedLetConstInLoop5.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
function foo5(x) {
    for (let x = 0, y = 1; x < 1; ++x) {
        var v = x;
        (function() { return x + y + v });
        (() => x + y + v);
        if (x == 1) {
            return;
        }
    }
    
    use(v);
}
```

----------------------------------------

TITLE: Incorrect Direct Type Assertion in TypeScript
DESCRIPTION: This snippet demonstrates an invalid type assertion where a number is directly converted to a string using the 'as' operator. TypeScript flags this with error TS2352 because 'number' and 'string' types do not sufficiently overlap. To perform such a conversion intentionally, it's recommended to first convert the expression to 'unknown' (e.g., `23 as unknown as string`) to explicitly acknowledge the potential type mismatch.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/asOperator2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var x = 23 as string;
```

----------------------------------------

TITLE: TypeScript TS2307 Error Example: Module Not Found
DESCRIPTION: This snippet illustrates a TypeScript TS2307 error, occurring when an ES module attempts to import a CommonJS module using an extensionless relative path. The compiler fails to resolve './foo', indicating a module resolution problem because it cannot find the module or its corresponding type declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/moduleResolutionWithoutExtension2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// Extensionless relative path cjs import in an ES module
    import foo = require("./foo"); // should error, should not ask for extension
```

----------------------------------------

TITLE: Importing and Exporting Module Members in TypeScript (test.ts)
DESCRIPTION: This snippet demonstrates importing members from the `m1` module and defining its own set of exported variables, classes, and functions. It also shows re-exporting an imported class.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/mapRootAbsolutePathModuleSimpleSpecifyOutputFile/node/mapRootAbsolutePathModuleSimpleSpecifyOutputFile.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import m1 = require("m1");
export var a1 = 10;
export class c1 {
    public p1: number;
}

export var instance1 = new c1();
export function f1() {
    return instance1;
}

export var a2 = m1.m1_c1;
```

----------------------------------------

TITLE: Destructuring Array Literal in TypeScript
DESCRIPTION: Shows how array destructuring can be applied directly to an array literal, extracting specific elements. The ES5 equivalent demonstrates the direct access to the array literal's elements, while the ES6 version uses destructuring for a more concise syntax.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementArrayBindingPattern2.sourcemap.txt#_snippet_5

LANGUAGE: JavaScript
CODE:
```
var nameMC = ["roomba", ["vacuum", "mopping"]][0];
```

LANGUAGE: TypeScript
CODE:
```
let [nameMC] = ["roomba", ["vacuum", "mopping"]];
```

----------------------------------------

TITLE: Advanced Conditional and Mapped Types in TypeScript
DESCRIPTION: This snippet defines several complex utility types. `StrictExtract` and `StrictExclude` provide precise type extraction/exclusion based on strict assignability. `A` is a mapped type that re-maps properties, while `B` is a recursive mapped type that applies `StrictExclude` to nested properties, demonstrating advanced type manipulation for deep filtering or transformation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess2.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
type StrictExtract<T, U> = T extends U ? U extends T ? T : never : never;
type StrictExclude<T, U> = T extends StrictExtract<T, U> ? never : T;
type A<T> = { [Q in { [P in keyof T]: P; }[keyof T]]: T[Q]; };
type B<T, V> = A<{ [Q in keyof T]: StrictExclude<B<T[Q], V>, {}>; }>;
```

----------------------------------------

TITLE: Defining a Simple Todo JSX Component in TypeScript
DESCRIPTION: This function component, `Todo`, is a basic building block for the `TodoList`. It accepts `key` (for React's reconciliation) and `todo` (the task string) as props and renders a `div` element displaying their concatenated string values.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadChildrenInvalidType(jsx=react,target=es2015).errors.txt#_snippet_1

LANGUAGE: typescript
CODE:
```
function Todo(prop: { key: number, todo: string }) {
    return <div>{prop.key.toString() + prop.todo}</div>;
}
```

----------------------------------------

TITLE: Defining Module Exports in TypeScript (m1.ts)
DESCRIPTION: This snippet defines a TypeScript module `m1.ts` that exports a variable, a class, an instance of the class, and a function. It demonstrates basic module export syntax for reusability within a project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/mapRootAbsolutePathModuleSubfolderSpecifyOutputFile/node/mapRootAbsolutePathModuleSubfolderSpecifyOutputFile.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
    export var m1_a1 = 10;
    export class m1_c1 {
        public m1_c1_p1: number;
    }
    
    export var m1_instance1 = new m1_c1();
    export function m1_f1() {
        return m1_instance1;
    }
```

----------------------------------------

TITLE: Iterating and Asserting Types in TypeScript Arrays
DESCRIPTION: This function 'f11' iterates over an array of 'Test' objects. It demonstrates how 'isTest2()' can be used for conditional type narrowing and how 'assertIsTest2()' guarantees the type of 'item' for subsequent access to 'item.z'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/assertionTypePredicates1.errors.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
    function f11(items: Test[]) {
        for (let item of items) {
            if (item.isTest2()) {
                item.z;
            }
            item.assertIsTest2();
            item.z;
        }
    }
```

----------------------------------------

TITLE: Uninitialized 'using' Declaration in TypeScript
DESCRIPTION: This TypeScript snippet illustrates error TS1155, where a 'using' declaration is made without an initializer. The 'using' keyword, introduced for explicit resource management, requires an assigned value (e.g., a disposable object) to function correctly and ensure proper disposal.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/usingDeclarations.8.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
{
    using a;
}
```

----------------------------------------

TITLE: Package 'pkg' package.json with Conditional Exports
DESCRIPTION: This `package.json` defines the `pkg` module, utilizing the `exports` field for conditional module resolution. It specifies separate entry points for `import` (ES Module) and `require` (CommonJS) contexts, directing to `import.js` and `require.js` respectively. This configuration is crucial for how TypeScript resolves types based on the `resolution-mode` in consuming projects.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride3(module=node18).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Declaring Function with Array Destructuring and Type Annotation (TypeScript)
DESCRIPTION: Demonstrates array destructuring in a function parameter with an explicit type annotation for a tuple containing numbers and a nested string array.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/destructuringParameterDeclaration1ES5iterable.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function a1([a, b, [[c]]]: [number, number, string[][]]) { }
```

----------------------------------------

TITLE: Using `await using` in TypeScript Async Functions and Generators
DESCRIPTION: This snippet demonstrates the correct application of the `await using` statement within asynchronous methods and async generator functions. When `await using` is employed inside an `async` function, it correctly manages disposable resources, ensuring they are disposed of asynchronously upon function exit.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarations.1(target=es5).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
async am() {
    await using d13 = { async [Symbol.asyncDispose]() {} };
    await null;
}

async * ag() {
    await using d15 = { async [Symbol.asyncDispose]() {} };
    yield;
    await null;
}
```

----------------------------------------

TITLE: Demonstrating Type Assignment with Generic Interfaces in TypeScript
DESCRIPTION: This snippet illustrates type assignment compatibility between `AnimalContainer<Animal>` and `AnimalContainer<Dog>`. While assigning `Dog` container to `Animal` container is allowed, the reverse assignment from `Animal` container to `Dog` container results in a type error (TS2322) due to missing properties in the `Animal` type required by `Dog`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/varianceAnnotationValidation.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
declare let ca: AnimalContainer<Animal>;
declare let cd: AnimalContainer<Dog>;

ca = cd;  // Ok
cd = ca;  // Error
```

----------------------------------------

TITLE: Addressing `super` Call Errors in Derived Class Constructors (TypeScript)
DESCRIPTION: This class definition demonstrates several common errors when calling `super` in a derived class constructor. It initially lacks a `super` call, leading to `TS2377`. The subsequent `super` call attempts to use type arguments (`<number, string, T>`) and a tagged template, which are both invalid for `super` calls, resulting in `TS17011`, `TS2754`, and `TS1034` errors. This highlights incorrect `super` usage.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/taggedTemplatesWithTypeArguments2.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
class SomeBase<A, B, C> {
    a!: A; b!: B; c!: C;
}

class SomeDerived<T> extends SomeBase<number, string, T> {
    constructor() {
        super<number, string, T> `hello world`;
    }
}
```

----------------------------------------

TITLE: Defining Package Exports in package.json (JSON)
DESCRIPTION: This JSON snippet defines the `package.json` for a module named 'pkg', specifying its version and using the 'exports' field to point to its main entry point, 'entrypoint.js'. This configuration is crucial for Node.js module resolution, especially with modern module systems.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/moduleResolutionWithModule(module=commonjs,moduleresolution=node16).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": "./entrypoint.js"
}
```

----------------------------------------

TITLE: Demonstrating TypeScript Type Assignment Error
DESCRIPTION: This snippet illustrates a TypeScript type error (TS2322) where a variable `x` is initially declared as a string and then an attempt is made to reassign it to a number. TypeScript's type checker, enabled by `@ts-check`, flags this as an error because `number` is not assignable to `string`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/checkJsFiles2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// @ts-check
var x = "string";
x = 0;
```

----------------------------------------

TITLE: Defining React Component Props and Functional Component in TypeScript
DESCRIPTION: This snippet defines a TypeScript interface `Props` for a React component's properties, including optional ones. It then declares a functional component `Foo` that accepts these props and initializes a `props` object conforming to the `Props` interface for subsequent JSX usage.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxSpreadOverwritesAttributeStrict.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import React = require('react');

interface Props {
    a: number;
    b: number;
    c?: number;
    d?: number;
}


const props: Props = { a: 1, b: 1 };
const Foo = (props: Props) => <div>{ props.a }</div>;
```

----------------------------------------

TITLE: Handling Unresolved Module Imports in TypeScript
DESCRIPTION: This snippet illustrates the TypeScript TS2307 error, which signifies that a module or its type declarations cannot be found. It demonstrates how different forms of `import` statements—bare module names, relative paths, and relative paths with `.js` extensions—can trigger this error when the target module is non-existent, highlighting common module resolution failures.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sideEffectImports1(module=preserve,nouncheckedsideeffectimports=true).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import "does-not-exist";
```

LANGUAGE: TypeScript
CODE:
```
import "./does-not-exist-either";
```

LANGUAGE: TypeScript
CODE:
```
import "./does-not-exist-either.js";
```

----------------------------------------

TITLE: Demonstrating TS2322 Type Mismatch in TypeScript
DESCRIPTION: This snippet shows a TypeScript variable `x` explicitly typed as a `string`, but then initialized with a `number` value. This assignment causes a `TS2322` compilation error, indicating that a `number` type is not assignable to a `string` type, enforcing TypeScript's type safety rules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/isolatedModulesNoEmitOnError.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export const x: string = 3;
```

----------------------------------------

TITLE: TypeScript unknown Narrowing with Declared Type Equality
DESCRIPTION: Demonstrates how `unknown` behaves when compared for equality with various declared types, including `string`, `boolean`, `number`, `object`, object literals, union types, intersection types, and function types. Highlights cases where narrowing occurs and where `unknown` remains `unknown` (e.g., with unions/intersections).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownType2.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
declare const aString: string;
declare const aBoolean: boolean;
declare const aNumber: number;
declare const anObject: object;
declare const anObjectLiteral: { x: number };
declare const aUnion: { x: number } | { y: string };
declare const anIntersection: { x: number } & { y: string };
declare const aFunction: () => number;

if (u === aString) {
    let uString: string = u;
}

if (u === aBoolean) {
    let uString: boolean = u;
}

if (u === aNumber) {
    let uNumber: number = u;
}

if (u === anObject) {
    let uObject: object = u;
}

if (u === anObjectLiteral) {
    let uObjectLiteral: object = u;
}

if (u === aUnion) {
    type unionDoesNotNarrow = isTrue<isUnknown<typeof u>>
}

if (u === anIntersection) {
    type intersectionDoesNotNarrow = isTrue<isUnknown<typeof u>>
}

if (u === aFunction) {
    let uFunction: object = u;
}
```

----------------------------------------

TITLE: Importing Modules in JavaScript (ESM and CJS)
DESCRIPTION: These examples demonstrate how JavaScript files in different module formats (ESM and CJS) import modules from a local 'inner' package. The imports use relative paths and aliases defined in the 'inner' package's exports map, showcasing consistent import syntax across formats.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackagePatternExports(module=node20).errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as cjsi from "inner/cjs/index";
import * as mjsi from "inner/mjs/index";
import * as typei from "inner/js/index";
cjsi;
mjsi;
typei;
```

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as cjsi from "inner/cjs/index";
import * as mjsi from "inner/mjs/index";
import *s typei from "inner/js/index";
cjsi;
mjsi;
typei;
```

LANGUAGE: JavaScript
CODE:
```
// cjs format file
import * as cjsi from "inner/cjs/index";
import * as mjsi from "inner/mjs/index";
import * as typei from "inner/js/index";
cjsi;
mjsi;
typei;
```

----------------------------------------

TITLE: TypeScript Declaration File with Valid Module Imports (ESM)
DESCRIPTION: Provides an example of a correctly structured TypeScript declaration file (`.d.mts`) in ESM format. It successfully imports and re-exports modules without errors, demonstrating proper module resolution when paths are not excluded or circularly defined.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackagePatternExportsExclude(module=node20).errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
// esm format file
import * as cjs from "inner/cjs/index";
import * as mjs from "inner/mjs/index";
import * as type from "inner/js/index";
export { cjs };
export { mjs };
export { type };
```

----------------------------------------

TITLE: Demonstrating Type Narrowing with isFunction in TypeScript
DESCRIPTION: The `foo` function uses a type guard `isFunction(value)` to narrow the type of `value` within the `if` block. This allows `toString1` and `toString2` to be called safely, as TypeScript correctly infers that `value` is a `Function` inside the conditional block, demonstrating effective type narrowing.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/conditionalTypes2.errors.txt#_snippet_22

LANGUAGE: TypeScript
CODE:
```
function foo<T>(value: T) {
    if (isFunction(value)) {
        toString1(value);
        toString2(value);
    }
}
```

----------------------------------------

TITLE: Demonstrating TS7051 Errors for Nameless Parameters in TypeScript
DESCRIPTION: This TypeScript code demonstrates various scenarios where the `noImplicitAny` compiler option triggers TS7051 errors for parameters that have a name but no explicit type annotation. It covers method declarations, function type literals, and object literal method declarations, highlighting the need for explicit type declarations like `arg0: string[]` or `arg1: C` to resolve the 'Parameter has a name but no type' error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyNamelessParameter.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class C { }
declare var a: { m(...string): void }
declare var b: (string, C) => void;
declare var c: { (C, number): void };
declare var d: { m(boolean, C, object, undefined): void }
// note: null and void do not parse correctly without a preceding parameter name
```

----------------------------------------

TITLE: Defining Redux Store Middleware and React JSX Types - TypeScript
DESCRIPTION: This snippet defines custom TypeScript types essential for a React application. It includes `MiddlewareArray` and `configureStore` for Redux integration, alongside comprehensive React type declarations such as `DetailedHTMLProps`, `HTMLAttributes`, `ReactNode`, `ReactChild`, `ReactFragment`, and `ReactNodeArray`. These types are crucial for ensuring type safety and correct usage of HTML elements and React components within the project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/excessiveStackDepthFlatArray.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
interface MiddlewareArray<T> extends Array<T> {}
declare function configureStore(options: { middleware: MiddlewareArray<any> }): void;

declare const defaultMiddleware: MiddlewareArray<any>;
configureStore({
  middleware: [...defaultMiddleware], // Should not error
});

declare namespace React {
  type DetailedHTMLProps<E extends HTMLAttributes<T>, T> = E;
  interface HTMLAttributes<T> {
    children?: ReactNode;
  }
  type ReactNode = ReactChild | ReactFragment | boolean | null | undefined;
  type ReactText = string | number;
  type ReactChild = ReactText;
  type ReactFragment = {} | ReactNodeArray;
  interface ReactNodeArray extends Array<ReactNode> {}
}
declare namespace JSX {
  interface IntrinsicElements {
    ul: React.DetailedHTMLProps<React.HTMLAttributes<HTMLUListElement>, HTMLUListElement>;
    li: React.DetailedHTMLProps<React.HTMLAttributes<HTMLLIElement>, HTMLLIElement>;
  }
}
declare var React: any;
```

----------------------------------------

TITLE: Using Required Utility Type with Interface (Foo) in TypeScript
DESCRIPTION: This snippet showcases the `Required<T>` utility type, which transforms all properties of `T` into mandatory ones. When applied to `Foo` (where `c` and `d` were optional), `Required<Foo>` makes `b`, `c`, and `d` all required. The assignments to `x2` (typed as `Required<Foo>`) illustrate how missing any of these properties now leads to type errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypes6.errors.txt#_snippet_23

LANGUAGE: TypeScript
CODE:
```
declare let x2: Required<Foo>;

x1.a;  // number
x1.b;  // number | undefined
x1.c;  // number
x1.d;  // number

x2 = { a: 1 };  // Error
x2 = { a: 1, b: 1 };  // Error
x2 = { a: 1, b: 1, c: 1 };  // Error
x2 = { a: 1, b: 1, c: 1, d: 1 };
```

----------------------------------------

TITLE: Declaring a Variable in JavaScript
DESCRIPTION: This snippet shows a basic JavaScript variable declaration. The variable 'a' is initialized with the integer value '10'. This is a fundamental operation in JavaScript for storing data.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/optionsInlineSourceMapSourcemap.sourcemap.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
var a = 10;
```

----------------------------------------

TITLE: Defining an External Module with a Class Export in TypeScript
DESCRIPTION: This simple external module defines and exports a class named `C`. This class serves as a type definition that other modules can import and reference, demonstrating a standard way to expose types from a module.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeofExternalModules.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export class C { }
```

----------------------------------------

TITLE: Formatting Dates and Numbers with Intl in TypeScript
DESCRIPTION: This snippet demonstrates how to use `Intl.DateTimeFormat` and `Intl.NumberFormat` to format dates and numbers according to a specified locale. It shows examples for 'en-US' and 'de-DE' locales, illustrating how the output changes based on regional conventions. The `log` function encapsulates the formatting logic for reusability.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/es2020IntlAPIs.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
const count = 26254.39;
const date = new Date("2012-05-24");
    
function log(locale: string) {
  console.log(
    `${new Intl.DateTimeFormat(locale).format(date)} ${new Intl.NumberFormat(locale).format(count)}`
  );
}
    
log("en-US");
// expected output: 5/24/2012 26,254.39
    
log("de-DE");
// expected output: 24.5.2012 26.254,39
```

----------------------------------------

TITLE: Configuring Root Package as ESM in package.json
DESCRIPTION: This `package.json` configuration sets the default module type for the entire package to ECMAScript Modules (ESM) by specifying `"type": "module"`. This allows `.js` files to be interpreted as ESM by default and enables features like `import.meta` without errors, unless overridden by a nested `package.json`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportMeta(module=node18).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Narrowing Discriminated Union with Switch in TypeScript
DESCRIPTION: Illustrates type narrowing for a discriminated union type using a `switch` statement on the `kind` property. This approach provides a clear and structured way to handle different union members based on the discriminant's value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes2.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function f11(x : { kind: false, a: string } | { kind: true, b: string } | { kind: string, c: string }) {
    switch (x.kind) {
        case false:
            x.a;
            break;
        case true:
            x.b;
            break;
        default:
            x.c;
    }
}
```

----------------------------------------

TITLE: Public Method with Partial Implicit Any Parameters (TypeScript)
DESCRIPTION: This snippet defines a public method `pub_f5` with parameters `x`, `y`, and `z`. Parameter `y` is explicitly typed as `any`, but `x` and `z` are implicitly typed. This results in `TS7006` errors for `x` and `z` when `noImplicitAny` is active, highlighting the need for explicit types on all parameters.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyParametersInClass.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
public pub_f5(x, y: any, z): void { }
```

----------------------------------------

TITLE: Calculating Area with Discriminated Unions and Optional Chaining in TypeScript
DESCRIPTION: This snippet defines a 'Shape' discriminated union type and a 'getArea' function. The function uses optional chaining (shape?.type) to safely access the 'type' property and then a switch statement to calculate the area based on the specific shape, returning 0 if the shape is 'undefined' or its type is not recognized.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/controlFlowOptionalChain.errors.txt#_snippet_23

LANGUAGE: TypeScript
CODE:
```
type Shape =
    | { type: 'rectangle', width: number, height: number }
    | { type: 'circle', radius: number }

function getArea(shape?: Shape) {
    switch (shape?.type) {
        case 'circle':
            return Math.PI * shape.radius ** 2
        case 'rectangle':
            return shape.width * shape.height
        default:
            return 0
    }
}
```

----------------------------------------

TITLE: Invalid `satisfies` Due to Missing Required Property (TypeScript)
DESCRIPTION: This snippet shows another invalid use of `satisfies`. The empty object literal `{}` fails to satisfy `I1` because it is missing the required `a` property. TypeScript reports an error (TS1360), stating that the object does not meet the type requirements of `I1`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeSatisfaction.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
const t3 = { } satisfies I1; // Error
```

----------------------------------------

TITLE: JSX Module Declaration and AppComponent with TS2552 Error
DESCRIPTION: This snippet illustrates a TypeScript class `AppComponent` attempting to render a JSX element (`<div />`) within its `render` method. The accompanying `TS2552` error 'Cannot find name 'createElement'' indicates that the TypeScript compiler cannot locate the `createElement` function, which is essential for JSX transformation. This often points to a missing React import or an incorrect JSX factory configuration in the TypeScript compiler options.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxFactoryIdentifierWithAbsentParameter.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare module JSX {
        interface IntrinsicElements {
            [s: string]: any;
        }
    }
    
    export class AppComponent {
        render() {
            return <div />;
        }
    }
```

----------------------------------------

TITLE: Logging Variable to Console in TypeScript
DESCRIPTION: This snippet demonstrates how to output the value of a variable, `numberA3`, to the console using `console.log()`. This is a fundamental operation for debugging and displaying information in JavaScript/TypeScript applications.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForArrayBindingPattern2.sourcemap.txt#_snippet_55

LANGUAGE: TypeScript
CODE:
```
console.log(numberA3);
```

----------------------------------------

TITLE: Type Narrowing with Private Name 'in' Expressions (TypeScript)
DESCRIPTION: The `flow` method, part of the `Foo` class, demonstrates how TypeScript's control flow analysis narrows types based on the result of an `in` expression involving private identifiers. It shows how `unknown` types can be refined to `Foo` or `object`, and how union types (e.g., `Foo | Bar`, `FooSub | Bar`) are narrowed, including scenarios with `null` and `never`. Note that `Bar` and `FooSub` are assumed types for demonstration.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/privateNameInInExpression(target=es2022).errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
flow(u: unknown, n: never, fb: Foo | Bar, fs: FooSub, b: Bar, fsb: FooSub | Bar, fsfb: Foo | FooSub | Bar) {

    if (typeof u === 'object') {
        if (#field in n) {
            n; // good n is never
        }

        if (#field in u) {
            u; // good u is Foo
        } else {
            u; // good u is object | null
        }

        if (u !== null) {
            if (#field in u) {
                u; // good u is Foo
            } else {
                u; // good u is object
            }

            if (#method in u) {
                u; // good u is Foo
            }

            if (#staticField in u) {
                u; // good u is typeof Foo
            }

            if (#staticMethod in u) {
                u; // good u is typeof Foo
            }
        }
    }

    if (#field in fb) {
        fb; // good fb is Foo
    } else {
        fb; // good fb is Bar
    }

    if (#field in fs) {
        fs; // good fs is FooSub
    } else {
        fs; // good fs is never
    }

    if (#field in b) {
        b; // good b is 'Bar & Foo'
    } else {
        b; // good b is Bar
    }

    if (#field in fsb) {
        fsb; // good fsb is FooSub
    } else {
        fsb; // good fsb is Bar
    }

    if (#field in fsfb) {
        fsfb; // good fsfb is 'Foo | FooSub'
    } else {
        fsfb; // good fsfb is Bar
    }

    class Nested {
        m(v: any) {
            if (#field in v) {
                v; // good v is Foo
            }
        }
    }
}
```

----------------------------------------

TITLE: Demonstrating TS2834/TS2835 Import Errors in TypeScript
DESCRIPTION: These TypeScript snippets illustrate common errors (TS2834, TS2835) encountered when using `--moduleResolution` as `node16` or `nodenext` without explicit file extensions in ECMAScript import paths. The errors highlight the necessity to specify `.js`, `.mjs`, or `.cjs` extensions for relative imports, even for directories or `index` files.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node18).errors.txt#_snippet_27

LANGUAGE: TypeScript
CODE:
```
const _m38 = import("./subfolder/");
```

LANGUAGE: TypeScript
CODE:
```
const _m39 = import("./subfolder/index");
```

LANGUAGE: TypeScript
CODE:
```
const _m40 = import("./subfolder2");
```

LANGUAGE: TypeScript
CODE:
```
const _m41 = import("./subfolder2/");
```

LANGUAGE: TypeScript
CODE:
```
const _m42 = import("./subfolder2/index");
```

LANGUAGE: TypeScript
CODE:
```
const _m43 = import("./subfolder2/another");
```

LANGUAGE: TypeScript
CODE:
```
const _m44 = import("./subfolder2/another/");
```

LANGUAGE: TypeScript
CODE:
```
const _m45 = import("./subfolder2/another/index");
```

----------------------------------------

TITLE: Extending Call Signature with One Optional Parameter (Valid) - TypeScript
DESCRIPTION: These interfaces demonstrate valid extensions of `Base.a2`, which has one optional parameter. `I4` removes the optional parameter, `I5` maintains it, and `I6` makes it required. All are valid as they adhere to the rule that derived types can have the same or fewer required parameters, or make optional parameters required.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/subtypingWithCallSignaturesWithOptionalParameters.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
interface I4 extends Base {
    a2: () => number; // ok, same number of required params
}

interface I5 extends Base {
    a2: (x?: number) => number; // ok, same number of required params
}

interface I6 extends Base {
    a2: (x: number) => number; // ok, same number of params
}
```

----------------------------------------

TITLE: Correct Implementation of Abstract Overridden Methods in TypeScript
DESCRIPTION: This snippet demonstrates the correct implementation of abstract methods that were declared and potentially overridden in an abstract base class. The concrete class `ADD` extends `AD` and provides implementations for both `f()` and `b()`, with `b()` explicitly using the `override` modifier as it was declared with `override` in `AD`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/override5.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
class ADD extends AD {
    f(): void {

    }
    override b(): void {

    }
}
```

----------------------------------------

TITLE: CommonJS Module Imports with ESM Conflicts (TypeScript)
DESCRIPTION: This TypeScript snippet demonstrates module imports within a CommonJS (`.cts`) formatted file. It highlights `TS1479` errors when attempting to import ECMAScript Modules (ESM) like 'package/mjs' and 'package' using `require` calls, suggesting dynamic `import()` instead. It also shows successful imports from 'inner' modules that resolve to CJS.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesConditionalPackageExports(module=node16).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
    // cjs format file
    import * as cjs from "package/cjs";
    import * as mjs from "package/mjs";
    import * as type from "package";
    cjs;
    mjs;
    type;
    import * as cjsi from "inner/a";
    import * as mjsi from "inner/b";
    import * as typei from "inner";
    import * as ts from "inner/types";
    cjsi.cjsSource;
    mjsi.cjsSource;
    typei.implicitCjsSource;
    ts.cjsSource;
```

----------------------------------------

TITLE: Destructuring Object with Nested Properties and Defaults (TypeScript)
DESCRIPTION: This snippet demonstrates how to use object destructuring to extract 'name' and nested 'skills' properties from an object named 'robotB'. It includes default value assignments for 'nameB', 'primaryB', and 'secondaryB', and also provides a default object for 'skills' if it's missing. This pattern is useful for safely accessing properties from potentially incomplete data structures.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementNestedObjectBindingPatternWithDefaultValues.sourcemap.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
var {
    name: nameB = "noNameSpecified",
    skills: {
        primary: primaryB = "noSkill",
        secondary: secondaryB = "noSkill"
    } = { primary: "noSkill", secondary: "noSkill" }
} = robotB

nameB
```

----------------------------------------

TITLE: Defining Exported Module Members in TypeScript (m2.ts)
DESCRIPTION: This snippet defines and exports variables, classes, and functions from `m2.ts`. The `export` keyword makes these members available for import and use in other TypeScript modules, facilitating modular application design.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/mapRootRelativePathMixedSubfolderSpecifyOutputFileAndOutputDirectory/node/mapRootRelativePathMixedSubfolderSpecifyOutputFileAndOutputDirectory.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export var m2_a1 = 10;
export class m2_c1 {
    public m2_c1_p1: number;
}

export var m2_instance1 = new m2_c1();
export function m2_f1() {
    return m2_instance1;
}
```

----------------------------------------

TITLE: Defining JSX Interfaces in TypeScript
DESCRIPTION: This snippet defines the essential interfaces within the 'JSX' namespace that enable TypeScript to understand and type-check JSX syntax. These interfaces, such as 'Element', 'ElementAttributesProperty', 'ElementChildrenAttribute', 'IntrinsicAttributes', and 'IntrinsicElements', are fundamental for integrating JSX with TypeScript's type system.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxChildrenGenericContextualTypes.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
namespace JSX {\n    export interface Element {}\n    export interface ElementAttributesProperty { props: {}; }\n    export interface ElementChildrenAttribute { children: {}; }\n    export interface IntrinsicAttributes {}\n    export interface IntrinsicElements { [key: string]: Element }\n}
```

----------------------------------------

TITLE: Defining Channel Interfaces and Union Type in TypeScript
DESCRIPTION: This snippet defines two distinct channel interfaces, `TextChannel` and `EmailChannel`, each characterized by a unique `type` literal property. It then combines these into a union type `Channel`, which serves as the foundational type for subsequent generic type manipulations and channel creation logic.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/complicatedIndexedAccessKeyofReliesOnKeyofNeverUpperBound.errors.txt#_snippet_0

LANGUAGE: typescript
CODE:
```
interface TextChannel {
    id: string;
    type: 'text';
    phoneNumber: string;
}

interface EmailChannel {
    id: string;
    type: 'email';
    addres: string;
}

type Channel = TextChannel | EmailChannel;
```

----------------------------------------

TITLE: TypeScript Interface Definition
DESCRIPTION: Defines a simple TypeScript interface named `Foo` with a single numeric property `x`. This interface is exported, making it available for type referencing in other modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeofImportDefer.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export interface Foo {
  x: number;
}
```

----------------------------------------

TITLE: Exporting a Constant in TypeScript (.ts)
DESCRIPTION: This snippet demonstrates a basic named export of a constant variable in a standard TypeScript file (.ts). This export makes the '_' constant available for import in other modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/impliedNodeFormatEmit3(module=esnext).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export const _ = 0;
```

----------------------------------------

TITLE: Defining Classes and Indexed Access Types in TypeScript
DESCRIPTION: This snippet defines two classes, `A` and `B`, with distinct properties. It then introduces a generic type `T<X>` that uses the `Pick` utility type to extract the 'x' property from any type `X` that extends `{ x: any }`. Additionally, it defines type aliases `C` and `D` based on `T<A>` and `T<B>` respectively, and includes type assertions to demonstrate expected assignability outcomes for `Pick` and generic types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/genericIndexedAccessVarianceComparisonResultCorrect.errors.txt#_snippet_0

LANGUAGE: typescript
CODE:
```
class A {
    x: string = 'A';
    y: number = 0;
}

class B {
    x: string = 'B';
    z: boolean = true;
}

type T<X extends { x: any }> = Pick<X, 'x'>;

type C = T<A>;
type D = T<B>;

type C_extends_D = C extends D ? true : false;                                  // true
type PickA_extends_PickB = Pick<A, 'x'> extends Pick<B, 'x'> ? true : false;    // true
type TA_extends_TB = T<A> extends T<B> ? true : false;                          // should be true
```

----------------------------------------

TITLE: Allowed and Disallowed Operations on Unknown Type in TypeScript
DESCRIPTION: This function demonstrates which operations are permitted on a variable of type `unknown`. It highlights that only equality (`==`, `!=`, `===`, `!==`) operators are allowed without type narrowing, while arithmetic, property access, element access, and function calls result in compilation errors (TS18046).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownType1.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
function f10(x: unknown) {
    x == 5;
    x !== 10;
    x >= 0;  // Error
    x.foo;  // Error
    x[10];  // Error
    x();  // Error
    x + 1;  // Error
    x * 2;  // Error
    -x;  // Error
    +x;  // Error
}
```

----------------------------------------

TITLE: Accessing Property with keyof T in TypeScript
DESCRIPTION: This function `f1` demonstrates a basic and type-safe way to access a property `k` of an object `x`, where `k` is explicitly defined as a key of type `T`. This serves as a fundamental example of correct property access using `keyof`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeRelationships.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function f1<T>(x: T, k: keyof T) {
    return x[k];
}
```

----------------------------------------

TITLE: Using Logical OR Assignment (||=) in TypeScript
DESCRIPTION: This snippet demonstrates the `||=` operator. If `results` is falsy (e.g., `undefined`, `null`, `0`, `''`), it is assigned the value of `bar?.value ?? []`. The `push` method is then safely called on the resulting array. This operator is useful for providing a default value if the variable is not yet initialized or is otherwise falsy.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/logicalAssignment8(target=es2021).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function foo1(results: number[] | undefined) {
    (results ||= bar?.value ?? []).push(100);
}
```

----------------------------------------

TITLE: Configuring ES Module Type in package.json
DESCRIPTION: This snippet shows the `package.json` configuration that sets the project type to 'module', enabling ES module resolution behavior in Node.js and influencing TypeScript's module resolution strategy.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationFileForTsJsImport(module=node18).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{"type": "module"}
```

----------------------------------------

TITLE: Destructuring Object with Default Values and Type Assertion in TypeScript
DESCRIPTION: This snippet demonstrates object destructuring in TypeScript, assigning default values to `nameC`, `primaryB`, and `secondaryB` if the corresponding properties are missing or undefined in the source object. It shows destructuring nested objects and using a type assertion `<Robot>` for the source object. The snippet is incomplete, showing the start of the `skills` object definition.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementNestedObjectBindingPatternWithDefaultValues.sourcemap.txt#_snippet_9

LANGUAGE: TypeScript
CODE:
```
var

    {
        name: nameC = "noNameSpecified",
        skills: {
            primary: primaryB = "noSkill",
            secondary: secondaryB = "noSkill"
        } = { primary: "noSkill", secondary: "noSkill" }
    } = <Robot>
         { 
           name
               : 
                 "Edger"
                        , 
                          skills
                                : 
                                  { 
                                    primary
```

----------------------------------------

TITLE: Iterating with Nested Object Destructuring in TypeScript
DESCRIPTION: This snippet demonstrates how to use object destructuring to extract nested properties (`primary`, `secondary`) from an object (`multiRobot.skills`) directly within the initialization part of a `for` loop. It initializes loop variables and performs destructuring in a single statement, making the code concise for iterating over structured data.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForObjectBindingPattern2.sourcemap.txt#_snippet_32

LANGUAGE: TypeScript
CODE:
```
for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
```

----------------------------------------

TITLE: Narrowing Primitive and Literal Types with Equality Checks - TypeScript
DESCRIPTION: This snippet demonstrates how TypeScript narrows union types (e.g., `number | string | boolean`) when compared using the `==` operator against primitive types and literal values. Within each `if` block, the type of `x` is refined to match the type of the value it's being compared against, showcasing effective type narrowing for primitives.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/narrowByEquality.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare let x: number | string | boolean;
declare let n: number;
declare let s: string;
declare let b: boolean;
declare let xUnknown: unknown;

if (x == n) {
    x;
}

if (x == s) {
    x;
}

if (x == b) {
    x;
}

if (x == 1) {
    x;
}

if (x == "") {
    x;
}

if (x == "foo") {
    x;
}

if (x == true) {
    x;
}

if (x == false) {
    x;
}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options (tsconfig.json)
DESCRIPTION: This snippet defines the TypeScript compiler options in 'tsconfig.json', setting the target to ES5, module system to CommonJS, and enabling decorator metadata and experimental decorators. It also specifies 'main.ts' as the file to compile. This configuration is relevant for Angular 2 projects and is part of the context for the module resolution error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/emitDecoratorMetadataCommonJSISolatedModules/amd/emitDecoratorMetadataCommonJSISolatedModules.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "compileOnSave": true,
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "isolatedModules": true
  },
  "files": [
    "main.ts"
  ]
}
```

----------------------------------------

TITLE: Exporting Derived Variable - TypeScript
DESCRIPTION: This snippet from `client.ts` demonstrates how to declare and export a new variable `x` whose value is assigned from a previously imported binding `defaultBinding`. This is a common pattern for transforming or re-exporting imported values.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/es6ImportDefaultBindingWithExport.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
export var x = defaultBinding;
```

----------------------------------------

TITLE: Defining Package Exports for Import and Require (JSON)
DESCRIPTION: This `package.json` snippet configures the `pkg` module's exports, specifying different entry points for `import` (ESM) and `require` (CommonJS) consumers. This setup is crucial for enabling conditional exports based on module resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportAttributesModeDeclarationEmit2(module=nodenext).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: TypeScript Basic Module Exports
DESCRIPTION: A simple TypeScript module exporting two constants. This module serves as a dependency for other examples demonstrating import functionalities.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/importAttributes1(module=commonjs).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export const a = 1;
export const b = 2;
```

----------------------------------------

TITLE: Converting Snake Case to Camel/Pascal Case - TypeScript
DESCRIPTION: This complex snippet defines two recursive types, `SnakeToCamelCase` and `SnakeToPascalCase`, which transform snake_case string literals into camelCase and PascalCase respectively. It utilizes template literal inference and casing intrinsics to perform character-by-character transformations across underscores.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes1.errors.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
type SnakeToCamelCase<S extends string> =
    S extends `${infer T}_${infer U}` ? `${Lowercase<T>}${SnakeToPascalCase<U>}` :
    S extends `${infer T}` ? `${Lowercase<T>}` :
    SnakeToPascalCase<S>;
type SnakeToPascalCase<S extends string> =
    string extends S ? string :
    S extends `${infer T}_${infer U}` ? `${Capitalize<Lowercase<T>>}${SnakeToPascalCase<U>}` :
    S extends `${infer T}` ? `${Capitalize<Lowercase<T>>}` :
    never;
```

----------------------------------------

TITLE: Complete Greeter Class Definition in TypeScript
DESCRIPTION: This snippet defines the Greeter class in TypeScript, showcasing a constructor with public parameter properties, a public greet method, private member variables, and public getter/setter for the greetings property. It demonstrates fundamental object-oriented programming concepts in TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationClass.sourcemap.txt#_snippet_14

LANGUAGE: TypeScript
CODE:
```
class Greeter {
    constructor(public greeting: string, ...b: string[]) {
    }
    greet() {
        return "<h1>" + this.greeting + "</h1>";
    }
    private x: string;
    private x1: number = 10;
    private fn() {
        return this.greeting;
    }
    get greetings() {
        return this.greeting;
    }
    set greetings(greetings: string) {
        this.greeting = greetings;
    }
}
```

----------------------------------------

TITLE: Illustrating Removed Compiler Options in tsconfig.json
DESCRIPTION: This snippet presents a `tsconfig.json` configuration that includes several compiler options which have been deprecated or removed from TypeScript. It serves to demonstrate the specific errors (TS5108, TS5102) that the TypeScript compiler will report when these outdated options are present, guiding users to update their configurations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/deprecatedCompilerOptions3.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "compilerOptions": {
        "target": "ES3",
        "noImplicitUseStrict": true,
        "keyofStringsOnly": true,
        "suppressExcessPropertyErrors": true,
        "suppressImplicitAnyIndexErrors": true,
        "noStrictGenericChecks": true,
        "charset": "utf8",
        "out": "dist.js"
    }
}
```

----------------------------------------

TITLE: Package JSON Configuration for Module Exports
DESCRIPTION: This `package.json` defines the `pkg` module, specifying conditional exports for `import` and `require`. It directs `import` statements to `import.js` (and implicitly `import.d.ts`) and `require` statements to `require.js` (and implicitly `require.d.ts`), which is crucial for understanding why `bar` is not resolved in the `import` context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride4(module=node16).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Checking Strict Equality (===) with NaN in TypeScript
DESCRIPTION: This snippet demonstrates strict equality checks (`===`) between a number variable `x` and the global `NaN` constant. TypeScript correctly identifies that these conditions will always return `false` because `NaN` is never strictly equal to itself or any other value, including `NaN`. The compiler suggests using `Number.isNaN(x)` for proper `NaN` detection.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nanEquality.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare const x: number;

if (x === NaN) {}
if (NaN === x) {}
```

----------------------------------------

TITLE: Defining JSX Intrinsic Elements and Element Interface in TypeScript
DESCRIPTION: This snippet defines the global `JSX` namespace, which is crucial for TypeScript to understand JSX syntax. It declares `IntrinsicElements` to specify built-in HTML elements like `span` and `Element` to define properties available on all JSX elements, such as `something`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/contextuallyTypedStringLiteralsInJsxAttributes01.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
namespace JSX {
    export interface IntrinsicElements {
        span: {};
    }
    export interface Element {
		something?: any;
    }
}
```

----------------------------------------

TITLE: Root Project Configuration with Module Type
DESCRIPTION: This is the root `package.json` for the project, setting the `type` field to `module`. This declaration signifies that files with a `.js` extension are treated as ES modules by default, influencing how Node.js and TypeScript resolve imports and exports within the project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride2(module=node18).errors.txt#_snippet_4

LANGUAGE: JSON
CODE:
```
{
        "private": true,
        "type": "module"
    }
```

----------------------------------------

TITLE: Defining Discriminated Union Types for UI Controls in TypeScript
DESCRIPTION: These interfaces and type alias define a discriminated union `Control` for different UI elements (Button, Checkbox). The `type` property acts as a discriminant, allowing TypeScript to narrow down the specific control type based on its value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/controlFlowGenericTypes.errors.txt#_snippet_21

LANGUAGE: TypeScript
CODE:
```
interface Button {
    type: "button";
    text: string;
}

interface Checkbox {
    type: "checkbox";
    isChecked: boolean;
}

type Control = Button | Checkbox;
```

----------------------------------------

TITLE: Destructuring Objects in TypeScript For...Of Loop
DESCRIPTION: This TypeScript snippet demonstrates iterating over an array of objects using a `for...of` loop while simultaneously destructuring nested properties. It extracts `name`, `primary` skill, and `secondary` skill into `nameA`, `primaryA`, and `secondaryA` variables respectively, simplifying data access from complex objects.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPattern.sourcemap.txt#_snippet_35

LANGUAGE: TypeScript
CODE:
```
for (let {name: nameA, skills: { primary: primaryA, secondary: secondaryA } } of 
     [{ name: "mower", skills: { primary: "mowing", secondary: "none" } },
         { name: "trimmer", skills: { primary: "trimming", secondary: "edging" } }]) {
  // Loop body would typically follow here
}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options in tsconfig.json
DESCRIPTION: This JSON snippet defines the TypeScript compiler options for the project. It sets `module` to `esnext` and `moduleResolution` to `bundler` for modern module handling, enables `declaration` and `emitDeclarationOnly` to generate declaration files without emitting JavaScript, and explicitly sets `types` to an empty array to control type resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/resolutionModeTripleSlash2.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "compilerOptions": {
    "module": "esnext",
    "moduleResolution": "bundler",
    "declaration": true,
    "emitDeclarationOnly": true,
    "types": []
  }
}
```

----------------------------------------

TITLE: Asynchronous Using Declaration with Value Property in TypeScript
DESCRIPTION: This snippet extends the basic `await using` declaration by including a `value` property in the object literal. It illustrates how additional properties can be included in the async disposable object, provided they are compatible with the inferred or declared type.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/usingDeclarationsWithObjectLiterals1.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
async function f() {
  {
    await using _ = { async [Symbol.asyncDispose]() {}, value: 1 };
  }
}
```

----------------------------------------

TITLE: Declaring Global JSX Interfaces in TypeScript
DESCRIPTION: This snippet defines the global `JSX` module, which is fundamental for TypeScript's understanding and type-checking of JSX syntax. It declares `Element` for custom components and `IntrinsicElements` for built-in HTML/SVG elements, enabling robust type inference and validation for JSX expressions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxEmit3.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare module JSX {
	interface Element { }
	interface IntrinsicElements { }
}
```

----------------------------------------

TITLE: Root Package.json with ESM Type
DESCRIPTION: This package.json configuration defines the root package as an ECMAScript Module ('type: "module"'). This setting influences how Node.js and TypeScript resolve imports within this package and its subdirectories.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=nodenext).errors.txt#_snippet_38

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Defining an Interface in TypeScript
DESCRIPTION: This snippet defines a simple TypeScript interface named 'A'. Interfaces are used to define the shape of objects, ensuring type safety within TypeScript applications. This declaration is valid within a .ts file.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/importSpecifiers_js.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export interface A {}
```

----------------------------------------

TITLE: Defining a Complex Object Literal in TypeScript
DESCRIPTION: This snippet defines a JavaScript object `obj` with various property types, including numeric keys, string keys, nested objects, and a property with a literal string name. This object is used as a base for subsequent property access examples.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/propertyAccess.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
var obj = {
    10: 'ten',
    x: 'hello',
    y: 32,
    z: { n: 'world', m: 15, o: () => false },
    'literal property': 100
};
```

----------------------------------------

TITLE: Asynchronous Using Declaration with Type Mismatch Error in TypeScript
DESCRIPTION: This code demonstrates an `await using` declaration explicitly typed as `MyAsyncDisposable`. It attempts to assign an object literal with an `extra` property not defined in `MyAsyncDisposable`, resulting in a `TS2353` error, highlighting TypeScript's strict object literal type checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/usingDeclarationsWithObjectLiterals1.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
async function f() {
  {
    await using _: MyAsyncDisposable = {
      async [Symbol.asyncDispose]() {},
      value: 1,
      extra: "foo",
    };
  }
}
```

----------------------------------------

TITLE: Handling Object Literal Excess Property Error in TypeScript
DESCRIPTION: Shows a common TypeScript error (TS2353) where an object literal is assigned to a union type, but it contains properties not known to *any* of the union members. In this case, `c` is not allowed when `a` is `null`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes2.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
function f13(x: { a: null; b: string } | { a: string, c: number }) {
    x = { a: null, b: "foo", c: 4};  // Error
}
```

----------------------------------------

TITLE: Importing React in TypeScript
DESCRIPTION: Imports the React library using a CommonJS-style 'require' statement, making React available for component definition and JSX usage within the TypeScript file.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadAttributesResolution10.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import React = require('react');
```

----------------------------------------

TITLE: Root Package.json with Module Type and Exports Map
DESCRIPTION: This `package.json` file configures the root 'package' module. It sets the `type` to 'module' to indicate ESM behavior by default and defines an `exports` map. The `exports` map specifies entry points for CJS (`./cjs`), MJS (`./mjs`), and the default entry (`.`), which is crucial for module resolution and can be related to the `TS2209` error if `rootDir` is not supplied.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesConditionalPackageExports(module=node20).errors.txt#_snippet_6

LANGUAGE: json
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module",
    "exports": {
        "./cjs": "./index.cjs",
        "./mjs": "./index.mjs",
        ".": "./index.js"
    }
}
```

----------------------------------------

TITLE: Enforce Protocol Patterns with TypeScript Template Literal Types
DESCRIPTION: This example defines a generic `Protocol` type to enforce specific URL schemes (http, https, ftp) for a host specification. It shows how to use this type in a function parameter and provides examples of valid URLs, as well as invalid ones that lack a protocol or use an incorrect one, leading to type errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypesPatterns.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type Protocol<T extends string, U extends string> = `${T}://${U}`;
function download(hostSpec: Protocol<"http" | "https" | "ftp", string>) { }
// ok, has protocol
download("http://example.com/protocol");
// issues error - no protocol
download("example.com/noprotocol");
// issues error, incorrect protocol
download("gopher://example.com/protocol");
```

----------------------------------------

TITLE: Nested Object Destructuring with Default Fallback in TypeScript
DESCRIPTION: This snippet shows nested object destructuring for the 'skills' property. It renames 'primary' to 'primaryA' and 'secondary' to 'secondaryA', both with their own default values. Crucially, if the 'skills' property itself is 'undefined' or missing, the entire default object '{ primary: "noSkill", secondary: "noSkill" }' is used as a fallback for the nested destructuring.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_56

LANGUAGE: TypeScript
CODE:
```
skills: {
    primary: primaryA = "primary",
    secondary: secondaryA = "secondary"
} = { primary: "noSkill", secondary: "noSkill" }
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options in tsconfig.json
DESCRIPTION: This snippet defines the TypeScript compiler options in `tsconfig.json`, enabling JavaScript file processing (`allowJs`), disabling declaration file generation (`declaration`), setting module resolution to 'node', and limiting JavaScript module depth to 2.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/nodeModulesImportHigher/amd/nodeModulesImportHigher.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "compilerOptions": { 
        "allowJs": true,
        "declaration": false,
        "moduleResolution": "node",
        "maxNodeModuleJsDepth": 2
      }
    }
```

----------------------------------------

TITLE: Destructuring Nested Property with Renaming and Default Value in TypeScript
DESCRIPTION: This snippet focuses on destructuring the 'primary' property within a nested object. It renames 'primary' to 'primaryA' and assigns a default value of '"primary"' if the 'primary' property is not found or is 'undefined' in the nested 'skills' object.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_58

LANGUAGE: TypeScript
CODE:
```
primary: primaryA = "primary"
```

----------------------------------------

TITLE: Defining JSX.LibraryManagedAttributes for Component Props in TypeScript
DESCRIPTION: This crucial type within the `JSX` namespace determines the final type of props for a component, considering `defaultProps` and `propTypes`. It uses conditional types to apply `Defaultize` and `InferredPropTypes` based on whether the component has `defaultProps` and `propTypes`, ensuring accurate type inference for React components.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxLibraryManagedAttributes.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
declare namespace JSX {
    interface Element extends ReactComponent {}
    interface IntrinsicElements {}
    type LibraryManagedAttributes<TComponent, TProps> =
        TComponent extends { defaultProps: infer D; propTypes: infer P; }
            ? Defaultize<TProps & InferredPropTypes<P>, D>
            : TComponent extends { defaultProps: infer D }
                ? Defaultize<TProps, D>
                : TProps;
}
```

----------------------------------------

TITLE: Root Package.json for ESM Project
DESCRIPTION: Defines the `package.json` configuration for the root project, specifying `"type": "module"` to enable ECMAScript Modules (ESM) by default across the project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions2(module=node20).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
        "name": "package",
        "private": true,
        "type": "module"
    }
```

----------------------------------------

TITLE: Defining Variables, Classes, and Functions in TypeScript (m1.ts)
DESCRIPTION: This snippet from ref/m1.ts defines a global variable m1_a1, a class m1_c1 with a public property, an instance of m1_c1, and a function m1_f1 that returns this instance. It demonstrates basic TypeScript syntax for variable, class, and function declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/sourcerootUrlSubfolderSpecifyOutputFile/node/sourcerootUrlSubfolderSpecifyOutputFile.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var m1_a1 = 10;
    class m1_c1 {
        public m1_c1_p1: number;
    }
    
    var m1_instance1 = new m1_c1();
    function m1_f1() {
        return m1_instance1;
    }
```

----------------------------------------

TITLE: Defining Dual Package Exports in package.json (JSON)
DESCRIPTION: This `package.json` defines a dual package, specifying both CommonJS (`index.cjs`) and ES Module (`index.js`) entry points using the `exports` field. It also sets `type: "module"` and `main: "index.cjs"` for backward compatibility, and `types: "index.d.cts"` for TypeScript declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/bundlerNodeModules1(module=esnext).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "name": "dual",
      "version": "1.0.0",
      "type": "module",
      "main": "index.cjs",
      "types": "index.d.cts",
      "exports": {
        ".": {
          "import": "./index.js",
          "require": "./index.cjs"
        }
      }
    }
```

----------------------------------------

TITLE: Defining Variables, Classes, and Functions in TypeScript
DESCRIPTION: This snippet demonstrates fundamental TypeScript syntax for declaring a variable, defining a class with a public property, instantiating the class, and defining a function that returns an instance of the class. It showcases basic object-oriented programming concepts and variable scope within a TypeScript file.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/sourcemapSingleFileSpecifyOutputFile/node/sourcemapSingleFileSpecifyOutputFile.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var a1 = 10;
    class c1 {
        public p1: number;
    }
    
    var instance1 = new c1();
    function f1() {
        return instance1;
    }
```

----------------------------------------

TITLE: Accessing Missing Property on Generic Type (TS2339) in TypeScript
DESCRIPTION: This snippet defines two generic functions. The `dupeAndGetDist` function attempts to call `getDist()` on its generic parameter `U` without `U` having a constraint that ensures the `getDist` method exists. This results in TypeScript error TS2339, indicating that the property 'getDist' does not exist on type 'U', demonstrating the need for explicit type constraints for generic operations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/genericCallSpecializedToTypeArg.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function dupe<T>(x: T): T {
  return x;
}
function dupeAndGetDist<U>(x: U): U {
  var y = dupe(x);
  y.getDist();
  return y;
}
```

----------------------------------------

TITLE: Using Logical OR Assignment (||=) in TypeScript
DESCRIPTION: This function demonstrates the use of the logical OR assignment operator (`||=`). If `results` is falsy (e.g., `undefined` or `null`), it is assigned the value of `bar?.value ?? []`. The `push(100)` operation then adds an element to the (now guaranteed) array. This ensures `results` is an array before `push` is called.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/logicalAssignment8(target=es2015).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare const bar: { value?: number[] } | undefined

function foo1(results: number[] | undefined) {
    (results ||= bar?.value ?? []).push(100);
}
```

----------------------------------------

TITLE: Defining Classes and Interfaces with Private Members in TypeScript
DESCRIPTION: This snippet defines a base class 'C' with a public method and a private property, an interface 'I' that extends 'C' and adds a new public method, and a derived class 'D' that extends 'C' and implements 'I', adding another public method. This setup creates the types used for subsequent type compatibility checks.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/interfaceExtendsClassWithPrivate1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class C {
    public foo(x: any) { return x; }
    private x = 1;
}

interface I extends C {
    other(x: any): any;
}

class D extends C implements I {
    public foo(x: any) { return x; }
    other(x: any) { return x; }
    bar() { }
}
```

----------------------------------------

TITLE: Demonstrating Unused Locals in Nested TypeScript Functions
DESCRIPTION: This TypeScript code defines a `greeter` function expression with parameters `person` and `person2`. Inside `greeter`, a local variable `unused` is declared, and a nested `maker` function expression is defined with a parameter `child` and a local variable `unused2`. The snippet demonstrates TypeScript compiler errors (TS6133) for `person`, `person2`, `unused`, `maker`, `child`, and `unused2` because they are declared but their values are never read. Although `person2` is assigned a value later, it's still flagged as unused in the context of its initial declaration as a parameter.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unusedLocalsOnFunctionExpressionWithinFunctionExpression1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
    var greeter = function (person: string, person2: string) {
        var unused = 20;
        var maker = function (child: string): void {
            var unused2 = 22;
        }
        person2 = "dummy value";
    }
```

----------------------------------------

TITLE: TypeScript Conditional Type Assignment Error (Excess Property)
DESCRIPTION: This snippet demonstrates another TypeScript type assignment error (TS2322) where an object literal '{ test: 'bye', arg: a, arr: a }' is not assignable to 'Something<A>'. In this case, the literal contains an 'excess' property 'arr', which is not defined in the 'Something<A>' type, leading to the assignment failure.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/conditionalTypesExcessProperties.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type Something<T> = { test: string } &  (T extends object ? {
    arg: T
} : {
    arg?: undefined
    });

function testFunc2<A extends object>(a: A, sa: Something<A>) {
    sa = { test: 'bye', arg: a, arr: a } // excess
    // error TS2322: Type '{ test: string; arg: A; arr: A; }' is not assignable to type 'Something<A>'.
    // Type '{ test: string; arg: A; arr: A; }' is not assignable to type 'A extends object ? { arg: A; } : { arg?: undefined; }'.
}
```

----------------------------------------

TITLE: Accessing Destructured Property from 'unknown' Catch Variable - TypeScript
DESCRIPTION: This snippet illustrates the TS2339 error when attempting to access a destructured property ('x') from a catch clause variable explicitly typed as 'unknown' (or a typedef resolving to 'unknown') without prior type narrowing. TypeScript correctly flags this as an error because properties of 'unknown' types cannot be accessed directly.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsdocCatchClauseWithTypeAnnotation.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
try { } catch (/** @type {unknown} */ { x }) { console.log(x); } // error in the destructure
try { } catch (/** @type {Unknown} */ { x }) { console.log(x); } // error in the destructure
```

----------------------------------------

TITLE: Declaring TypeScript Auto Accessors with Literal Computed Names
DESCRIPTION: This TypeScript code demonstrates the correct syntax for declaring auto-accessors within a class using simple literal computed property names. It shows both instance and static auto-accessors initialized with or without default values, which are valid according to TypeScript's rules for computed property names in class property declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/autoAccessor5(target=esnext).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
class C1 {
    accessor ["w"]: any;
    accessor ["x"] = 1;
    static accessor ["y"]: any;
    static accessor ["z"] = 2;
}
```

----------------------------------------

TITLE: Defining Readonly and Optional Mapped Type T05 in TypeScript
DESCRIPTION: This mapped type, T05, creates a new type where all properties of the generic type T are made both 'readonly' and optional. This combines the immutability of 'readonly' with the flexibility of optional properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypes6.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
type T05<T> = { readonly [P in keyof T]?: T[P] };
```

----------------------------------------

TITLE: Exporting Modules in TypeScript Declaration Files
DESCRIPTION: These snippets show how modules are re-exported from TypeScript declaration files (.d.ts, .d.mts, .d.cts) using `export { alias }` syntax. They import modules with different extensions and then re-export them, defining the public API surface.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackagePatternExportsTrailers(module=node20).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
// cjs format file
    import * as cjs from "inner/cjs/index.cjs";
    import * as mjs from "inner/mjs/index.mjs";
    import * as type from "inner/js/index.js";
    export { cjs };
    export { mjs };
    export { type };
```

LANGUAGE: TypeScript
CODE:
```
// esm format file
    import * as cjs from "inner/cjs/index.cjs";
    import * as mjs from "inner/mjs/index.mjs";
    import * as type from "inner/js/index.js";
    export { cjs };
    export { mjs };
    export { type };
```

LANGUAGE: TypeScript
CODE:
```
// cjs format file
    import * as cjs from "inner/cjs/index.cjs";
    import * as mjs from "inner/mjs/index.mjs";
    import * as type from "inner/js/index.js";
    export { cjs };
    export { mjs };
    export { type };
```

----------------------------------------

TITLE: Declaring a Robot Object in TypeScript
DESCRIPTION: This snippet demonstrates the declaration and initialization of a `robotB` object with a `Robot` type annotation. It includes nested properties for `name` and `skills`, where `skills` itself is an object with `primary` and `secondary` attributes. This showcases basic object literal syntax with type safety.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementNestedObjectBindingPattern.sourcemap.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
var robotB: Robot = {
  name: "trimmer",
  skills: {
    primary: "trimming",
    secondary: "edging"
  }
};
```

----------------------------------------

TITLE: Incorrect Imports with Global Type Conflicts (TypeScript)
DESCRIPTION: This TypeScript snippet demonstrates an incorrect import of custom 'Date' and 'Event' types from './types.ts'. The regular imports conflict with built-in global 'Date' and 'Event' types, leading to TS2866 errors when 'isolatedModules' is enabled, as they are not declared as type-only imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/isolatedModulesShadowGlobalTypeNotValue(isolatedmodules=true,verbatimmodulesyntax=false).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { Date, Event } from './types';
function foo(a: Date) {
    const b = new Date(a.year, a.month, a.day);
    return b.getTime();
}
function bar() {
    return new Event('bar') as Event.T;
}
```

----------------------------------------

TITLE: Creating Discriminated Union Members from Union Literal Parameters (GH18421)
DESCRIPTION: This example demonstrates how to construct an object that conforms to a discriminated union type (`Thing`) when the discriminator property's value (`thingType`) is passed as a union literal parameter. TypeScript correctly infers the return type of `makeNewThing` as `Thing`, showing proper handling of literal type arguments in object creation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/assignmentCompatWithDiscriminatedUnion.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
interface ThingTypeOne {
    type: 'one';
}

interface ThingTypeTwo {
    type: 'two';
}

type ThingType = 'one' | 'two';

type Thing = ThingTypeOne | ThingTypeTwo;

function makeNewThing(thingType: ThingType): Thing {
    return {
        type: thingType
    };
}
```

----------------------------------------

TITLE: Calling foo3 with Nested Object Parameter in TypeScript
DESCRIPTION: This snippet demonstrates calling the `foo3` function with a complex object literal as its argument. The object includes a `name` property and a nested `skills` object, which itself contains `primary` and `secondary` skill properties. This pattern is common when working with destructuring parameters in TypeScript/JavaScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringParameterNestedObjectBindingPattern.sourcemap.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
foo3({ name: "Edger", skills: { primary: "edging", secondary: "branch trimming" } });
```

----------------------------------------

TITLE: Type Narrowing with Boolean Discriminator and Destructuring in TypeScript
DESCRIPTION: The `f30` function illustrates type narrowing with a boolean discriminator (`isA`) on destructured parameters. Checking either `kind` or `isA` correctly narrows the type of the other property, showcasing TypeScript's ability to infer relationships between properties in a union.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/dependentDestructuredVariables.errors.txt#_snippet_12

LANGUAGE: TypeScript
CODE:
```
function f30({ kind, isA }: Foo) {
    if (kind === 'A') {
        isA;   // true
    }
    if (kind === 'B') {
        isA;   // false
    }
    if (kind === 'C') {
        isA;   // false
    }
    if (isA) {
        kind;  // 'A'
    }
    else {
        kind;  // 'B' | 'C'
    }
}
```

----------------------------------------

TITLE: Control Flow Narrowing with Tuple Elements in TypeScript
DESCRIPTION: This function illustrates type narrowing for tuple elements. Initial assignments result in 'number | null' and 'string | null'. However, inside the 'if (obj[0] && obj[1])' block, TypeScript correctly narrows 'c0' to 'number' and 'c1' to 'string' for both direct access and destructuring assignments.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/destructuringControlFlow.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function f2(obj: [number, string] | null[]) {
    let a0 = obj[0];  // number | null
    let a1 = obj[1];  // string | null
    let [b0, b1] = obj;
    ([a0, a1] = obj);
    if (obj[0] && obj[1]) {
        let c0 = obj[0];  // number
        let c1 = obj[1];  // string
        let [d0, d1] = obj;
        ([c0, c1] = obj);
    }
}
```

----------------------------------------

TITLE: ESM Imports in JavaScript (index.js)
DESCRIPTION: This snippet demonstrates an ECMAScript module (ESM) file, typically inferred from context or `type: "module"` in `package.json`, successfully importing various packages, including CommonJS (cjs), ES Module (mjs), and type-only imports. It shows successful resolution in an ESM context without errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageExports(module=node18).errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
// esm format file
    import * as cjs from "package/cjs";
    import * as mjs from "package/mjs";
    import * as type from "package";
    cjs;
    mjs;
    type;
    import * as cjsi from "inner/cjs";
    import * as mjsi from "inner/mjs";
    import * as typei from "inner";
    cjsi;
    mjsi;
    typei;
```

----------------------------------------

TITLE: Import Assignment Incompatibility with ESNext Modules - TypeScript
DESCRIPTION: This snippet demonstrates the use of an `import = require` assignment, which is not compatible when the TypeScript compiler is targeting ECMAScript modules. TypeScript error TS1202 indicates that this syntax should be replaced with standard ES module imports like `import * as ns from 'mod'`, `import {a} from 'mod'`, or `import d from 'mod'`. Additionally, error TS2792 suggests that the module 'mod' cannot be found, implying a need to adjust the `moduleResolution` option (e.g., to 'nodenext') or configure `paths` in `tsconfig.json`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/esnextmodulekindWithES5Target10.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import i = require("mod");
```

----------------------------------------

TITLE: Generic Function with Keyof T | Keyof U and Intersection Type Access
DESCRIPTION: This function demonstrates a generic approach to accessing properties from an intersection of two object types. The key 'K' is constrained to be a key of either 'T' or 'U', and the function returns the value of that key from the intersected type (T & U). This allows for flexible property access where the key might originate from either of the input types, but the resulting type is derived from their combined structure.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess.errors.txt#_snippet_37

LANGUAGE: TypeScript
CODE:
```
function f72(func: <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]) {
    let a = func({ a: 1, b: "hello" }, { c: true }, 'a');  // number
    let b = func({ a: 1, b: "hello" }, { c: true }, 'b');  // string
    let c = func({ a: 1, b: "hello" }, { c: true }, 'c');  // boolean
}
```

----------------------------------------

TITLE: Defining TPromise Type in TypeScript
DESCRIPTION: This type definition extends a standard Promise by omitting its original `then` and `catch` methods and replacing them with custom ones that return `TPromise` itself. This allows for chaining operations while maintaining the custom `TPromise` type, useful for specific promise-like behaviors or custom error handling.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationEmitPrivatePromiseLikeInterface.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
type TPromise<ResolveType, RejectType = any> = Omit<Promise<ResolveType>, "then" | "catch"> & {
        then<TResult1 = ResolveType, TResult2 = never>(
            onfulfilled?: ((value: ResolveType) => TResult1 | PromiseLike<TResult1>) | undefined | null,
            onrejected?: ((reason: RejectType) => TResult2 | PromiseLike<TResult2>) | undefined | null,
        ): TPromise<TResult1 | TResult2, RejectType>;
        catch<TResult = never>(
            onrejected?: ((reason: RejectType) => TResult | PromiseLike<TResult>) | undefined | null,
        ): TPromise<ResolveType | TResult, RejectType>;
    };
```

----------------------------------------

TITLE: Exporting Constants in TypeScript
DESCRIPTION: This snippet defines and exports two constants, `a` and `b`, from the `0.ts` module. These constants can then be imported and used by other modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportAsNamespace3(module=esnext).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export const a = 1;
export const b = 2;
```

----------------------------------------

TITLE: Using module.exports in ESM (TS2580 Error)
DESCRIPTION: This snippet demonstrates the TS2580 error when 'module.exports' is used in a file configured as an ECMAScript module (ESM), indicated by 'import "fs";' and likely 'type: "module"' in 'package.json'. In ESM, 'module' and 'exports' are not globally available, leading to this error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsExportAssignment(module=node16).errors.txt#_snippet_3

LANGUAGE: JavaScript
CODE:
```
// esm format file
import "fs";
const a = {};
module.exports = a;
```

----------------------------------------

TITLE: ES Module Export for 'foo' Module (JavaScript)
DESCRIPTION: This JavaScript file provides an ES Module export for the `foo` module, exporting `foo` as a constant. This is used when `import` is the resolution method.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/resolvesWithoutExportsDiagnostic1(moduleresolution=bundler).errors.txt#_snippet_2

LANGUAGE: JavaScript
CODE:
```
export const foo = 1;
```

----------------------------------------

TITLE: Exhaustive Switch with Never Type in TypeScript
DESCRIPTION: Shows an exhaustive `switch` statement on a discriminated union type. The `default` case correctly narrows the type to `never`, demonstrating how TypeScript handles unreachable code paths for type checking and flags access to properties on `never`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exhaustiveSwitchStatements1.errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
type A = { kind: "abc" } | { kind: "def" };

function f35431(a: A) {
  switch (a.kind) {
    case "abc":
    case "def": return;
    default:
      a!.kind; // Error expected
         ~~~~
  }
}
```

----------------------------------------

TITLE: Accessing Property Specific to One Interface in Union (TypeScript)
DESCRIPTION: A variable `ab` of union type `AB` (A | B) is declared. Attempting to access `onlyInB` on `ab` results in a `TS2339` error. This is because `onlyInB` is defined only in interface `B` and not in `A`, making it not common to both members of the union.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unionPropertyExistence.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
var ab: AB;
ab.onlyInB;
```

----------------------------------------

TITLE: Using Template Literal Types with Record Utility - TypeScript
DESCRIPTION: Demonstrates how to use a template literal type (`IdType`) as the key type for TypeScript's `Record` utility. It shows how to create an object with such keys and access its properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/indexSignatures1.errors.txt#_snippet_38

LANGUAGE: TypeScript
CODE:
```
type A = Record<IdType, string>;

const a: A = { [id]: 'test' }

let aid = a[id];
```

----------------------------------------

TITLE: `let` Declarations in `for` Loop Initializers
DESCRIPTION: Demonstrates `let` declarations within the initializer of a `for` loop, including simple variable, array destructuring, and object destructuring. Variables declared with `let` in this context are scoped to the loop body. The `use(x)` outside the loop refers to the global `var x`, indicating the loop-scoped `let x` is not accessible outside.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/downlevelLetConst16.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
function foo3() {
    for (let x; ;) {
        use(x);
    }
    for (let [y] = []; ;) {
            use(y);
    }
    for (let {a: z} = {a: 1}; ;) {
        use(z);
    }
    use(x);
}
```

----------------------------------------

TITLE: Type Guarding Classes with Same Structure (No Inheritance) - TypeScript
DESCRIPTION: This example demonstrates type guarding for `C7` and `C8`, which are independent classes but share the same property structure. For a variable `let4: C8 | string`, checking `let4.constructor === C7` results in `never` because `C8` does not inherit from `C7`, and their constructors are distinct. The check `let4.constructor === C8` correctly narrows the type to `C8`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeGuardConstructorDerivedClass.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
class C7 {
    property1: number
}

class C8 {
    property1: number;
}

let let4: C8 | string;
if (let4.constructor === C7) {
    let4; // never
}
if (let4.constructor === C8) {
    let4; // C8
}
```

----------------------------------------

TITLE: Importing and Exporting Types and Values in TypeScript
DESCRIPTION: This snippet demonstrates importing a type using 'import type', re-exporting it, declaring a constant of that type, and defining a function that returns an instance of the imported type. It showcases common module patterns for type and value sharing in TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/allowImportingTypesDtsExtension(allowimportingtsextensions=false,moduleresolution=nodenext).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import type { User } from "./types.d.ts";
export type { User } from "./types.d.ts";

export const user: User = { name: "John" };

export function getUser(): import("./types.d.ts").User {
    return user;
}
```

----------------------------------------

TITLE: Defining ESLint Plugin Package Metadata (JSON)
DESCRIPTION: This snippet defines the basic metadata for the 'eslint-plugin-import-x' package, including its name, version, and main entry point. It's a standard Node.js package.json file that describes the project and its entry points.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportAssignmentExpressionIsExpressionNode.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "name": "eslint-plugin-import-x",
      "version": "1.0.0",
      "main": "index.cjs"
    }
```

----------------------------------------

TITLE: Implicit Any Errors with Mixed Explicit and Implicit Parameters in TypeScript
DESCRIPTION: This function type declaration shows implicit 'any' type errors for parameters 'x' and 'z'. Although 'y' is explicitly typed as 'any', 'x' and 'z' lack type annotations, causing TS7006 errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyParametersInInterface.errors.txt#_snippet_15

LANGUAGE: TypeScript
CODE:
```
f12: (x, y: any, z) => string;
```

----------------------------------------

TITLE: Iterating with Object Destructuring in For-Of Loop (TypeScript & Emitted JS)
DESCRIPTION: This snippet demonstrates a `for...of` loop in TypeScript utilizing complex object destructuring to extract `name`, `primary` skill, and `secondary` skill from objects returned by `getMultiRobots()`. The `codeList` includes both the original TypeScript source and its corresponding transpiled JavaScript output, illustrating how TypeScript's modern syntax is converted to ES5-compatible JavaScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPattern.sourcemap.txt#_snippet_33

LANGUAGE: TypeScript
CODE:
```
for (let {name: nameA, skills: { primary: primaryA, secondary: secondaryA } } of getMultiRobots()) {
    console.log(nameA);
}
```

LANGUAGE: JavaScript
CODE:
```
var _1 = _0[_z], nameA = _1.name, _2 = _1.skills, primaryA = _2.primary, secondaryA = _2.secondary;
console.log(nameA);
}
```

----------------------------------------

TITLE: Defining Object Types with Optional and Required Properties in TypeScript
DESCRIPTION: These type aliases define two object structures: 'Props' with all required properties and 'InputProps' which introduces an optional property 'foo'. This illustrates the fundamental difference between required and optional properties in TypeScript type definitions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/strictOptionalProperties1.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
type Props = {
    foo: string;
    bar: string
}

type InputProps = {
    foo?: string;
    bar: string;
}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler with outFile and files in tsconfig.json
DESCRIPTION: This tsconfig.json configuration specifies an 'outFile' for bundling compiled output and explicitly lists 'a.ts' and 'b.js' in the 'files' array. The inclusion of 'b.js' (a JavaScript file) without the 'allowJs' option is the direct cause of the TS6504 error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/jsFileCompilationDifferentNamesSpecified/amd/jsFileCompilationDifferentNamesSpecified.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "compilerOptions": { "outFile": "test.js" },
  "files": [ "a.ts", "b.js" ]
}
```

----------------------------------------

TITLE: Declaring Arrow Function Parameter with Implicit Any Type (TS7006) - TypeScript
DESCRIPTION: This example demonstrates a TS7006 error where the parameter 'y2' in an arrow function type declaration implicitly has an 'any' type due to the absence of an explicit type annotation. This error prevents potential runtime issues by enforcing type safety for function parameters.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/implicitAnyDeclareTypePropertyWithoutType.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
var x2: (y2) => number;
```

----------------------------------------

TITLE: Map Interface: Sequence Algorithms
DESCRIPTION: Includes methods for common sequence operations on a Map, such as concatenating, mapping values, mapping keys, mapping entries, flat mapping, and filtering elements based on a predicate.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/complexRecursiveCollections.errors.txt#_snippet_9

LANGUAGE: TypeScript
CODE:
```
// Sequence algorithms
concat<KC, VC>(...collections: Array<Iterable<[KC, VC]>>): Map<K | KC, V | VC>;
concat<C>(...collections: Array<{[key: string]: C}>): Map<K | string, V | C>;
map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Map<K, M>;
mapKeys<M>(mapper: (key: K, value: V, iter: this) => M, context?: any): Map<M, V>;
mapEntries<KM, VM>(mapper: (entry: [K, V], index: number, iter: this) => [KM, VM], context?: any): Map<KM, VM>;
flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Map<any, any>;
filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Map<K, F>;
filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
```

----------------------------------------

TITLE: Dynamic Import Resolution Failure (Missing Extension for Index in Subfolder2) - TypeScript
DESCRIPTION: Demonstrates a TypeScript error (TS2834) for a dynamic `import()` targeting an implicit `index` file within `subfolder2` (`./subfolder2/index`) without an explicit extension. The `node16` or `nodenext` module resolution requires explicit file extensions for relative ECMAScript imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node16).errors.txt#_snippet_42

LANGUAGE: TypeScript
CODE:
```
const _m42 = import("./subfolder2/index");
```

----------------------------------------

TITLE: Example Usage of TodoList Component
DESCRIPTION: This snippet shows how the `TodoList` component is intended to be used. It declares a variable `x` of type `TodoListProps` and then attempts to spread its properties onto the `TodoList` component. This demonstrates the typical way props are passed to a component.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadChildrenInvalidType(jsx=react-jsx,target=es2015).errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
let x: TodoListProps;
    <TodoList {...x}/>
```

----------------------------------------

TITLE: Type Narrowing with Tuple Union Parameters in TypeScript
DESCRIPTION: This snippet demonstrates type narrowing for parameters of a function that accepts a union of tuple types. Depending on the boolean `guard` parameter, the `value` parameter is correctly inferred as either `number` or `string` within the respective conditional blocks, showcasing TypeScript's ability to narrow types based on control flow analysis.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/dependentDestructuredVariables.errors.txt#_snippet_33

LANGUAGE: TypeScript
CODE:
```
const fa3: (...args: [true, number] | [false, string]) => void = (guard, value) => {
    if (guard) {
        for (;;) {
            value;  // number
        }
    }
    else {
        while (!!true) {
            value;  // string
        }
    }
}
```

----------------------------------------

TITLE: Demonstrating TS2339 Error on Union Type in TypeScript
DESCRIPTION: This snippet illustrates TypeScript error TS2339, which arises when a method (`toLowerCase`) is called on a union type (`string | Promise<string>`) but is not present on all types within the union (specifically, `Promise<string>`). It highlights the need for type narrowing or conditional checks before accessing properties on union types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nonexistentPropertyOnUnion.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function f(x: string | Promise<string>) {
    x.toLowerCase();
}
```

----------------------------------------

TITLE: TypeScript Import Assertion and Attribute Usage Errors
DESCRIPTION: This snippet demonstrates common TypeScript compilation errors related to deprecated `import assert` syntax, incorrect `resolution-mode` values, and attempts to import non-existent members. It highlights the transition from `assert` to `with` for import attributes and the strictness of `resolution-mode` values (`require` or `import`).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportModeDeclarationEmitErrors1(module=node20).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// incorrect mode
import type { RequireInterface } from "pkg" assert { "resolution-mode": "foobar" };
// not type-only
import { ImportInterface } from "pkg" assert { "resolution-mode": "import" };
// not exclusively type-only
import {type RequireInterface as Req, RequireInterface as Req2} from "pkg" assert { "resolution-mode": "require" };

export interface LocalInterface extends RequireInterface, ImportInterface {}
```

----------------------------------------

TITLE: Assigning Incompatible Types to 'never' in TypeScript
DESCRIPTION: This snippet demonstrates various attempts to assign values of different types (number, string, boolean, undefined, null, object) to a variable explicitly typed as 'never'. It also shows an attempt to call a 'never' type. TypeScript correctly flags all these assignments and the function call as errors, as 'never' represents a type that can never hold any value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/neverTypeErrors2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function f1() {
    let x: never;
    x = 1;
    x = "abc";
    x = false;
    x = undefined;
    x = null;
    x = {};
    x();
}
```

----------------------------------------

TITLE: Contextual Typing with OR Operator - Object Literals (TypeScript)
DESCRIPTION: This snippet demonstrates TypeScript error TS2872, 'This kind of expression is always truthy,' when using the logical OR operator (||) with two object literals. The TypeScript compiler flags this because the first operand `{ a: s => s.length }` is an object literal and will always evaluate to a truthy value, making the second operand `{ a: s => 1 }` unreachable. This highlights a common pitfall in using || for fallback values with non-primitive types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/contextuallyTypingOrOperator2.errors.txt#_snippet_0

LANGUAGE: typescript
CODE:
```
var v: { a: (_: string) => number } = { a: s => s.length } || { a: s => 1 };
```

----------------------------------------

TITLE: Type Inference with `const` Generic `readonly unknown[]` and Array Spread in TypeScript
DESCRIPTION: This snippet showcases type inference with a generic function `f4` that utilizes a `const` type parameter `T extends readonly unknown[]`. The `const` modifier helps infer narrower literal types for the elements within the tuple, providing more precise type checking and preventing widening of literal types when using array spread.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/arraySpreadInCall.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
declare function f4<const T extends readonly unknown[]>(...args: T): T;
const x41 = f4(...[1, 'foo'])
const x42 = f4(true, ...[1, 'foo'])
const x43 = f4(...([1, 'foo']))
const x44 = f4(true, ...([1, 'foo']))
```

----------------------------------------

TITLE: Handling Named Re-exports with TypeScript Module Resolution Errors
DESCRIPTION: This section illustrates named re-exports from various modules. Similar to named imports, these re-exports generate TypeScript errors (TS2305, TS2497) when the source modules use 'export =' or do not have the specified named export, or when 'esModuleInterop' is not configured.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/es6ExportEqualsInterop.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
export { a as a1 } from "interface";
export { a as a2 } from "variable";
export { a as a3 } from "interface-variable";
export { a as a4 } from "module";
export { a as a5 } from "interface-module";
export { a as a6 } from "variable-module";
export { a as a7 } from "function";
export { a as a8 } from "function-module";
export { a as a9 } from "class";
export { a as a0 } from "class-module";
```

----------------------------------------

TITLE: ESM TypeScript Declaration File Exports
DESCRIPTION: This .d.mts file serves as an ES Module TypeScript declaration, correctly importing and re-exporting type aliases for CJS, ESM, and generic JS modules. It demonstrates proper type definition for ESM consumers of the inner package.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackagePatternExports(module=node16).errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
import * as cjs from "inner/cjs/index";
import * as mjs from "inner/mjs/index";
import * as type from "inner/js/index";
export { cjs };
export { mjs };
export { type };
```

----------------------------------------

TITLE: ES Module Export in Explicit JavaScript ES Module (.mjs)
DESCRIPTION: This snippet demonstrates an ES module export in a '.mjs' file, which explicitly designates it as an ES module JavaScript file. This extension ensures ES module interpretation regardless of 'package.json' settings.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/impliedNodeFormatEmit3(module=commonjs).errors.txt#_snippet_5

LANGUAGE: JavaScript
CODE:
```
export const _ = 0;
```

----------------------------------------

TITLE: Exporting Constant in JavaScript ES Module (.mjs)
DESCRIPTION: This snippet shows a constant export in an ES module-style JavaScript file (`.mjs`). It exports a constant `_` with a value of `0`, explicitly marking it as an ES module.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/impliedNodeFormatEmit1(module=amd).errors.txt#_snippet_4

LANGUAGE: JavaScript
CODE:
```
    export const _ = 0;
```

----------------------------------------

TITLE: Accessing Nested Properties with Generic Types
DESCRIPTION: This function illustrates various methods for accessing deeply nested properties within a generic object type 'T'. 'T' is constrained to have an 'a' property which itself contains an 'x' property. It demonstrates using dot notation, bracket notation, and type assertions with indexed access types (T['a'], T['a']['x']) to maintain precise type information.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess.errors.txt#_snippet_40

LANGUAGE: TypeScript
CODE:
```
function f80<T extends { a: { x: any } }>(obj: T) {
    let a1 = obj.a;  // { x: any }
    let a2 = obj['a'];  // { x: any }
    let a3 = obj['a'] as T['a'];  // T["a"]
    let x1 = obj.a.x;  // any
    let x2 = obj['a']['x'];  // any
    let x3 = obj['a']['x'] as T['a']['x'];  // T["a"]["x"]
}
```

----------------------------------------

TITLE: Configuring Root Package as ESM in package.json
DESCRIPTION: This 'package.json' file configures the root directory as an ECMAScript Module (ESM) by setting "type": "module". This setting affects all '.ts' and '.js' files in the root and its subdirectories unless overridden by a nested 'package.json'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTopLevelAwait(module=node18).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Root Project package.json Configuration
DESCRIPTION: This `package.json` file configures the root project as an ECMAScript Module (`"type": "module"`) and defines its main export as `./index.js`. This setup is fundamental for how Node.js and TypeScript resolve modules within the project, especially in an ESM context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsSpecifierGenerationPattern(module=node16).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module",
    "exports": "./index.js"
}
```

----------------------------------------

TITLE: Defining DeepReadonly Utility Types in TypeScript
DESCRIPTION: These type definitions create a `DeepReadonly` utility type that recursively makes all properties of an object or elements of an array readonly. `DeepReadonlyObject` specifically uses `NonFunctionPropertyNames` to ensure that function properties are not included in the readonly transformation, allowing methods to remain mutable.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/conditionalTypes1.errors.txt#_snippet_14

LANGUAGE: TypeScript
CODE:
```
type DeepReadonly<T> =
    T extends any[] ? DeepReadonlyArray<T[number]> :
    T extends object ? DeepReadonlyObject<T> :
    T;

interface DeepReadonlyArray<T> extends ReadonlyArray<DeepReadonly<T>> {}

type DeepReadonlyObject<T> = {
    readonly [P in NonFunctionPropertyNames<T>]: DeepReadonly<T[P]>;
};
```

----------------------------------------

TITLE: Export Assignment Error (TS1203) in TypeScript
DESCRIPTION: This snippet illustrates the TS1203 error, which occurs when 'export assignment' syntax (e.g., `export = value;`) is used while targeting ECMAScript modules. This syntax is primarily for CommonJS modules. The error recommends using the ES module equivalent `export default` for exporting a single value as the default export, highlighting a mismatch between the module syntax used and the targeted module system.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/es6ImportEqualsDeclaration.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
var a = 10;
export = a;
```

----------------------------------------

TITLE: Compiling JSX with Preact (Error TS2875) in TypeScript
DESCRIPTION: This snippet shows a TypeScript file attempting to use Preact as its JSX import source, resulting in a 'TS2875' error. The error indicates that the 'preact/jsx-runtime' module path is required but not found, suggesting missing type definitions or an incorrect setup for Preact JSX compilation. The code itself is a JSX fragment similar to the React example, but its compilation fails due to the environment configuration.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxJsxsCjsTransformCustomImportPragma(jsx=react-jsx).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
/// <reference path="/.lib/react16.d.ts" />
/* @jsxImportSource preact */
const a = <>
  <p></p>
  text
  <div className="foo"></div>
</>

export {};
```

----------------------------------------

TITLE: Reducing Collections to Single Values or Summaries in TypeScript
DESCRIPTION: These methods aggregate collection elements into a single value or a summary. They include standard `reduce` operations, checks for element properties (`every`, `some`), string concatenation (`join`), size checks (`isEmpty`, `count`), and grouping counts (`countBy`).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/complexRecursiveCollections.errors.txt#_snippet_60

LANGUAGE: TypeScript
CODE:
```
reduce<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
reduce<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
reduceRight<R>(reducer: (reduction: R, value: V, key: K, iter: this) => R, initialReduction: R, context?: any): R;
reduceRight<R>(reducer: (reduction: V | R, value: V, key: K, iter: this) => R): R;
every(predicate: (value: V, key: K, iter: this) => boolean, context?: any): boolean;
some(predicate: (value: V, key: K, iter: this) => boolean, context?: any): boolean;
join(separator?: string): string;
isEmpty(): boolean;
count(): number;
count(predicate: (value: V, key: K, iter: this) => boolean, context?: any): number;
countBy<G>(grouper: (value: V, key: K, iter: this) => G, context?: any): Map<G, number>;
```

----------------------------------------

TITLE: Type Narrowing with Null Check Assignment in TypeScript
DESCRIPTION: Demonstrates how assigning a union type `T | null` to a new variable `y` and then performing a `null` check on `y` correctly narrows the type of `y` within the `if` block to `T`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownControlFlow.errors.txt#_snippet_23

LANGUAGE: TypeScript
CODE:
```
function foo<T>(x: T | null) {
    let y = x;
    if (y !== null) {
        y;
    }
}
```

----------------------------------------

TITLE: Configuring Root Project as ES Module
DESCRIPTION: This root `package.json` marks the project as private and explicitly sets its `type` to `module`. This configuration indicates that files within this project, by default, should be treated as ES modules, affecting how dependencies are resolved.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride2(module=node16).errors.txt#_snippet_4

LANGUAGE: JSON
CODE:
```
{
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Defining Basic Async Functions in TypeScript
DESCRIPTION: This snippet demonstrates the basic syntax for defining `async` functions in TypeScript. It shows functions with implicit `Promise<void>` return types and explicit annotations for `Promise<void>` or a custom `MyPromise<void>` type, indicating that these functions will always return a Promise.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/asyncAwaitIsolatedModules_es6.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
async function f0() { }
async function f1(): Promise<void> { }
async function f3(): MyPromise<void> { }
```

----------------------------------------

TITLE: TypeScript For-Of Loop with Array Destructuring
DESCRIPTION: This snippet shows a `for...of` loop in TypeScript that iterates over the result of `getRobots()`, using array destructuring to assign the first element to `numberA3` and the rest to `robotAInfo`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfArrayBindingPattern2.sourcemap.txt#_snippet_58

LANGUAGE: TypeScript
CODE:
```
for ([numberA3, ...robotAInfo] of getRobots()) {
```

----------------------------------------

TITLE: Function Parameter Destructuring with Default Values - TypeScript
DESCRIPTION: Shows how to use object destructuring with default values directly in function parameters. If `a` or `b` are not provided or are `undefined` in the argument object, their respective default values are used.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/shorthandPropertyAssignmentsInDestructuring_ES6.errors.txt#_snippet_21

LANGUAGE: TypeScript
CODE:
```
function foo({a = 4, b = { x: 5 }}) {
}
```

----------------------------------------

TITLE: Declaring Interface Variable in TypeScript
DESCRIPTION: This snippet declares a variable `d1` of type `InterfaceX`. This variable is intended to hold an instance that conforms to the `InterfaceX` contract, allowing access to its defined properties and methods.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeResolution.sourcemap.txt#_snippet_46

LANGUAGE: TypeScript
CODE:
```
var d1: InterfaceX;
```

----------------------------------------

TITLE: Assigning Extraneous Props to React Component (TypeScript)
DESCRIPTION: This code attempts to instantiate the `EmptyProp` component using an object spread (`...o`). Since `EmptyProp` expects no props, passing `prop1: boolean` results in a `TS2559` error, indicating that the passed properties have nothing in common with the component's expected props.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadAttributesResolution5.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
let o = {
    prop1: false
}
// Ok
let e = <EmptyProp {...o} />;
```

----------------------------------------

TITLE: Defining Arrow Function with Multiple Destructured Properties and Default Value (TypeScript)
DESCRIPTION: This snippet defines an arrow function `f7` that destructures `a`, `b`, and `c` from an object `O`. Property `a` is renamed to `string` and assigned a default value of an empty string, demonstrating default values with multiple destructured properties in arrow functions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/renamingDestructuredPropertyInFunctionType.errors.txt#_snippet_38

LANGUAGE: TypeScript
CODE:
```
const f7 = ({ a: string = "", b, c }: O) => { };
```

----------------------------------------

TITLE: Configuring Module Exports in Node.js package.json
DESCRIPTION: This JSON snippet from a 'package.json' file defines the 'exports' field, which specifies how the 'pkg' module's subpaths are resolved for different environments. It maps 'import' conditions to './import.js' and 'require' conditions to './require.js', influencing how TypeScript's module resolution finds type declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportModeDeclarationEmit1(module=nodenext).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Testing Function.prototype.bind with Class Methods - TypeScript
DESCRIPTION: Explores `bind` usage on methods of class `C`. It demonstrates correct binding and partial application, as well as type errors when arguments are mismatched (`f13`) or when an incorrect `this` context is provided (`f14`), emphasizing the strict `this` parameter checking.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/strictBindCallApply1.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
declare let c: C;
declare let obj: {};

let f10 = c.foo.bind(c);
let f11 = c.foo.bind(c, 10);
let f12 = c.foo.bind(c, 10, "hello");
let f13 = c.foo.bind(c, 10, 20);  // Error
let f14 = c.foo.bind(undefined);  // Error
```

----------------------------------------

TITLE: Scoping `let` in Arbitrary Blocks - TypeScript
DESCRIPTION: Shows that `let` declarations within arbitrary code blocks (`{}`) are strictly block-scoped. Variables declared with `let` inside such blocks are not accessible outside of them, reinforcing `let`'s block-level scoping behavior.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/letDeclarations-scopes.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
{
    let l = 0;
    n = l;
    {
        let l = false;
        var b: boolean = l;
    }
}
```

----------------------------------------

TITLE: Derived Class DD: Property Overriding Method Without 'override'
DESCRIPTION: This snippet defines class `DD` extending `B`. It demonstrates a TS4114 error where `fooo` is declared as a property in `DD`, implicitly overriding the `fooo` method from `B` without the required `override` modifier. The `foo` member is correctly overridden.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/override4.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
class DD extends B {
    override foo: () => void
    fooo: () => void;
}
```

----------------------------------------

TITLE: Importing Modules in ESM TypeScript (index.ts)
DESCRIPTION: This TypeScript file, configured as an ECMAScript module (ESM), demonstrates importing various module types (CommonJS, ECMAScript, and plain JavaScript) from the 'inner' package. It serves as a test case for module resolution without errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackagePatternExportsTrailers(module=node18).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// esm format file
import * as cjsi from "inner/cjs/index.cjs";
import * as mjsi from "inner/mjs/index.mjs";
import * as typei from "inner/js/index.js";
cjsi;
mjsi;
typei;
```

----------------------------------------

TITLE: Implementing a Generic Compose Function in TypeScript
DESCRIPTION: The `compose` function is a higher-order function that chains multiple functions together, applying them sequentially from left to right. It is overloaded to support composing a varying number of functions, ultimately returning a single function that takes an initial value and passes it through the entire chain.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/inferFromGenericFunctionReturnTypes1.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function compose<A, B, C, D, E>(
  fnA: (a: SetOf<A>) => SetOf<B>, 
  fnB: (b: SetOf<B>) => SetOf<C>, 
  fnC: (c: SetOf<C>) => SetOf<D>,
  fnD: (c: SetOf<D>) => SetOf<E>,
):(x: SetOf<A>) => SetOf<E>;
/* ... etc ... */
function compose<T>(...fns: ((x: T) => T)[]): (x: T) => T {
  return (x: T) => fns.reduce((prev, fn) => fn(prev), x);
}
```

----------------------------------------

TITLE: Required TypeScript Compiler Options for `await using`
DESCRIPTION: This snippet provides the essential `compilerOptions` configuration for `tsconfig.json` that enables the use of `await using` declarations and resolves the TS2854 error. Setting the `module` to 'es2022' or higher and `target` to 'es2017' or higher ensures compatibility.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarations.1(target=es2015).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
  "compilerOptions": {
    "module": "es2022",
    "target": "es2017"
  }
}
```

----------------------------------------

TITLE: Modern Array Destructuring in JavaScript For Loop
DESCRIPTION: This snippet showcases the modern JavaScript array destructuring syntax directly within the `for` loop's initialization. It concisely extracts `nameMA` and a nested array `[primarySkillA, secondarySkillA]` from the `getMultiRobot()` return value. This approach significantly improves code readability and reduces boilerplate compared to traditional indexing.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForArrayBindingPattern.sourcemap.txt#_snippet_47

LANGUAGE: JavaScript
CODE:
```
for (let [nameMA, [primarySkillA, secondarySkillA]] = getMultiRobot(), i = 0; i < 1; i++)
```

----------------------------------------

TITLE: package.json Configuration for Module Type and Import Maps
DESCRIPTION: Illustrates a 'package.json' configuration defining the package as an ESM module ("type": "module") and setting up import maps ("imports") to alias internal module paths for cjs, mjs, and type files, which can lead to TS2210 if 'rootDir' is not specified.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageImports(module=node20).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module",
    "exports": "./index.js",
    "imports": {
        "#cjs": "./index.cjs",
        "#mjs": "./index.mjs",
        "#type": "./index.js"
    }
}
```

----------------------------------------

TITLE: Using 'in' Operator with Interface Union Types in TypeScript
DESCRIPTION: This snippet demonstrates the 'in' operator with union types composed of interfaces. 'c1' is a union of 'X' and 'Y', and '(c2 || c3)' also resolves to a union type. These are valid right-hand operands because interfaces implicitly extend 'object' and thus satisfy the 'in' operator's type requirements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/inOperatorWithValidOperands.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
interface X { x: number }
interface Y { y: number }

var c1: X | Y;
var c2: X;
var c3: Y;

var rc1 = x in c1;
var rc2 = x in (c2 || c3);
```

----------------------------------------

TITLE: Declaring TypeMap and Generic Functions in TypeScript
DESCRIPTION: This snippet defines a `TypeMap` interface for mapping string literals to specific types. It also declares a generic function `f` and a type alias `F1` that utilize template literal types for their parameters, demonstrating the foundational setup for type mapping scenarios.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes5.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
interface TypeMap {
  a: "A";
  b: "B";
}
declare const f: <T0 extends "a" | "b">(x: `${T0}`) => TypeMap[T0];
type F1 = <T1 extends "a" | "b">(x: `${T1}`) => TypeMap[T1];
const f1: F1 = f;
```

----------------------------------------

TITLE: Defining Generic Construct Signatures in a Base Interface (A)
DESCRIPTION: This snippet shows a collection of generic construct signatures, likely belonging to a base interface named 'A'. These signatures define various constructor patterns, including those with type parameters, function arguments, and object literal arguments, which are then attempted to be overridden or re-declared in extending interfaces.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/constructSignatureAssignabilityInInheritance6.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
a6: new <T extends Base>(x: (arg: T) => Derived) => T;
a11: new <T>(x: { foo: T }, y: { foo: T; bar: T }) => Base;
a15: new <T>(x: { a: T; b: T }) => T[];
a16: new <T extends Base>(x: { a: T; b: T }) => T[];
```

----------------------------------------

TITLE: Exporting Functions and Modules in Node.js with JSDoc
DESCRIPTION: This JavaScript snippet defines and exports a function `f1` with a JSDoc comment specifying a string parameter. It also exports `m2`, an imported module. This illustrates common Node.js module exports and the use of JSDoc for type hinting.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/nodeModulesMaxDepthIncreased/node/nodeModulesMaxDepthIncreased.errors.txt#_snippet_3

LANGUAGE: JavaScript
CODE:
```
var m2 = require('m2');

/**
 * @param {string} p1 The first param
 */
exports.f1 = function(p1) {
	return 42;
};

exports.f2 = m2;
```

----------------------------------------

TITLE: Demonstrating Unchecked Indexed Access Errors in TypeScript Compound Assignments
DESCRIPTION: This snippet showcases different scenarios where TypeScript's `noUncheckedIndexedAccess` option triggers errors (TS18048 or TS2532) for compound assignments on properties or elements that could be `undefined`. It includes examples using dot notation, bracket notation with string literals and variables, and number-indexed maps with literals and variables. The errors highlight the need for explicit checks or non-null assertions before performing such operations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noUncheckedIndexedAccessCompoundAssignments.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare const stringMap: { [s: string]: number };
declare const s: string;
declare const numberMap: { [n: number]: number };
declare const n: number;

// Each line below should produce an error (TS18048 or TS2532) due to unchecked indexed access
stringMap.foo++;
--stringMap.foo;
stringMap.foo += 1;
stringMap.foo *= 1;
++stringMap['foo'];
stringMap['foo']--;
++stringMap[s];
stringMap[s]--;
numberMap[32]++;
numberMap[32] += 1;
numberMap[n]++;
numberMap[n] += 1;
```

----------------------------------------

TITLE: Declaring Function Returning Array with 'const' Type Parameter in TypeScript
DESCRIPTION: This snippet defines a generic function `f3` that takes a value of type `T` (with `const` modifier) and returns an array of `T`. The `const` modifier ensures that `T` is inferred as a literal type, leading to a `readonly` array type for the return value. The examples show `f3` inferring `readonly ["hello"]`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeParameterConstModifiers.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
declare function f3<const T>(x: T): T[];

const x31 = f3("hello");
const x32 = f3("hello");
```

----------------------------------------

TITLE: Using Math.acosh in TypeScript
DESCRIPTION: This snippet demonstrates the TS2550 error when attempting to use 'Math.acosh' without the 'es2015' or later 'lib' compiler option. The 'acosh' function, part of ES2015, is not recognized by default, leading to a property not found error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/doYouNeedToChangeYourTargetLibraryES2015.errors.txt#_snippet_42

LANGUAGE: TypeScript
CODE:
```
const testMathAcosh = Math.acosh(0);
```

----------------------------------------

TITLE: TypeScript: CJS File and Suggested MJS Extension for Imports (TS2835)
DESCRIPTION: Shows a CommonJS (CJS) format file and an associated TS2835 error, which suggests adding an '.mjs' extension to an import path. This error occurs when '--moduleResolution' is 'node16' or 'nodenext' and the import path might resolve to an MJS file.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node20).errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
// cjs format file
const x = 1;
export {x};
```

----------------------------------------

TITLE: Incorrect Interface Implementation from Base Class with Private Property - TypeScript
DESCRIPTION: This snippet shows 'C6' extending 'C3' and implementing 'i1'. 'C3' has a 'private name' property. When 'C6' attempts to implement 'i1', the inherited 'private name' from 'C3' does not satisfy the interface's public 'name' requirement, resulting in a TS2420 error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/interfaceImplementation8.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
interface i1 {
    name: string;
}

class C3 {
    private name:any;
}

class C6 extends C3 implements i1{ }
```

----------------------------------------

TITLE: Defining Properties Reduction Types in TypeScript
DESCRIPTION: These types, 'PropertiesReducer' and 'PropertiesReduce', are used to transform a 'TProperties' schema into its corresponding concrete object type. They apply 'Readonly', 'Partial', and 'Required' modifiers to properties based on the schema's definitions, effectively mapping schema properties to their static type representation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/deeplyNestedMappedTypes.errors.txt#_snippet_15

LANGUAGE: TypeScript
CODE:
```
export type PropertiesReducer<T extends TProperties, R extends Record<keyof any, unknown>> = Evaluate<(
    Readonly<Partial<Pick<R, ReadonlyOptionalPropertyKeys<T>>>> &
    Readonly<Pick<R, ReadonlyPropertyKeys<T>>> &
    Partial<Pick<R, OptionalPropertyKeys<T>>> &
    Required<Pick<R, RequiredPropertyKeys<T>>>
)>
export type PropertiesReduce<T extends TProperties, P extends unknown[]> = PropertiesReducer<T, {
    [K in keyof T]: Static<T[K], P>
}>
```

----------------------------------------

TITLE: Declaring Function Overloads in TypeScript
DESCRIPTION: This snippet demonstrates function overloading in TypeScript. It declares two overloads for the `fn` function, one accepting `WorkerFS` and another accepting `FileSystem`, with a single implementation signature that accepts a union type of both. This pattern allows for different call signatures based on input types while maintaining a single underlying implementation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/elaboratedErrors.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function fn(s: WorkerFS): void;
function fn(s: FileSystem): void;
function fn(s: FileSystem|WorkerFS) { }
```

----------------------------------------

TITLE: Using Pipe Function with Explicitly Typed Callback Parameters in TypeScript
DESCRIPTION: This example illustrates the 'pipe' function's type inference capabilities when the callback parameters are explicitly named. TypeScript correctly infers the types of 'a', 'b', and 'c' (string, number, boolean) based on the preceding arguments provided to the 'pipe' function.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/variadicTuples2.errors.txt#_snippet_35

LANGUAGE: TypeScript
CODE:
```
pipe("foo", 123, true, (a, b, c) => {
    a;  // string
    b;  // number
    c;  // boolean
})
```

----------------------------------------

TITLE: Implementing a Higher-Order Component (HOC) with Generic Classes in TypeScript
DESCRIPTION: This snippet defines a base `Comp` class and a `CompClass` type for its constructor. It then introduces `myHoc`, a higher-order component function that takes a `CompClass` and returns a new `CompClass`. The example `GenericComp` extends `Comp` with generic props, demonstrating how `myHoc` correctly infers and propagates generic types when applied to a generic class.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/genericFunctionInference1.errors.txt#_snippet_9

LANGUAGE: TypeScript
CODE:
```
declare class Comp<P> {
    props: P;
    constructor(props: P);
}

type CompClass<P> = new (props: P) => Comp<P>;

declare function myHoc<P>(C: CompClass<P>): CompClass<P>;

type GenericProps<T> = { foo: number, stuff: T };

declare class GenericComp<T> extends Comp<GenericProps<T>> {}

const GenericComp2 = myHoc(GenericComp);
```

----------------------------------------

TITLE: Illustrating Type Mismatch with `satisfies` Operator in TypeScript
DESCRIPTION: This snippet demonstrates the use of the `satisfies` operator to ensure an object conforms to the `Facts` type. It intentionally introduces a type mismatch where property `s` is a `string` but `Facts` expects `boolean` values, resulting in a `TS2322` error. This highlights how `satisfies` helps catch type errors at the assignment level, ensuring strict type adherence.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeSatisfaction_propertyValueConformance1(nopropertyaccessfromindexsignature=false).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
const x2 = {
    m: true,
    s: "false"
} satisfies Facts;
```

----------------------------------------

TITLE: Configuring Subfolder Package for CommonJS in JSON
DESCRIPTION: This `package.json` snippet within a subfolder explicitly sets its module type to `commonjs`. This overrides any parent `"type": "module"` setting for files within this specific directory, ensuring they are interpreted as CommonJS modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions2(module=node16).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
    "type": "commonjs"
}
```

----------------------------------------

TITLE: Correct JSX Usage: Function Component in TypeScript
DESCRIPTION: This snippet illustrates the correct way to use a function `Fact` as a JSX component. Function components are valid JSX element types because they possess a call signature, allowing them to be invoked to render elements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxElementResolution8.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
function Fact(): any { return null; }
<Fact />
```

----------------------------------------

TITLE: Aggregating Array Elements with Underscore.js `reduce` in TypeScript
DESCRIPTION: Illustrates using `_.reduce` to boil down a list of values into a single value. It takes an array, an iterator function, and an initial memo value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/underscoreTest1.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
var sum = _.reduce([1, 2, 3], (memo, num) => memo + num, 0);
```

----------------------------------------

TITLE: MyComp Prop Type Mismatch Error (Number to String) in TypeScript
DESCRIPTION: This example shows a TS2322 error where the 'b' prop, defined as a 'string' in the 'Prop' interface, is incorrectly assigned a 'number' value (20) during component instantiation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxTypeArgumentResolution.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
x = <MyComp<Prop> a={10} b={20} />; // error
```

----------------------------------------

TITLE: Defining React Component Props Interface and Component in TypeScript
DESCRIPTION: This code defines the `IProps` interface for a React component, specifying `primaryText` as a `string` and using an index signature `[propName: string]: string | number` to allow other props to be either a `string` or a `number`. It also includes the `VerticalNavMenuItem` functional component that consumes these props.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxAttributeResolution14.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
    interface IProps {
      primaryText: string,
      [propName: string]: string | number
    }
    
    function VerticalNavMenuItem(prop: IProps) {
      return <div>props.primaryText</div>
    }
```

----------------------------------------

TITLE: JSX Type Error: Component Expects Single Child, Multiple Provided
DESCRIPTION: This example shows a `TS2746` error. The `Blah` component's `children` prop is defined to accept a *single* function. Providing multiple children, even if they match the function signature, leads to a type error because the prop expects a singular child.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxChildrenIndividualErrorElaborations.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
var a = <Blah>
      {x => "" + x}
      {x => "" + x}
</Blah>
```

----------------------------------------

TITLE: Demonstrating Top-Level Await Errors in CommonJS TypeScript
DESCRIPTION: This snippet illustrates TypeScript compilation errors (TS1309) that occur when 'await' is used at the top level of a CommonJS module. Both 'const x = await 1;' and 'for await (const y of []) {}' trigger this error, as CommonJS modules do not support top-level await. This file is implicitly CommonJS due to 'subfolder/package.json'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTopLevelAwait(module=node18).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// cjs format file
const x = await 1;
export {x};
for await (const y of []) {}
```

----------------------------------------

TITLE: Configuring JSX with React in TypeScript
DESCRIPTION: This snippet demonstrates basic JSX usage with React as the import source. It defines properties and uses them in `div` elements, showcasing attribute spreading and key placement. It also includes a reference to a React 16 declaration file and imports another module, illustrating a typical setup for React applications.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxJsxsCjsTransformKeyPropCustomImportPragma(jsx=react-jsxdev).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
/// <reference path="/.lib/react16.d.ts" />
/* @jsxImportSource react */
import "./preact";
const props2 = { answer: 42 }
const a2 = <div key="foo" {...props2}>text</div>;
const b2 = <div {...props2} key="bar">text</div>;

export {};
```

----------------------------------------

TITLE: Defining Nested Standard React Components (TypeScript)
DESCRIPTION: This snippet defines a `standardElement` using nested standard React components: a `Link` component wrapping a `Button` component. It illustrates how props like `href`, `passHref`, and `component` are used, demonstrating linked editing for common React patterns.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/linkedEditingJsxTag11.linkedEditing.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
const standardElement = \n   <[|/*2*/Link|] href="/hello" passHref>\n       <[|/*3*/Button|] component="a">\n           Next\n       </[|/*3*/Button|]>\n   </[|/*2*/Link]|]>
```

----------------------------------------

TITLE: Understanding Union with Unknown Type in TypeScript
DESCRIPTION: This snippet shows the behavior of the `unknown` type when used in union types (`|`) with other types. It highlights that `unknown` absorbs all other types in a union, making the resulting type `unknown`, except when united with `any` (which results in `any`).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownType1.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type T10 = unknown | null;  // unknown
type T11 = unknown | undefined;  // unknown
type T12 = unknown | null | undefined;  // unknown
type T13 = unknown | string;  // unknown
type T14 = unknown | string[];  // unknown
type T15 = unknown | unknown;  // unknown
type T16 = unknown | any;  // any
```

----------------------------------------

TITLE: Correct `super()` Call Order with Initialized Property in TypeScript
DESCRIPTION: Class `Derived5` correctly calls `super()` as the first statement in its constructor, even with an initialized property `a = 1;`. This ensures that the base class constructor is executed and `this` is properly initialized before any derived class property initialization or `this` access.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/derivedClassParameterProperties.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
class Derived5 extends Base {
    a = 1;
    constructor(y: string) {
        super();
        var b = 2;
    }
}
```

----------------------------------------

TITLE: Subfolder package.json Configuring CommonJS Type
DESCRIPTION: This `package.json` file, located in a subfolder, explicitly sets the module type to `"commonjs"`. This creates a mixed module environment within the project, leading to the TypeScript resolution errors observed when modules with different types attempt to import each other.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesSynchronousCallErrors(module=node18).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
        "type": "commonjs"
    }
```

----------------------------------------

TITLE: Preventing Static CommonJS Imports of ECMAScript Modules (TypeScript)
DESCRIPTION: These snippets demonstrate `TS1479` errors, which arise when a CommonJS module attempts to use static `import` syntax to reference an ECMAScript module. TypeScript flags this as an incompatibility, suggesting the use of dynamic `import()` calls instead, as static `import` in CommonJS context translates to `require`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node18).errors.txt#_snippet_9

LANGUAGE: TypeScript
CODE:
```
import * as m1 from "./index.js";
```

LANGUAGE: TypeScript
CODE:
```
import * as m2 from "./index.mjs";
```

LANGUAGE: TypeScript
CODE:
```
import * as m5 from "./subfolder/index.mjs";
```

LANGUAGE: TypeScript
CODE:
```
import * as m8 from "./subfolder2/index.mjs";
```

LANGUAGE: TypeScript
CODE:
```
import * as m10 from "./subfolder2/another/index.js";
```

LANGUAGE: TypeScript
CODE:
```
import * as m11 from "./subfolder2/another/index.mjs";
```

LANGUAGE: TypeScript
CODE:
```
import * as m13 from "./";
```

LANGUAGE: TypeScript
CODE:
```
import * as m14 from "./index";
```

----------------------------------------

TITLE: Demonstrating Type Parameter Assignability Errors in TypeScript
DESCRIPTION: This snippet illustrates TypeScript's strict type checking for generic functions. It shows that without explicit constraints, a type parameter 'U' cannot be assigned to 'T', nor can 'Object' be assigned to 'T', because 'T' could be an unrelated type. This highlights the importance of `extends` clauses for generic types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeParametersShouldNotBeEqual.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function ff<T, U>(x: T, y: U) {
    var z: Object;
    x = x;  // Ok
    x = y;  // Error
    x = z;  // Error
    z = x;  // Ok
}
```

----------------------------------------

TITLE: Importing ES Module in CommonJS TypeScript (.cts)
DESCRIPTION: This TypeScript file uses the .cts extension, explicitly marking it as a CommonJS module. When it attempts a static 'import' of an ECMAScript module (./module.mjs), it triggers TS1479. The error specifically advises using a dynamic 'import()' call instead for interoperability.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesCJSResolvingToESM1_emptyPackageJson.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
import {} from "./module.mjs";
```

----------------------------------------

TITLE: Package.json with Conditional Exports
DESCRIPTION: This `package.json` defines a package named `pkg` and uses the `exports` field to conditionally expose different entry points for `import` (ESM) and `require` (CommonJS) resolutions. This configuration is crucial for how modules are resolved in TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride4(module=node18).errors.txt#_snippet_1

LANGUAGE: json
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Using JSDoc `const` Assertion for Literal Types in TypeScript
DESCRIPTION: Illustrates the use of the `/** @type {const} */` JSDoc assertion to infer literal types. 'asConst1' will be inferred as '1' (literal number), and 'asConst2' will be inferred as '{ readonly x: 1 }' (a literal object with a readonly property), rather than 'number' or '{ x: number }'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsdocTypeTagCast.errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
var asConst1 = /** @type {const} */(1);
var asConst2 = /** @type {const} */({
    x: 1
});
```

----------------------------------------

TITLE: TypeScript Generic Function with Constrained Type Parameter Defaulting to Earlier Parameter
DESCRIPTION: This snippet illustrates a TypeScript function `f09` where a type parameter `U` has both a constraint (`U extends T`) and a default type that refers to an earlier type parameter `T`. It provides examples of type inference, partially supplied, and fully supplied type arguments.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/genericDefaults.errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
declare function f09<T, U extends T = T>(a?: T, b?: U): [T, U];
// inference
f09();
f09(a);
f09(a, a);
f09(a, ab);
// no inference, partially supplied
f09<A>();
f09<A>(a);
f09<A>(a, a);
f09<A>(a, ab);
// no inference, fully supplied
f09<A, AB>();
f09<A, AB>(a);
f09<A, AB>(a, ab);
```

----------------------------------------

TITLE: Assigning Functions with Explicit 'this' to Typed Variables - TypeScript
DESCRIPTION: This snippet shows how functions with explicit 'this' parameters can be assigned to variables with compatible function types. It demonstrates assigning `explicitStructural` to `ok.f` which expects `this: { y: number }`. It also shows assigning `implicitThis` to `implicitAnyOk.f`, where `implicitThis` has an implicit `any` 'this' type, which is compatible with a function type that doesn't specify 'this'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/thisTypeInFunctions.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
let ok: {y: number, f: (this: { y: number }, x: number) => number} = { y: 12, f: explicitStructural };
let implicitAnyOk: {notSpecified: number, f: (x: number) => number} = { notSpecified: 12, f: implicitThis };
ok.f(13);
implicitThis(12);
implicitAnyOk.f(12);
```

----------------------------------------

TITLE: Function Type Supertype Rules with `any`, `unknown`, and `never` in TypeScript
DESCRIPTION: This extensive snippet explores how function types with `any`, `unknown`, or `never` in their parameters or return types behave as supertypes. It defines a user-defined type guard `isFunction` and various function types (`A`, `B`, `C`, `D`) to demonstrate type narrowing behavior when these function types are used in conditional checks, illustrating which function types are considered supertypes of others.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/strictSubtypeAndNarrowing.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
declare function isFunction<T>(x: unknown): x is T;

type A = (...args: any) => unknown;
type B = (...args: any[]) => unknown;
type C = (...args: never) => unknown;
type D = (...args: never[]) => unknown;

type FnTypes = A | B | C | D;

function fx1(f: (() => void) | undefined) {
    if (isFunction<A>(f)) {
        f;  // () => void
    }
    else {
        f;  // undefined
    }
    f;  // (() => void) | undefined
}

function fx2(f: (() => void) | undefined) {
    if (isFunction<B>(f)) {
        f;  // () => void
    }
    else {
        f;  // undefined
    }
    f;  // (() => void) | undefined
}

function fx3(f: (() => void) | undefined) {
    if (isFunction<C>(f)) {
        f;  // () => void
    }
    else {
        f;  // undefined
    }
    f;  // (() => void) | undefined
}

function fx4(f: (() => void) | undefined) {
    if (isFunction<D>(f)) {
        f;  // () => void
    }
    else {
        f;  // undefined
    }
    f;  // (() => void) | undefined
}

function checkA(f: FnTypes) {
    if (isFunction<A>(f)) {
        f;  // A | B
    }
    else {
        f;  // C | D
    }
    f;  // FnTypes
}

function checkB(f: FnTypes) {
    if (isFunction<B>(f)) {
        f;  // A | B
    }
    else {
        f;  // C | D
    }
    f;  // FnTypes
}

function checkC(f: FnTypes) {
    if (isFunction<C>(f)) {
        f;  // FnTypes
    }
    else {
        f;  // never
    }
    f;  // FnTypes
}

function checkD(f: FnTypes) {
    if (isFunction<C>(f)) {
        f;  // FnTypes
    }
    else {
        f;  // never
    }
    f;  // FnTypes
}
```

----------------------------------------

TITLE: Merging Abstract Class with Interface in TypeScript
DESCRIPTION: This snippet illustrates a valid declaration merging scenario where an abstract class `CI` is merged with an interface `CI`. The interface can define members that the abstract class must implement or that can be implemented by its concrete subclasses.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/classAbstractMergedDeclaration.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
abstract class CI {}
interface CI {}
```

----------------------------------------

TITLE: ESM Import Resolution Failure (Missing Extension for Subfolder Directory) - TypeScript
DESCRIPTION: Highlights a TypeScript error (TS2834) when an ECMAScript `import` targets a directory (`./subfolder/`) without an explicit file extension. The `node16` or `nodenext` module resolution policy requires explicit extensions for relative paths in ECMAScript imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node16).errors.txt#_snippet_51

LANGUAGE: TypeScript
CODE:
```
import * as m16 from "./subfolder/";
```

----------------------------------------

TITLE: Importing Modules in TypeScript (TypeScript)
DESCRIPTION: This TypeScript snippet demonstrates importing 'foo' and 'bar' modules. Despite declaration files existing, TypeScript reports 'TS7016' errors because the 'package.json' 'exports' field prevents correct resolution of the declaration files under the specified module resolution settings.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/resolvesWithoutExportsDiagnostic1(moduleresolution=node16).errors.txt#_snippet_9

LANGUAGE: TypeScript
CODE:
```
import { foo } from "foo";
import { bar } from "bar";
```

----------------------------------------

TITLE: Dynamic `import()` with ECMAScript Module Resolution Errors in TypeScript
DESCRIPTION: This section shows dynamic `import()` calls, which strictly use the ECMAScript module (ESM) resolver. The ESM resolver does not perform automatic extension resolution or index resolution for relative paths, leading to `TS2307`, `TS2835`, and `TS2834` errors when explicit extensions are omitted. This highlights the stricter requirements of ESM imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=nodenext).errors.txt#_snippet_27

LANGUAGE: TypeScript
CODE:
```
const _m35 = import("./");
const _m36 = import("./index");
const _m37 = import("./subfolder");
const _m38 = import("./subfolder/");
const _m39 = import("./subfolder/index");
const _m40 = import("./subfolder2");
const _m41 = import("./subfolder2/");
const _m42 = import("./subfolder2/index");
const _m43 = import("./subfolder2/another");
const _m44 = import("./subfolder2/another/");
```

----------------------------------------

TITLE: Defining Final Type Structure for PubSub Record in TypeScript
DESCRIPTION: This conditional type defines the final structure of a PubSub record once all required fields (`identifier`, `record`, `maxMsToWaitBeforePublishing`, `storedAs`) are present. It provides the `type` itself, a `fields` Set of its keys, and a `hasField` utility method for checking field existence. If not all required fields are present, it returns an empty object type.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/conditionalTypeDoesntSpinForever.errors.txt#_snippet_9

LANGUAGE: TypeScript
CODE:
```
type TypeConstructor<SO_FAR> =
  SO_FAR extends {identifier: any, record: any, maxMsToWaitBeforePublishing: number, storedAs: PubSubRecordIsStoredInRedisAsA} ? {
    type: SO_FAR,
    fields: Set<keyof SO_FAR>,
    hasField: (fieldName: string | number | symbol) => fieldName is keyof SO_FAR
  } : {}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options for pkg3 (JSON)
DESCRIPTION: This snippet defines the TypeScript compiler options for the `pkg3` package. It specifies output and root directories, target ECMAScript version, module system, strict type checking, ES module interop, and declaration file generation. These settings are crucial for how TypeScript compiles the project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationEmitReexportedSymlinkReference3.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
    "compilerOptions": {
      "outDir": "dist",
      "rootDir": "src",
      "target": "es5",
      "module": "commonjs",
      "strict": true,
      "esModuleInterop": true,
      "declaration": true
    }
}
```

----------------------------------------

TITLE: Function with Implicit Any and Any Array Rest Parameters (TS7006, TS7019) in TypeScript
DESCRIPTION: This function `m_f7` shows a combination of implicit 'any' error for parameter 'x' (TS7006) and an implicit 'any[]' error for the rest parameter 'r' (TS7019). Both parameters lack explicit type annotations, leading to type inference issues.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyParametersInModule.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
function m_f7(x, ...r): void { }
```

----------------------------------------

TITLE: Exporting Initialized Variables and Instances in TypeScript
DESCRIPTION: This section illustrates the export of various initialized variables using 'var' and 'let', including primitive types, class instances, and typed class instances. These exports are correctly initialized and represent valid, common patterns for module exports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportNonInitializedVariablesSystem.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
export var a1 = 1;
export let b1 = 1;
export var c1: string = 'a';
export let d1: number = 1;
class D {}
export var e1 = new D;
export let f1 = new D;
export var g1: D = new D;
export let h1: D = new D;
```

----------------------------------------

TITLE: Declaring Redux Connect Function Type in TypeScript
DESCRIPTION: This snippet defines an overloaded type for the `connect` function, typically used in Redux. It specifies a signature where `mapStateToProps` is null or undefined, and `mapDispatchToProps` is provided. It uses `InferableComponentEnhancerWithProps` and `ResolveThunks` to infer component props, indicating a pattern for enhancing components with resolved dispatch properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/reactReduxLikeDeferredInferenceAllowsAssignment.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
declare const connect: {
  <no_state = {}, TDispatchProps = {}, TOwnProps = {}>(
    mapStateToProps: null | undefined,
    mapDispatchToProps: TDispatchProps
  ): InferableComponentEnhancerWithProps<
    ResolveThunks<TDispatchProps>,
    TOwnProps
  >;
};
```

----------------------------------------

TITLE: Type Narrowing with Comparison to a Union Literal Type in TypeScript
DESCRIPTION: Demonstrates type narrowing when comparing a discriminated union's `kind` property to another union of literal types. If `m.kind == x`, `m` is narrowed to the types whose `kind` property matches either "A" or "D", resulting in `{ kind: "A", x: string } | { kind: "D" }`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
function f4(m: Message, x: "A" | "D") {
    if (m.kind == x) {
        m;  // { kind: "A", x: string } | { kind: "D" }
    }
}
```

----------------------------------------

TITLE: ES Module Imports in TypeScript (.ts)
DESCRIPTION: This snippet demonstrates standard ES module imports within a `.ts` file, which is configured as an ES module. It imports modules aliased as `#cjs`, `#mjs`, and `#type`, which are resolved through the `imports` field in the `package.json`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackageImports(module=node16).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import * as cjs from "#cjs";
import * as mjs from "#mjs";
import * as type from "#type";
cjs;
mjs;
type;
```

----------------------------------------

TITLE: Returning a Specific Template Literal Type from a Function in TypeScript
DESCRIPTION: This function demonstrates returning a value with a specific template literal type. The return type annotation `test-${string}` ensures that the function always produces a string prefixed with 'test-', providing stronger type guarantees than a general `string`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes2.errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
function getCardTitle(title
```

----------------------------------------

TITLE: Defining Package Metadata for pkg1 (JSON)
DESCRIPTION: This JSON snippet defines the `package.json` metadata for `@raymondfeng/pkg1`. It specifies the package name, version, main entry point (`dist/index.js`), and the declaration file entry point (`dist/index.d.ts`), which is essential for TypeScript's type resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/declarationEmitReexportedSymlinkReference3.errors.txt#_snippet_5

LANGUAGE: JSON
CODE:
```
{
    "name": "@raymondfeng/pkg1",
    "version": "1.0.0",
    "description": "",
    "main": "dist/index.js",
    "typings": "dist/index.d.ts"
}
```

----------------------------------------

TITLE: TypeScript ESM Declaration File Example (.d.mts)
DESCRIPTION: An ES Module TypeScript declaration file (`.d.mts`) that correctly imports and re-exports modules for CJS, MJS, and JS formats, demonstrating the structure for ESM type definitions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackagePatternExports(module=node20).errors.txt#_snippet_4

LANGUAGE: typescript
CODE:
```
// esm format file
import * as cjs from "inner/cjs/index";
import * as mjs from "inner/mjs/index";
import * as type from "inner/js/index";
export { cjs };
export { mjs };
export { type };
```

----------------------------------------

TITLE: Implementing an Exhaustive Check Helper Function in TypeScript
DESCRIPTION: Defines a helper function `assertNever` that takes a `never` type and throws an error. This function is used to ensure exhaustive checks in `switch` statements, guaranteeing that all possible cases of a union type are handled. If a case is missed, `x` would not be `never`, leading to a compile-time error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
```

----------------------------------------

TITLE: Using `export * as` in ES Modules (JavaScript)
DESCRIPTION: This JavaScript snippet demonstrates the `export * as` syntax for namespace re-exports in an ES Module environment. This syntax is natively supported by modern JavaScript runtimes when operating in ES module mode, eliminating the need for external helper libraries like `tslib`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions2(module=node18).errors.txt#_snippet_3

LANGUAGE: JavaScript
CODE:
```
export * as fs from "fs";
```

----------------------------------------

TITLE: Declaring an Array of Union Types in TypeScript
DESCRIPTION: These snippets illustrate two equivalent syntaxes for declaring an array where each element is a union type. Each element within `arrayOfUnions` can be either a `string` or a `number`, providing flexibility for heterogeneous array content.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unionTypeLiterals.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
var arrayOfUnions: (string | number)[];
```

LANGUAGE: TypeScript
CODE:
```
var arrayOfUnions: Array<string | number>;
```

----------------------------------------

TITLE: `await using` in an Asynchronous Function
DESCRIPTION: Illustrates the application of `await using` within a standard asynchronous function. This pattern ensures proper disposal of resources when the function completes.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarations.1(target=es2015).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
async function af() {
    await using d3 = { async [Symbol.asyncDispose]() {} };
    await null;
}
```

----------------------------------------

TITLE: Defining a Generic Interface in TypeScript
DESCRIPTION: This snippet defines a generic interface `IFoo<T>` with a single method `foo` that takes and returns a value of the generic type `T`. This interface acts as a contract for classes that implement it, ensuring type safety based on the generic parameter.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/genericSpecializations3.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
interface IFoo<T> {
    foo(x: T): T;
}
```

----------------------------------------

TITLE: Defining TypeScript Interfaces for Nested Properties
DESCRIPTION: Defines two interfaces, `IProps` and `INestedProps`, used to structure data with optional string and boolean properties, including a nested object. These interfaces serve as the foundational type definitions for subsequent excess property checks.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nonObjectUnionNestedExcessPropertyCheck.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
interface IProps {
        iconProp?: string;
        nestedProp?: {
            testBool?: boolean;
        }
    }
    
    interface INestedProps {
        nestedProps?: IProps;
    }
```

----------------------------------------

TITLE: Updating Object State with setState Function in TypeScript
DESCRIPTION: This `setState` function provides a generic way to update properties of an object `obj` with values from `props`. It iterates over the keys in `props` and assigns the corresponding values to `obj`. The examples demonstrate valid updates and type errors when attempting to assign `undefined` to a non-optional string property or adding unknown properties, highlighting TypeScript's type safety with `Pick<T, K>`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeErrors.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
function setState<T, K extends keyof T>(obj: T, props: Pick<T, K>) {
    for (let k in props) {
        obj[k] = props[k];
    }
}

let foo: Foo = { a: "hello", b: 42 };
setState(foo, { a: "test", b: 43 })
setState(foo, { a: "hi" });
setState(foo, { b: undefined });
setState(foo, { });
setState(foo, foo);
setState(foo, { a: undefined });  // Error
// Type 'undefined' is not assignable to type 'string'.
// The expected type comes from property 'a' which is declared here on type 'Pick<Foo, "a">'.
setState(foo, { c: true });  // Error
// Object literal may only specify known properties, and 'c' does not exist in type 'Pick<Foo, keyof Foo>'.

```

----------------------------------------

TITLE: Calculating Area with Discriminated Union and Exhaustive Switch in TypeScript
DESCRIPTION: This snippet defines a discriminated union `Shape` using a `kind` property and demonstrates an exhaustive `switch` statement to calculate the area based on the specific shape type. TypeScript's type narrowing within each `case` allows safe access to shape-specific properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exhaustiveSwitchStatements1.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
interface Square { kind: "square"; size: number; }

interface Rectangle { kind: "rectangle"; width: number; height: number; }

interface Circle { kind: "circle"; radius: number; }

interface Triangle { kind: "triangle"; side: number; }

type Shape = Square | Rectangle | Circle | Triangle;

function area(s: Shape): number {
    let area;
    switch (s.kind) {
        case "square": area = s.size * s.size; break;
        case "rectangle": area = s.width * s.height; break;
        case "circle": area = Math.PI * s.radius * s.radius; break;
        case "triangle": area = Math.sqrt(3) / 4 * s.side * s.side; break;
    }
    return area;
}
```

----------------------------------------

TITLE: Using Readonly Utility Type with Interface (Bar) in TypeScript
DESCRIPTION: This snippet applies the `Readonly<T>` utility type to `Bar`, making all its properties (`a` and `b`) immutable. It shows that attempts to assign new values to either `a` or `b` result in TypeScript errors, confirming their read-only status.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypes6.errors.txt#_snippet_25

LANGUAGE: TypeScript
CODE:
```
declare let x4: Readonly<Bar>;
x4.a = 1;  // Error
x4.b = 1;  // Error
```

----------------------------------------

TITLE: Importing ES Module in CommonJS JavaScript (.js)
DESCRIPTION: Similar to the .ts example, this JavaScript file (.js) is treated as a CommonJS module. It fails to statically import an ECMAScript module (./module.mjs) with TS1479. The recommended solutions are to change the file extension to .mjs or set "type": "module" in package.json.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesCJSResolvingToESM1_emptyPackageJson.errors.txt#_snippet_3

LANGUAGE: JavaScript
CODE:
```
import {} from "./module.mjs";
```

----------------------------------------

TITLE: Using String.prototype.padStart in TypeScript (ES2017)
DESCRIPTION: This snippet illustrates a TypeScript TS2550 error when using `String.prototype.padStart` without the `lib` compiler option set to 'es2017' or later. The error signifies that the 'padStart' property is not available on string types in the current library target. To fix this, adjust the 'lib' compiler option in `tsconfig.json`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/doYouNeedToChangeYourTargetLibraryES2016Plus.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
const testStringPadStart = "".padStart(2);
```

----------------------------------------

TITLE: Iterating with For...Of and Nested Object Destructuring in TypeScript
DESCRIPTION: This snippet demonstrates how to iterate over an array of `MultiRobot` objects using a `for...of` loop. It showcases advanced object destructuring to extract `name`, `primary` skill, and `secondary` skill properties, providing default values for each. The `name` property is aliased to `nameA`, and nested `skills` properties are also destructured and aliased.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_60

LANGUAGE: TypeScript
CODE:
```
for (let {
    name: nameA = "noName",
    skills: {
        primary: primaryA = "primary",
        secondary: secondaryA = "secondary"
    } = { primary: "noSkill", secondary: "noSkill" }
} of <MultiRobot[]>[{ name: "mower", skills: { primary: "mowing", secondary: "none" } },
    { name: "trimmer", skills: { primary: "trimming", secondary: "edging" } }]) {
    console.log(nameA);
}
```

----------------------------------------

TITLE: APIDOC: Function Decorators and Control Flow Functions
DESCRIPTION: API documentation for functions that decorate or control the execution of other functions. This includes memoization, delayed execution, throttling, debouncing, one-time execution, and function composition.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/underscoreTest1.errors.txt#_snippet_69

LANGUAGE: APIDOC
CODE:
```
memoize<T extends Function>(func: T, hashFunction?: Function): T;
```

LANGUAGE: APIDOC
CODE:
```
delay(func: Function, wait: number, ...args: any[]): number;
```

LANGUAGE: APIDOC
CODE:
```
defer(func: Function, ...args: any[]): number;
```

LANGUAGE: APIDOC
CODE:
```
throttle<T extends Function>(func: T, wait: number): T;
```

LANGUAGE: APIDOC
CODE:
```
debounce<T extends Function>(func: T, wait: number, immediate?: boolean): T;
```

LANGUAGE: APIDOC
CODE:
```
once<T extends Function>(func: T): T;
```

LANGUAGE: APIDOC
CODE:
```
after<T extends Function>(count: number, func: T): T;
```

LANGUAGE: APIDOC
CODE:
```
wrap<T extends Function>(func: T, wrapper: (func: T, ...args: any[]) => any): T;
```

LANGUAGE: APIDOC
CODE:
```
compose(...funcs: Function[]): Function;
```

----------------------------------------

TITLE: Resolving Multiple Root JSX Elements and Missing React Scope (TypeScript)
DESCRIPTION: This TypeScript snippet illustrates two common JSX errors: TS2657 and TS2874. The TS2657 error arises because the expression attempts to assign multiple root JSX elements (<div></div><div></div>) to a variable without a single wrapping parent. The TS2874 error indicates that 'React' is not in scope, which is required for JSX compilation. Both issues must be addressed for valid JSX.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxErrorRecovery3.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
var x = <div></div><div></div>
```

----------------------------------------

TITLE: Configuring Node.js Module Type and Exports in package.json
DESCRIPTION: This `package.json` file configures the 'foo' package as a Node.js module by setting `"type": "module"`. It also defines an `exports` map, directing module imports to `index.d.ts`, which is crucial for how Node.js resolves imports for this package.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeNextModuleResolution2.errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
        "name": "foo",
        "type": "module",
        "exports": {
            ".": "./index.d.ts"
        }
    }
```

----------------------------------------

TITLE: ES6+ Object Destructuring with Renaming and Default Values - JavaScript
DESCRIPTION: This snippet demonstrates modern JavaScript (ES6+) object destructuring. It renames the 'name' property to 'nameC' and 'skill' to 'skillC', providing default values ('<NoName>', '<skillUnspecified>') that are used if the corresponding property is missing or 'undefined' in the source object.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementDefaultValues.sourcemap.txt#_snippet_7

LANGUAGE: JavaScript
CODE:
```
var { name: nameC = "<NoName>", skill: skillC = "<skillUnspecified>" } = { name: "Edger", skill: "cutting edges" };
```

----------------------------------------

TITLE: Checking for Case-Insensitive String Containment in JavaScript Array
DESCRIPTION: This function checks if an array contains a specific string, performing a case-insensitive comparison. It iterates through the array, converting each element and the target value to lowercase before comparison. It returns `true` if a match is found, `false` otherwise.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/fixSignatureCaching.errors.txt#_snippet_19

LANGUAGE: JavaScript
CODE:
```
function containsIC(array, value) {
    var valueLC, i, len = array.length;
    if (!len || !value) {
        return false;
    }
    valueLC = value.toLowerCase();
    for (i = 0; i < len; ++i) {
        if (valueLC === array[i].toLowerCase()) {
            return true;
        }
    }
    return false;
}
```

----------------------------------------

TITLE: Declaring Overloaded Promise Functions by Type in TypeScript
DESCRIPTION: This section illustrates function overloading based on the type of the input parameter. It shows how a single function name can have multiple declarations, each handling different input types and returning a corresponding `IPromise` or `Promise` type.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/promisePermutations.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
declare function testFunction11(x: number): IPromise<number>;
declare function testFunction11(x: string): IPromise<string>;
declare function testFunction11P(x: number): Promise<number>;
declare function testFunction11P(x: string): Promise<string>;
```

----------------------------------------

TITLE: Type Narrowing with Aliased Boolean Condition in TypeScript
DESCRIPTION: This snippet shows that type narrowing remains effective even when the combined success condition is stored in an aliased `const` boolean variable. If `areSuccess` is true, TypeScript correctly narrows the types of `data1`, `data2`, and `data3`, allowing their methods to be called without error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/controlFlowAliasedDiscriminants.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
const areSuccess = isSuccess1 && isSuccess2 && isSuccess3;
if (areSuccess) {
    data1.toExponential();  // should ok
    data2.toExponential();  // should ok
    data3.toExponential();  // should ok
}
```

----------------------------------------

TITLE: Iterating with Destructuring and Default Values in TypeScript
DESCRIPTION: This snippet demonstrates a 'for...of' loop in TypeScript that iterates over an array named 'robots'. It utilizes object destructuring to extract 'name' and 'skill' properties, aliasing them to 'nameA' and 'skillA' respectively, and provides default string values if the properties are undefined. The emitted JavaScript shows the transpiled equivalent using a traditional 'for' loop.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_36

LANGUAGE: TypeScript
CODE:
```
for (let {name: nameA = "noName", skill: skillA = "noSkill" } of robots) {
```

LANGUAGE: JavaScript
CODE:
```
for (var _0 = 0, robots_2 = robots; _0 < robots_2.length; _0++) {
```

----------------------------------------

TITLE: TypeScript Relative Import Path Error (TS2834)
DESCRIPTION: This snippet demonstrates a TypeScript TS2834 error, indicating that relative import paths require explicit file extensions when 'moduleResolution' is set to 'node16' or 'nodenext'. It highlights the need to specify .js, .mjs, or .cjs extensions for imported modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=nodenext).errors.txt#_snippet_36

LANGUAGE: TypeScript
CODE:
```
const _m45 = import("./subfolder2/another/index");
```

----------------------------------------

TITLE: Type Inference with Strict Optional Properties and Partial Types in TypeScript
DESCRIPTION: This comprehensive snippet demonstrates how TypeScript infers types when working with strict optional properties in objects and tuples, and with utility types like 'Partial<T>'. It shows the inferred return types of generic functions ('f11', 'f12', 'f13') when passed various object and tuple types, highlighting how 'undefined' is handled in inference.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/strictOptionalProperties1.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
declare let ox1: { p: string };
declare let ox2: { p: string | undefined };
declare let ox3: { p?: string };
declare let ox4: { p?: string | undefined };

declare let tx1: [string];
declare let tx2: [string | undefined];
declare let tx3: [string?];
declare let tx4: [(string | undefined)?];

declare function f11<T>(x: { p?: T }): T;

f11(ox1);  // string
f11(ox2);  // string | undefined
f11(ox3);  // string
f11(ox4);  // string | undefined

declare function f12<T>(x: [T?]): T;

f12(tx1);  // string
f12(tx2);  // string | undefined
f12(tx3);  // string
f12(tx4);  // string | undefined

declare function f13<T>(x: Partial<T>): T;

f13(ox1);  // { p: string }
f13(ox2);  // { p: string | undefined }
f13(ox3);  // { p: string }
f13(ox4);  // { p: string | undefined }

f13(tx1);  // [string]
f13(tx2);  // [string | undefined]
f13(tx3);  // [string]
f13(tx4);  // [string | undefined]
```

----------------------------------------

TITLE: Applying Recursive Transformation to Object Properties in TypeScript
DESCRIPTION: The 'Transform<T>' type recursively applies itself to all properties of an object 'T'. This example shows how it transforms an interface 'Product' containing an array of union types, resulting in a type where each element of the 'users' array is also recursively transformed.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/recursiveMappedTypes.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
type Transform<T> = { [K in keyof T]: Transform<T[K]> };

interface User {
    avatar: string;
}

interface Guest {
    displayName: string;
}

interface Product {
    users: (User | Guest)[];
}

declare var product: Transform<Product>;
product.users;  // (Transform<User> | Transform<Guest>)[]
```

----------------------------------------

TITLE: Iterating with Object Destructuring and Default Values in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates a `for...of` loop iterating over an iterable returned by `getRobots()`. It uses object destructuring to extract `name` and `skill` properties, assigning default values ('noName', 'noSkill') if the properties are undefined. This pattern simplifies data extraction from iterated objects.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_40

LANGUAGE: TypeScript
CODE:
```
for (let {name: nameA = "noName", skill: skillA = "noSkill"  } of getRobots()) {
}
```

----------------------------------------

TITLE: Piping Array Operations to Extract First Element in TypeScript
DESCRIPTION: This snippet illustrates various ways to use `pipe` to retrieve an array and then extract its first element. It shows different forms of intermediate identity transformations (`x => x`, `identity`, `x => first(x)`) within the pipeline, demonstrating flexibility in function composition while maintaining correct type inference for array processing.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/genericFunctionInference1.errors.txt#_snippet_19

LANGUAGE: TypeScript
CODE:
```
declare const getArray: () => string[];
declare const first: <T>(ts: T[]) => T;

const fn60 = pipe(
    getArray,
    x => x,
    first,
);

const fn61 = pipe(
    getArray,
    identity,
    first,
);

const fn62 = pipe(
    getArray,
    x => x,
    x => first(x),
);
```

----------------------------------------

TITLE: Handling Mapped Types with Template Literal Key Constraints in TypeScript
DESCRIPTION: This snippet defines `Mapped4` where keys are constrained to start with an underscore (`_`). The function `f4` demonstrates accessing properties of `Mapped4` and assigning them to a type ``_${string}``, showing correct type flow when the key constraint is maintained.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeConstraints2.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
type Mapped4<K extends `_${string}`> = {
  [P in K]: P;
};

function f4<K extends `_${string}`>(obj: Mapped4<K>, key: keyof Mapped4<K>) {
  let s: `_${string}` = obj[key];
}
```

----------------------------------------

TITLE: TypeScript Mapped Type Inference with Readonly and Partial
DESCRIPTION: This snippet illustrates how TypeScript performs type inference when dealing with `Readonly<T>` and `Partial<T>` mapped types. It shows that the `primary` argument dictates the inferred type `T`, and the `secondary` argument (a mapped type of `T`) must conform to that inferred type, leading to errors if properties are missing (for `Readonly`) or extra properties are present (for both `Readonly` and `Partial`).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeErrors.errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
declare function objAndReadonly<T>(primary: T, secondary: Readonly<T>): T;
declare function objAndPartial<T>(primary: T, secondary: Partial<T>): T;
    
function f20() {
    let x1 = objAndReadonly({ x: 0, y: 0 }, { x: 1 });  // Error
    let x2 = objAndReadonly({ x: 0, y: 0 }, { x: 1, y: 1 });
    let x3 = objAndReadonly({ x: 0, y: 0 }, { x: 1, y: 1, z: 1 });  // Error
}
    
function f21() {
    let x1 = objAndPartial({ x: 0, y: 0 }, { x: 1 });
    let x2 = objAndPartial({ x: 0, y: 0 }, { x: 1, y: 1 });
    let x3 = objAndPartial({ x: 0, y: 0 }, { x: 1, y: 1, z: 1 });  // Error
}
```

----------------------------------------

TITLE: Numeric Indexed Access Unaffected by noUncheckedIndexedAccess in TypeScript
DESCRIPTION: This snippet demonstrates that the `noUncheckedIndexedAccess` compiler option specifically targets string-indexed access and does not affect numeric-indexed access. A `numMap` with a numeric index signature can be accessed directly, and the result is correctly inferred as `boolean` without `undefined`, thus no errors occur.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noUncheckedIndexedAccess.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
declare const numMap: { [s: number]: boolean };
const num_ok1: boolean = numMap[0];
```

----------------------------------------

TITLE: Importing ES Module in Standard TypeScript (.ts)
DESCRIPTION: This snippet demonstrates a valid import of an ECMAScript module in a standard TypeScript file. When 'type': 'module' is set in package.json, or with appropriate tsconfig settings, .ts files can be treated as ES modules, allowing direct ES module imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodePackageSelfNameScoped(module=node16).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// esm format file
import * as self from "@scope/package";
self;
```

----------------------------------------

TITLE: ES Module Export Syntax - TypeScript
DESCRIPTION: This snippet shows standard ES Module export syntax in a TypeScript file. Unlike the CommonJS example, this code compiles without errors, demonstrating correct module export patterns for ES Modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportHelpersCollisions3(module=nodenext).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export {default} from "fs";
export {default as foo} from "fs";
export {bar as baz} from "fs";
```

----------------------------------------

TITLE: Incorrect 'class' Attribute on Custom React Component (JSX)
DESCRIPTION: This snippet demonstrates TypeScript errors (TS2769) when a custom React component, `MyComp`, is invoked with the 'class' attribute instead of 'className'. The errors indicate that no overload matches the call and that 'class' does not exist on the component's props, suggesting 'className' as the correct prop. This emphasizes the need for custom components to define their props using React's conventions.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/spellingSuggestionJSXAttribute.errors.txt#_snippet_4

LANGUAGE: jsx
CODE:
```
<MyComp class="" />;
```

----------------------------------------

TITLE: Defining Function with Single JSDoc Type Literal for Object Destructuring (Good)
DESCRIPTION: This example shows the correct JSDoc for a function that takes only a single object destructuring parameter. The JSDoc type literal accurately describes the structure and types of the destructured properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsdocParamTag2.errors.txt#_snippet_3

LANGUAGE: JavaScript
CODE:
```
/**
 * @param {{a: string, b: string}} obj
 */
function good4({a, b}) {}
```

----------------------------------------

TITLE: Defining and Calling TypeScript Function with Optional Parameters
DESCRIPTION: This snippet defines a TypeScript function `foo` with a required string parameter `a` and an optional number parameter `b`. It includes examples of correct calls and an incorrect call `foo()` that triggers a `TS2554` error for missing required arguments.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/functionCall11.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function foo(a:string, b?:number){}
foo('foo', 1);
foo('foo');
foo();
```

----------------------------------------

TITLE: Nested `for` loop with `let` variable capture in TypeScript
DESCRIPTION: This snippet features a nested `for` loop structure. An outer `for` loop declares `y`, and an inner `let` variable `x` is initialized to `1` within the loop body. The variable `x` is captured by inner functions, and the `if` conditions demonstrate `break` and `continue` statements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/capturedLetConstInLoop6.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
for (let y = 0; y < 1; ++y) {
    let x = 1;
    (function() { return x});
    (() => x);
    if (x == 1) {
        break;
    }
    if (x == 2) {
        continue;
    }
}
```

----------------------------------------

TITLE: package.json Configuration for ES Module Type
DESCRIPTION: This `package.json` configuration sets the project's default module type to 'module' (ES Module). This enables top-level 'await' in TypeScript files within the project.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTopLevelAwait(module=node20).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: NPM Package Exports Configuration (`pkg/package.json`)
DESCRIPTION: Defines the `package.json` for the `pkg` module, specifying `exports` for `import` and `require` conditions. This configuration dictates how different module systems resolve imports from this package, pointing to separate declaration files.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportAttributesModeDeclarationEmit2(module=node20).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Using Type Parameter as Value in TypeScript
DESCRIPTION: This snippet shows a generic TypeScript function `f2` that attempts to return the type parameter `T` itself as a value. The TypeScript compiler generates error TS2693 because `T` is a type parameter, used for type checking at compile-time, and cannot be used as a runtime value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/returnTypeParameter.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function f2<T>(a: T): T { return T; } // bug was that this satisfied the return statement requirement
```

----------------------------------------

TITLE: Narrowing with 'in' Operator for Union with 'undefined' Property in TypeScript
DESCRIPTION: This function demonstrates the 'in' operator with a property that can be 'string' or 'undefined'. The 'in' operator only checks for property existence, not its value. Therefore, if 'a' is in 'x', it means the property 'a' exists, regardless of whether its value is 'string' or 'undefined'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/inKeywordTypeguard(strict=false).errors.txt#_snippet_19

LANGUAGE: TypeScript
CODE:
```
function f14(x: { a: string | undefined }) {
    if ("a" in x) {
        x;
    }
    else {
        x;
    }
}
```

----------------------------------------

TITLE: Exporting All from Missing Module 'bar' in TypeScript
DESCRIPTION: This snippet demonstrates a TypeScript TS2792 error when attempting to re-export all members from a non-existent module 'bar' using `export * from 'bar'`. The error suggests configuring `moduleResolution` to 'nodenext' or adding aliases to the `paths` option in `tsconfig.json` to resolve the module.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/systemModule11.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export var x;
export function foo() {}
export * from 'bar';
```

----------------------------------------

TITLE: Root package.json for ES Module Configuration - JSON
DESCRIPTION: This `package.json` file configures the root directory as an ES module (`"type": "module"`). This setting dictates how JavaScript files in this directory (unless overridden by a subfolder's `package.json`) are interpreted, allowing the use of `import.meta.url`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsImportMeta(module=node16).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Generic Class: Multiple Errors with `this` Access Before `super()` in TypeScript
DESCRIPTION: This generic class `Derived9<T>` mirrors the issues in `Derived7`, demonstrating that the rules for `super()` calls and `this` access apply equally to generic derived classes. `TS2376` occurs because `super()` is not the first statement, and `TS17009` is triggered by accessing `this.a` and `this.b` before `super()`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/derivedClassParameterProperties.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
class Base2<T> { x: T; }

class Derived9<T> extends Base2<T> {
    a = 1;
    b: number;
    constructor(y: string) {
    // error TS2376: A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers.
        this.a = 3;
        // error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.
        this.b = 3;
        // error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.
        super();
    }
}
```

----------------------------------------

TITLE: Handling Incomplete Switch Statement Return Types in Standalone TypeScript Functions
DESCRIPTION: This snippet illustrates the same TS2322 error as in class properties, but for a standalone function assigned to a `const` variable typed as `FuncType`. The error arises because the `switch` statement lacks a `case` for `6`, causing the function to implicitly return `undefined` for that input, violating the `string` return type expectation under `strictNullChecks`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/classPropertyErrorOnNameOnly.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type Values = 1 | 2 | 3 | 4 | 5 | 6

type FuncType = (arg: Values) => string

const outsideClass: FuncType = function(val) { // compare to errors only on this line in this case
    switch (val) {
      case 1:
        return "1";
      case 2:
        return "2";
      case 3:
        return "3"
      case 4:
        return "4"
      case 5:
        return "5"
      // forgot case 6
    }
}
```

----------------------------------------

TITLE: JavaScript Object Destructuring Assignment
DESCRIPTION: This snippet shows a complex JavaScript destructuring assignment. It extracts `nameC` from the `name` property and `primaryB` and `secondaryB` from nested `skills` properties of an object literal. This pattern is commonly used for concise variable extraction from structured data.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementNestedObjectBindingPattern.sourcemap.txt#_snippet_6

LANGUAGE: JavaScript
CODE:
```
var { name: nameC, skills: { primary: primaryB, secondary: secondaryB } } = { name: "Edger", skills: { primary: "edging", secondary: "branch trimming" } };
```

----------------------------------------

TITLE: Inferring Intersection of Generic Call Signatures in TypeScript
DESCRIPTION: This example demonstrates type inference for an intersection type of two generic call signatures. When a type argument is applied, it is propagated to both generic signatures within the intersection, resulting in an intersection of specific function types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/instantiationExpressions.errors.txt#_snippet_18

LANGUAGE: TypeScript
CODE:
```
function f20(f: (<T>(a: T) => T) & (<U>(a: U, b: number) => U[])) {
    let fs = f<string>;  // ((a: string) => string) & ((a: string, b: number) => string[]])
}
```

----------------------------------------

TITLE: `while` Loop with Multiple `let` Variables and Closures in TypeScript
DESCRIPTION: This snippet demonstrates a `while` loop where multiple `let` variables (`x` and `y`) are declared within the loop body. It illustrates how these variables are captured by closures (function expression and arrow function) in each iteration, emphasizing `let`'s per-iteration scoping. The loop includes `break` and `continue` statements, both regular and labeled, for flow control.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/capturedLetConstInLoop7_ES6.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
l6:
while (1 === 1) {
    let x, y;
    (function() { return x + y});
    (() => x + y);
    if (x == 1) {
        break;
    }
    if (x == 1) {
        break l6;
    }
    if (x == 2) {
        continue;
    }
    if (x == 2) {
        continue l6;
    }

}
```

----------------------------------------

TITLE: Iterating with Nested Object Destructuring and Default Values in TypeScript
DESCRIPTION: This snippet demonstrates how to use a `for...of` loop to iterate over an array of `MultiRobot` objects. It features nested object destructuring to extract `primary` and `secondary` skills, along with default values for individual properties (`primaryA`, `secondaryA`) and for the entire `skills` object if it's missing. The loop processes each robot, making its skills available through aliased variables.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_27

LANGUAGE: TypeScript
CODE:
```
for (let { skills: { primary: primaryA = "primary", secondary: secondaryA = "secondary" } =
    { primary: "nosKill", secondary: "noSkill" } } of
     <MultiRobot[]>[{ name: "mower", skills: { primary: "mowing", secondary: "none" } },
         { name: "trimmer", skills: { primary: "trimming", secondary: "edging" } }])
```

----------------------------------------

TITLE: Handling Discriminated Union in Callback Parameters (f50)
DESCRIPTION: Illustrates how TypeScript handles discriminated unions within callback function arguments. The type of `data` is correctly narrowed based on the `kind` parameter, allowing specific methods like `toFixed()` or `toUpperCase()` to be called.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/dependentDestructuredVariables.errors.txt#_snippet_20

LANGUAGE: TypeScript
CODE:
```
declare function f50(cb: (...args: Args) => void): void

f50((kind, data) => {
    if (kind === 'A') {
        data.toFixed();
    }
    if (kind === 'B') {
        data.toUpperCase();
    }
});
```

----------------------------------------

TITLE: Incorrect Type-Only Import of ESM in CommonJS (TS1541)
DESCRIPTION: This code demonstrates an incorrect type-only import of an ECMAScript module (`.mts`) from a CommonJS module (`.cts`). It triggers TypeScript error TS1541 because the `resolution-mode` attribute is missing, which is required to clarify how the module should be resolved.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeOnlyESMImportFromCJS(module=node18).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import type {} from "./module.mts";
```

----------------------------------------

TITLE: Accessing Property Type with Indexed Access in TypeScript
DESCRIPTION: This snippet uses indexed access to extract the type of the 'name' property from the 'Shape' class. It correctly resolves to 'string', demonstrating a valid and common use case of TypeScript's indexed access types for precise type inference.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccessErrors.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
type T10 = Shape["name"];
```

----------------------------------------

TITLE: Importing Types and Values in TypeScript
DESCRIPTION: This snippet demonstrates importing a type-only declaration using `import type` and separate value imports from the same module. This pattern helps in distinguishing between type and value dependencies, especially with `verbatimModuleSyntax` enabled, ensuring type imports are erased at compile time.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/preserveValueImports(isolatedmodules=false).errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
import type a from "./a";
import { b, c } from "./a";
b;
```

----------------------------------------

TITLE: TypeScript Dynamic Import Usage Causing TS1323 Error
DESCRIPTION: Examples of dynamic `import()` expressions in TypeScript that result in the TS1323 error. This error indicates that the current `--module` compiler setting does not support dynamic imports. To resolve this, the module flag must be set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', 'node18', 'node20', or 'nodenext'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/importCallExpressionErrorInES2015.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import("./0");
var p1 = import("./0");
p1.then(zero => {
    return zero.foo();
})

function foo() {
    const p2 = import("./0");
}
```

----------------------------------------

TITLE: NPM package.json Configuration for 'package' with Exports
DESCRIPTION: This `package.json` defines the `package` module, setting its `type` to `module` and specifying `exports` for CJS, MJS, and default entry points. This configuration dictates how different module consumers resolve imports from this package.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackageExports(module=node20).errors.txt#_snippet_5

LANGUAGE: JSON
CODE:
```
{
        "name": "package",
        "private": true,
        "type": "module",
        "exports": {
            "./cjs": "./index.cjs",
            "./mjs": "./index.mjs",
            ".": "./index.js"
        }
    }
```

----------------------------------------

TITLE: Importing ES Module with `import * as` in CommonJS - TypeScript
DESCRIPTION: This snippet demonstrates TypeScript error TS1479, which occurs when a CommonJS module uses the `import * as` syntax to import a module that resolves to an ECMAScript module. TypeScript converts this import to a `require` call, which is incompatible with ES modules. The suggested resolution is to use a dynamic `import()` call.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node18).errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
import * as m12 from "./subfolder2/another/index.cjs";
```

LANGUAGE: TypeScript
CODE:
```
import * as m13 from "./";
```

LANGUAGE: TypeScript
CODE:
```
import * as m14 from "./index";
```

LANGUAGE: TypeScript
CODE:
```
import * as m15 from "./subfolder";
import * as m16 from "./subfolder/";
import * as m17 from "./subfolder/index";
import * as m18 from "./subfolder2";
import * as m19 from "./subfolder2/";
import * as m20 from "./subfolder2/index";
import * as m21 from "./subfolder2/another";
```

LANGUAGE: TypeScript
CODE:
```
import * as m22 from "./subfolder2/another/";
```

LANGUAGE: TypeScript
CODE:
```
import * as m23 from "./subfolder2/another/index";
```

----------------------------------------

TITLE: Defining Interfaces, Classes, Functions, and Modules in TypeScript
DESCRIPTION: This snippet defines various TypeScript constructs including an interface `I`, classes `C` and `C2` (with inheritance), a generic class `D`, and functions `F` and `F2`. It also includes modules `M` and `N` with their own classes and functions, providing a comprehensive set of type definitions for the file.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/ifDoWhileStatements.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
interface I {
    id: number;
}

class C implements I {
    id: number;
    name: string;
}

class C2 extends C {
    valid: boolean;
}

class D<T>{
    source: T;
    recurse: D<T>;
    wrapped: D<D<T>>
}

function F(x: string): number { return 42; }
function F2(x: number): boolean { return x < 42; }

module M {
    export class A {
        name: string;
    }

    export function F2(x: number): string { return x.toString(); }
}

module N {
    export class A {
        id: number;
    }

    export function F2(x: number): string { return x.toString(); }
}
```

----------------------------------------

TITLE: Demonstrating TS2322 Type Error in TypeScript
DESCRIPTION: This snippet illustrates a common TypeScript type error (TS2322) where a variable initially declared as a string is later reassigned a number value. The `@ts-check` directive enables type checking in a JavaScript file, highlighting the type incompatibility.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/checkJsFiles3.errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
// @ts-check
var x = "string";
x = 0;
```

----------------------------------------

TITLE: Implementing Discriminated Unions with Template Literal Types in TypeScript
DESCRIPTION: Shows how template literal types can be used as discriminants in union types, allowing TypeScript to correctly narrow down the type of an object based on a pattern in its string literal property.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes3.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
type Action =
    | { type: `${string}_REQUEST` }
    | { type: `${string}_SUCCESS`, response: string };
function reducer(action: Action) {
    if (action.type === 'FOO_SUCCESS') {
        action.type;
        action.response;
    }
}
```

----------------------------------------

TITLE: CJS Module Imports in index.cjs
DESCRIPTION: Shows importing CommonJS (cjs), ES Module (mjs), and default exports from 'package' and 'inner' modules within a CommonJS formatted JavaScript file (`.cjs`). This file explicitly uses the CJS format, overriding any `package.json` 'type' field for its scope.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageExports(module=node20).errors.txt#_snippet_2

LANGUAGE: javascript
CODE:
```
// cjs format file
import * as cjs from "package/cjs";
import * as mjs from "package/mjs";
import * as type from "package";
cjs;
mjs;
type;
import * as cjsi from "inner/cjs";
import * as mjsi from "inner/mjs";
import * as typei from "inner";
cjsi;
mjsi;
typei;
```

----------------------------------------

TITLE: Node.js Package Exports Configuration
DESCRIPTION: Illustrates a `package.json` file defining conditional exports for 'import' and 'require' resolution modes. This configuration is crucial for modern Node.js module resolution, enabling interoperability between different module systems and ensuring that the correct entry points are used based on the consumer's module context.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportModeDeclarationEmit1(module=node16).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
    {
        "name": "pkg",
        "version": "0.0.1",
        "exports": {
            "import": "./import.js",
            "require": "./require.js"
        }
    }
```

----------------------------------------

TITLE: Importing Undefined Module in lib.ts (TypeScript)
DESCRIPTION: This snippet from 'lib.ts' demonstrates a TS2307 error, indicating that the module 'foo' cannot be found. This typically occurs when a module is imported but not installed or incorrectly referenced in the project's 'tsconfig.json'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/cachedModuleResolution7.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import {x} from "foo";
```

----------------------------------------

TITLE: Capturing Multiple Let Variables in For Loop (TypeScript)
DESCRIPTION: Demonstrates capturing multiple `let` declared variables (`x`, `y`) initialized within a single `for` loop statement. Closures correctly capture the re-bound values of both `x` and `y` for each iteration. Includes conditional `break` and `continue` statements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/capturedLetConstInLoop6_ES6.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
for (let x = 0, y = 1; x < 1; ++x) {
    (function() { return x + y});
    (() => x + y);
    if (x == 1) {
        break;
    }
    if (x == 2) {
        continue;
    }
}
```

----------------------------------------

TITLE: Destructuring with Nested Spread - Properties 'z', 'a', 'b' (TypeScript)
DESCRIPTION: This snippet illustrates object destructuring with a spread operator merging properties from another object. Properties 'z', 'a', and 'b' are successfully extracted from the combined object.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/destructuringSpread.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
const { z, a, b } = {
  z: 0,
  ...{ a: 0, b: 0 }
};
```

----------------------------------------

TITLE: Demonstrating Object Literal Freshness with Spread in TypeScript
DESCRIPTION: This snippet illustrates TypeScript's object literal freshness checking. When an object literal is assigned to a type with known properties, explicitly declared unknown properties (like 'z') will cause a `TS2353` error, while properties introduced via spread (`...x`) that are not part of the target type's known properties ('extra') are allowed if the source object is not fresh.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/objectLiteralFreshnessWithSpread.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
let x = { b: 1, extra: 2 }
let xx: { a, b }  = { a: 1, ...x, z: 3 } // error for 'z', no error for 'extra'
```

----------------------------------------

TITLE: Defining and Using JSDoc-Typed Classes with Generics in JavaScript
DESCRIPTION: This comprehensive snippet illustrates the definition of `Soup` (a generic class using JSDoc `@template`) and `Chowder` (a class extending `Soup` with a specific generic type, also via JSDoc `@extends`). It includes examples of correct and incorrect instantiation, highlighting TypeScript errors (`TS2554` for missing arguments and `TS2345` for type mismatches) when `Chowder` is instantiated without arguments or with an incorrect type.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/classCanExtendConstructorFunction.errors.txt#_snippet_8

LANGUAGE: JavaScript
CODE:
```
/**
 * @template T
 * @param {T} flavour
 */
function Soup(flavour) {
    this.flavour = flavour
}
/** @extends {Soup<{ claim: "ignorant" | "malicious" }>} */
class Chowder extends Soup {
    log() {
        return this.flavour
    }
}

var soup = new Soup(1);
soup.flavour
var chowder = new Chowder({ claim: "ignorant" });
chowder.flavour.claim
var errorNoArgs = new Chowder();
var errorArgType = new Chowder(0);
```

----------------------------------------

TITLE: Successful ECMAScript Imports with Explicit Extensions in TypeScript
DESCRIPTION: This block of code demonstrates correct ECMAScript module imports. Each `import` statement explicitly includes the file extension (`.js`, `.mjs`, or `.cjs`), which is required when `--moduleResolution` is set to `node16` or `nodenext` to ensure proper module resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node18).errors.txt#_snippet_25

LANGUAGE: TypeScript
CODE:
```
import * as m1 from "./index.js";
import * as m2 from "./index.mjs";
import * as m3 from "./index.cjs";
import * as m4 from "./subfolder/index.js";
import * as m5 from "./subfolder/index.mjs";
import * as m6 from "./subfolder/index.cjs";
import * as m7 from "./subfolder2/index.js";
import * as m8 from "./subfolder2/index.mjs";
import * as m9 from "./subfolder2/index.cjs";
import * as m10 from "./subfolder2/another/index.js";
import * as m11 from "./subfolder2/another/index.mjs";
import * as m12 from "./subfolder2/another/index.cjs";
```

----------------------------------------

TITLE: Type Assertions with Keyof and String in TypeScript
DESCRIPTION: This function explores type assertions involving `keyof T` and `string`. It demonstrates casting a `string` to `keyof T` and vice-versa, illustrating how TypeScript handles these conversions and the potential implications for type safety.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess.errors.txt#_snippet_28

LANGUAGE: TypeScript
CODE:
```
    function f50<T>(k: keyof T, s: string) {
        const x1 = s as keyof T;
        const x2 = k as string;
    }
```

----------------------------------------

TITLE: Inner Module Package Configuration - JSON
DESCRIPTION: This package.json file configures the 'inner' module as an ES module ("type": "module") and defines its main entry point using "exports". This configuration is crucial for how the 'inner' module is resolved by TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsBlocksSpecifierResolution(module=nodenext).errors.txt#_snippet_4

LANGUAGE: JSON
CODE:
```
{
    "name": "inner",
    "private": true,
    "type": "module",
    "exports": "./index.js"
}
```

----------------------------------------

TITLE: Correct Type-Only Imports to Resolve Conflicts (TypeScript)
DESCRIPTION: This TypeScript snippet illustrates the correct usage of 'import type' for 'Date' and 'Event' from './types.ts', resolving the TS2866 errors by explicitly marking them as type-only imports. It also includes a standard import for 'Console' from 'node:console', demonstrating mixed import strategies.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/isolatedModulesShadowGlobalTypeNotValue(isolatedmodules=true,verbatimmodulesyntax=false).errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import type { Date, Event } from './types';
import { Console } from 'node:console';
function foo(a: Date) {
    const b = new Date(a.year, a.month, a.day);
    return b.getTime();
}
function bar() {
    return new Event('bar') as Event.T;
}
const baz: Console = new Console();
```

----------------------------------------

TITLE: Package JSON for 'pkg' with Conditional Exports
DESCRIPTION: This `package.json` defines the 'pkg' module, specifying conditional exports for `import` (ESM) and `require` (CommonJS) entry points. This configuration dictates how different module loaders will resolve imports from this package, influencing the behavior observed in `index.ts` based on the resolution mode.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride3(module=node16).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Subfolder2 Package Configuration (Default Type)
DESCRIPTION: This `package.json` file for `subfolder2` is empty, meaning it inherits the module type from its parent `package.json` (which is `"type": "module"` from the root). This implies that `.js` files in this folder will be treated as ES modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node18).errors.txt#_snippet_38

LANGUAGE: JSON
CODE:
```
{}
```

----------------------------------------

TITLE: Destructuring Assignment with Default Values in TypeScript
DESCRIPTION: This snippet illustrates a destructuring assignment pattern with default values. It assigns the 'name' property to 'nameA' and 'skill' to 'skillA', providing 'noName' and 'noSkill' respectively if the original properties are missing or undefined. This is a concise way to extract values and ensure defaults.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_47

LANGUAGE: TypeScript
CODE:
```
{name: nameA = "noName", skill: skillA = "noSkill" }
```

----------------------------------------

TITLE: Dynamic `import()` with ESM Resolution in TypeScript
DESCRIPTION: This section illustrates dynamic `import()` statements, which utilize the ECMAScript Module (ESM) resolver. Unlike `require`, the ESM resolver does not perform automatic extension or index resolution, leading to `TS2834` and `TS2835` errors when explicit file extensions are omitted, especially with `node16` or `nodenext` module resolution. `TS2307` indicates a general module not found error.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=nodenext).errors.txt#_snippet_35

LANGUAGE: TypeScript
CODE:
```
const _m35 = import("./");
const _m36 = import("./index");
const _m37 = import("./subfolder");
const _m38 = import("./subfolder/");
const _m39 = import("./subfolder/index");
const _m40 = import("./subfolder2");
const _m41 = import("./subfolder2/");
const _m42 = import("./subfolder2/index");
const _m43 = import("./subfolder2/another");
const _m44 = import("./subfolder2/another/");
```

----------------------------------------

TITLE: Demonstrating TS2345 Error: Function Signature Mismatch in TypeScript
DESCRIPTION: This snippet shows a TypeScript type error (TS2345) where the `callee` function, which requires two arguments (`n: number | undefined, m: string`), is passed as an argument to the `caller` function. The `caller` function expects its argument (`arg`) to be a function that takes an optional number parameter (`n?: number`). The mismatch occurs because `callee`'s signature is not assignable to `caller`'s expected signature, as `callee` requires a second argument (`m: string`) that `caller`'s expected signature does not provide or account for.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/signatureLengthMismatchWithOptionalParameters.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function callee(n: number | undefined, m: string) { }

function caller(arg: (n?: number) => void) { }

caller(callee);
```

----------------------------------------

TITLE: Dynamic Import with Missing Extension (Nested Subfolder Index)
DESCRIPTION: This snippet demonstrates a dynamic 'import()' call targeting an 'index' file within a nested subfolder, lacking an explicit file extension. The ECMAScript module resolver, used by dynamic imports, necessitates explicit extensions for correct resolution in 'node16' or 'nodenext' mode.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=nodenext).errors.txt#_snippet_22

LANGUAGE: TypeScript
CODE:
```
const _m45 = import("./subfolder2/another/index");
```

----------------------------------------

TITLE: JavaScript ESM Module Imports with Import Maps
DESCRIPTION: Demonstrates how ECMAScript Modules (ESM) use import maps to resolve internal module paths. This setup is shown across .js, .mjs, and .cjs files, all importing the same set of modules defined in 'package.json'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageImports(module=node20).errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as cjs from "#cjs";
import * as mjs from "#mjs";
import * as type from "#type";
cjs;
mjs;
type;
```

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as cjs from "#cjs";
import * as mjs from "#mjs";
import * as type from "#type";
cjs;
mjs;
type;
```

LANGUAGE: JavaScript
CODE:
```
// esm format file
import * as cjs from "#cjs";
import * as mjs from "#mjs";
import *s type from "#type";
cjs;
mjs;
type;
```

----------------------------------------

TITLE: Root Project Package.json Configuration
DESCRIPTION: Defines the main `package.json` for the root project, setting its name, private status, and explicitly declaring `"type": "module"` to enable ES Module behavior by default.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackagePatternExports(module=node20).errors.txt#_snippet_6

LANGUAGE: json
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Grouping Custom Objects by Property using Object.groupBy (TypeScript)
DESCRIPTION: This snippet defines an `Employee` type and demonstrates grouping a `Set` of `Employee` objects by their `role` property using `Object.groupBy`. It showcases how to group custom objects based on a specific string property.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/objectGroupBy.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
type Employee = { name: string, role: 'ic' | 'manager' }
const employees: Set<Employee> = new Set();
const byRole = Object.groupBy(employees, x => x.role);
```

----------------------------------------

TITLE: Assigning Functions to a Type with Two Optional Parameters (TypeScript)
DESCRIPTION: This snippet illustrates assigning different function expressions and existing functions (from an assumed 'b' object) to a variable 'a5' typed as a function taking two optional number parameters. It shows that assignments are valid when the assigned function has fewer or the same number of parameters, adhering to TypeScript's function compatibility rules for optional parameters.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/assignmentCompatWithCallSignaturesWithOptionalParameters.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
var a5: (x?: number, y?: number) => number;
a5 = () => 1; // ok, fewer required params
a5 = (x?: number, y?: number) => 1; // ok, fewer required params
a5 = (x: number) => 1; // ok, fewer params in lambda
a5 = (x: number, y: number) => 1;  // ok, same number of params
a5 = b.a; // ok
a5 = b.a2; // ok
a5 = b.a3; // ok, fewer params in b.a3
a5 = b.a4; // ok, same number of params
a5 = b.a5; // ok
a5 = b.a6; // ok, same number of params
```

----------------------------------------

TITLE: Using String.prototype.trimRight (ES2019+)
DESCRIPTION: This snippet attempts to use the 'trimRight' method on a string. This method is an alias for 'trimEnd' and is part of the ECMAScript 2019 specification. The error indicates that the current TypeScript 'lib' compiler option does not include 'es2019' or later, which is required for this functionality.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/doYouNeedToChangeYourTargetLibraryES2016Plus.errors.txt#_snippet_25

LANGUAGE: TypeScript
CODE:
```
const testStringTrimRight = "".trimRight();
```

----------------------------------------

TITLE: Object Destructuring with Renaming and Default Values in TypeScript
DESCRIPTION: These snippets illustrate a common pattern in TypeScript (and JavaScript ES6+) object destructuring. They show how to extract a property from an object, rename it to a new variable name, and provide a default value if the original property is not found or is undefined.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringParameterNestedObjectBindingPatternDefaultValues.sourcemap.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
primary: primaryB = "primary"
```

LANGUAGE: TypeScript
CODE:
```
secondary: secondaryB = "secondary"
```

----------------------------------------

TITLE: Calculating Area using If/Else If with Discriminated Unions in TypeScript
DESCRIPTION: Calculates the area of a `Shape` using a series of `if/else if` statements. TypeScript uses the `s.kind` property to narrow the type of `s` within each block, allowing access to specific properties like `s.size`, `s.radius`, `s.width`, and `s.height`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes1.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function area1(s: Shape) {
    if (s.kind === "square") {
        return s.size * s.size;
    }
    else if (s.kind === "circle") {
        return Math.PI * s.radius * s.radius;
    }
    else if (s.kind === "rectangle") {
        return s.width * s.height;
    }
    else {
        return 0;
    }
}
```

----------------------------------------

TITLE: Updating Object IDs with Type-Safe Mapping in TypeScript
DESCRIPTION: This function `updateIds` updates string ID fields within an object based on a provided mapping. It uses generic constraints `T extends Record<K, string>` and `K extends string` to ensure type safety for the object and its ID fields, and `Partial<Record<T[K], T[K]>>` for the mapping.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/keyofAndIndexedAccess.errors.txt#_snippet_65

LANGUAGE: TypeScript
CODE:
```
function updateIds<T extends Record<K, string>, K extends string>(
    obj: T,
    idFields: K[],
    idMapping: Partial<Record<T[K], T[K]>>
): Record<K, string> {
    for (const idField of idFields) {
        const newId: T[K] | undefined = idMapping[obj[idField]];
        if (newId) {
            obj[idField] = newId;
        }
    }
    return obj;
}
```

----------------------------------------

TITLE: CommonJS Require: Successful Module Resolution
DESCRIPTION: This snippet demonstrates successful module resolution using CommonJS 'require' statements. Unlike ECMAScript imports, 'require' calls still perform extension and index resolution, allowing them to load CommonJS modules without explicit extensions, even under 'node16' or 'nodenext' module resolution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=node16).errors.txt#_snippet_14

LANGUAGE: TypeScript
CODE:
```
import m26 = require("./subfolder");
import m27 = require("./subfolder/");
import m28 = require("./subfolder/index");
import m29 = require("./subfolder2");
import m30 = require("./subfolder2/");
import m31 = require("./subfolder2/index");
```

----------------------------------------

TITLE: Defining a Point Interface in TypeScript
DESCRIPTION: This snippet defines the `Point` interface, representing a 2D coordinate with `x` and `y` number properties. It is used in other examples to demonstrate type relationships.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeErrors.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
interface Point {
    x: number;
    y: number;
}
```

----------------------------------------

TITLE: Declaring 'WriteFileOptions' Interface in TypeScript
DESCRIPTION: This TypeScript declaration defines the `WriteFileOptions` interface within the 'fs' module, along with a `writeFile` function signature that utilizes it. This interface is fundamental for type-checking file write operations in Node.js environments.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/importingExportingTypes.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare module "fs" {
  export interface WriteFileOptions {}
  export function writeFile(path: string, data: any, options: WriteFileOptions, callback: (err: Error) => void): void;
}
```

----------------------------------------

TITLE: Declare an Array with Union Types in TypeScript
DESCRIPTION: This snippet illustrates declaring an array 'robotAInfo' in TypeScript that can hold elements of either 'number' or 'string' types, using a union type '(number | string)[]'. The JavaScript output is a simple 'var' declaration for an uninitialized variable.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementArrayBindingPattern3.sourcemap.txt#_snippet_7

LANGUAGE: JavaScript
CODE:
```
var robotAInfo;
```

LANGUAGE: TypeScript
CODE:
```
let robotAInfo: (number | string)[];
```

----------------------------------------

TITLE: Declaring Function with Object Destructuring and Default Property Value (TypeScript)
DESCRIPTION: Defines a function c2 with an object destructuring parameter where the z property has a default value, making z an optional number.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/destructuringParameterDeclaration1ES5iterable.errors.txt#_snippet_15

LANGUAGE: TypeScript
CODE:
```
function c2({z = 10}) { }
```

----------------------------------------

TITLE: Explicit `this` Type Annotation in TypeScript Function
DESCRIPTION: Demonstrates how to explicitly type the `this` parameter in a function signature. By annotating `this: { no: number }`, TypeScript correctly infers the type of `this.no`, preventing implicit `any` errors and allowing safe property access.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeofThis.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function Test3(this: { no: number }) {
    let x: typeof this.no = 1;
}
```

----------------------------------------

TITLE: Defining an Object Type with Multiline JSDoc Typedef - JavaScript
DESCRIPTION: This example illustrates defining an object type (`Type2`) using a multiline JSDoc `@typedef` expression. The `check` function accepts an object conforming to `Type2`, which includes `num` (number), `str` (string), and `boo` (boolean) properties, and returns either a string or a number based on the `boo` property.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typedefTagWrapping.errors.txt#_snippet_1

LANGUAGE: JavaScript
CODE:
```
/** 
 * @typedef {{
 *   num: number,
 *   str: string,
 *   boo: boolean
 * }} Type2
 */

/**
 * Makes use of a type with a multiline type expression.
 * @param {Type2} obj The object.
 * @returns {string|number} The return.
 */
function check(obj) {
  return obj.boo ? obj.num : obj.str;
}
```

----------------------------------------

TITLE: Generating Read-Only Accessor Names with `const` Assertions in TypeScript
DESCRIPTION: This snippet shows a function that generates an array of accessor names (e.g., 'get-foo', 'set-foo') using template literals and applies a `const` assertion to the returned array. This ensures that the returned array is a read-only tuple with specific string literal types for its elements, providing strong type safety for generated names.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/constAssertions.errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
function accessorNames<S extends string>(propName: S) {
    return [`get-${propName}`, `set-${propName}`] as const;
}

const ns1 = accessorNames('foo');
```

----------------------------------------

TITLE: Instantiating React Component with Spread Props - TypeScript
DESCRIPTION: This snippet demonstrates how to instantiate the `Poisoned` React component using JSX. It utilizes the spread operator (`...obj`) to pass all properties from the `obj` constant, which conforms to the `PoisonedProp` interface, as props to the component. This is a common pattern for passing multiple props concisely.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxSpreadAttributesResolution4.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
let p = <Poisoned {...obj} />;
```

----------------------------------------

TITLE: Implementing MainButton Component with Prop Discrimination in TypeScript
DESCRIPTION: This snippet provides the implementation for the `MainButton` component, which uses type discrimination to determine its behavior. It casts the incoming `props` to `LinkProps` and checks for the existence of the `to` property. If `to` is present, it delegates to `_buildMainLink`; otherwise, it defaults to `_buildMainButton`. This pattern allows a single function to handle multiple prop types based on their unique properties.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxStatelessFunctionComponentOverload5.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
export function MainButton(props: ButtonProps | LinkProps | HyphenProps): JSX.Element {
    const linkProps = props as LinkProps;
    if(linkProps.to) {
        return this._buildMainLink(props);
    }

    return this._buildMainButton(props);
}
```

----------------------------------------

TITLE: TypeScript Declaration File for Import Mode (import.d.ts)
DESCRIPTION: This declaration file (`import.d.ts`) is designed to be resolved when the `pkg` module is imported using the `import` resolution mode. It declares `foo` as a global number, making it available in contexts where `resolution-mode="import"` is active.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride4(module=node20).errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
export {};
declare global {
    var foo: number;
}
```

----------------------------------------

TITLE: Defining and Using an Async React Functional Component (RSC) in TypeScript
DESCRIPTION: This snippet defines `RenderPromise`, an `async` functional React component that accepts a `title` prop and returns a promise resolving to a string. This pattern is characteristic of React Server Components (RSCs), where components can perform asynchronous operations. It also demonstrates TypeScript's prop validation for async components.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsxElementType.errors.txt#_snippet_8

LANGUAGE: TSX
CODE:
```
const RenderPromise = async ({ title }: { title: string }) => "react";
Component = RenderPromise;
<RenderPromise />;
<RenderPromise title="react" />;
<RenderPromise excessProp />;
```

----------------------------------------

TITLE: Concatenating Variadic Tuples
DESCRIPTION: The `concat` function demonstrates a generic way to concatenate two variadic tuple types `T` and `U` into a new tuple type `[...T, ...U]`, preserving the order and types of elements.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/variadicTuples1.errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
function concat<T extends unknown[], U extends unknown[]>(t: [...T], u: [...U]): [...T, ...U] {
    return [...t, ...u];
}
```

----------------------------------------

TITLE: Root Package.json ES Module Configuration
DESCRIPTION: This `package.json` snippet configures the root project as an ECMAScript module by setting `"type": "module"`. This declaration influences how TypeScript and Node.js resolve and interpret module imports and exports within this package, making files like `index.ts` behave as ES modules by default.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesSynchronousCallErrors(module=node16).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
        "name": "package",
        "private": true,
        "type": "module"
    }
```

----------------------------------------

TITLE: Defining and Exporting Modules in TypeScript with Visibility Examples
DESCRIPTION: This TypeScript code defines several nested modules (`OuterMod`, `M`, `InnerMod`), an enum (`E`), an interface (`I`), and classes (`B`, `C`). It demonstrates how members are declared, exported, and accessed across different module scopes. The snippet also includes examples of common visibility errors when attempting to access non-exported or private members from outside their defined scope, such as accessing `x` or `E` from `M` when they are not explicitly exported.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/moduleVisibilityTest2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
module OuterMod {\n\texport function someExportedOuterFunc() { return -1; }\n\n\texport module OuterInnerMod {\n\t\texport function someExportedOuterInnerFunc() { return "foo"; }\n\t}\n}\n\nimport OuterInnerAlias = OuterMod.OuterInnerMod;\n\nmodule M {\n\n\tmodule InnerMod {\n\t\texport function someExportedInnerFunc() { return -2; }\n\t}\n\n\tenum E {\n\t\tA,\n\t\tB,\n\t\tC,\n\t}\n\n\tvar x = 5;\n\texport declare var exported_var;\n\n\tvar y = x + x;\n\n\n\tinterface I {\n\t\tsomeMethod():number;\n\t}\n\n\t class B {public b = 0;}\n\n\t export class C implements I {\n\t\tpublic someMethodThatCallsAnOuterMethod() {return OuterInnerAlias.someExportedOuterInnerFunc();}\n\t\tpublic someMethodThatCallsAnInnerMethod() {return InnerMod.someExportedInnerFunc();}\n\t\tpublic someMethodThatCallsAnOuterInnerMethod() {return OuterMod.someExportedOuterFunc();}\n\t\tpublic someMethod() { return 0; }\n\t\tpublic someProp = 1;\n\n\t\tconstructor() {\n\t\t    function someInnerFunc() { return 2; }\n            var someInnerVar = 3;\n\t\t}\n\t\t\n\t}\n\n\tvar someModuleVar = 4;\n\n\tfunction someModuleFunction() { return 5;}\n}\n\nmodule M {\n\texport var c = x;\n\texport var meb = M.E.B;\n}\n\nvar cprime : M.I = <M.I>null;\n\nvar c = new M.C();\nvar z = M.x;\nvar alpha = M.E.A;\nvar omega = M.exported_var;\nc.someMethodThatCallsAnOuterMethod();
```

----------------------------------------

TITLE: ESM Imports in index.ts - TypeScript
DESCRIPTION: This TypeScript file is configured as an ECMAScript module (ESM) and demonstrates successful imports of CommonJS (cjs), ECMAScript (mjs), and type-only modules from both 'package' and 'inner' dependencies. It shows how ESM can correctly resolve different module formats without errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackageExports(module=node18).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// esm format file
import * as cjs from "package/cjs";
import * as mjs from "package/mjs";
import * as type from "package";
cjs;
mjs;
type;
import * as cjsi from "inner/cjs";
import * as mjsi from "inner/mjs";
import * as typei from "inner";
cjsi;
mjsi;
typei;
```

----------------------------------------

TITLE: Picking Object Properties by Value Type in TypeScript
DESCRIPTION: The `PickByValueType` mapped type creates a new object type containing only properties from `T` whose values are assignable to type `U`. It uses a conditional type within the `as` clause to filter keys. This example demonstrates how to pick properties of type `string` from `Example`, resulting in `T1` containing only `foo`, and confirms that `e2` can only be 'foo'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypeAsClauses.errors.txt#_snippet_6

LANGUAGE: TypeScript
CODE:
```
type Example = {foo: string, bar: number};

type PickByValueType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K]
};

type T1 = PickByValueType<Example, string>;
const e1: T1 = {
    foo: "hello"
};
type T2 = keyof T1;
const e2: T2 = "foo";
```

----------------------------------------

TITLE: Declaring Overloaded MainButton Component Signatures in TypeScript
DESCRIPTION: This snippet defines the overloaded function signatures for the `MainButton` React component. It declares that `MainButton` can accept `ButtonProps`, `LinkProps`, or `HyphenProps`, each returning a `JSX.Element`. This allows the component to behave differently based on the specific set of props provided, leveraging TypeScript's function overloading capabilities.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxStatelessFunctionComponentOverload5.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
export function MainButton(buttonProps: ButtonProps): JSX.Element;
export function MainButton(linkProps: LinkProps): JSX.Element;
export function MainButton(hyphenProps: HyphenProps): JSX.Element;
```

----------------------------------------

TITLE: Declaring Private Field in Class
DESCRIPTION: This snippet declares a private field named `#private` within a class. This is a syntax for private class fields in JavaScript/TypeScript, ensuring the field is only accessible from within the class itself, enforcing encapsulation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/esDecorators-classDeclaration-sourceMap(target=esnext).sourcemap.txt#_snippet_16

LANGUAGE: TypeScript
CODE:
```
#private;
```

----------------------------------------

TITLE: Defining Generic Seq Collections in TypeScript
DESCRIPTION: This snippet defines the `Seq` function and interface, representing a generic sequence in Immutable.js. It provides overloaded function signatures for creating sequences from various collection types (Keyed, Indexed, Set, Iterable, plain objects) and defines common sequence operations like `cacheResult`, `map`, `flatMap`, and `filter`. It extends the base `Collection` interface.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/complexRecursiveCollections.errors.txt#_snippet_42

LANGUAGE: TypeScript
CODE:
```
export function Seq<S extends Seq<any, any>>(seq: S): S;
export function Seq<K, V>(collection: Collection.Keyed<K, V>): Seq.Keyed<K, V>;
export function Seq<T>(collection: Collection.Indexed<T>): Seq.Indexed<T>;
export function Seq<T>(collection: Collection.Set<T>): Seq.Set<T>;
export function Seq<T>(collection: Iterable<T>): Seq.Indexed<T>;
export function Seq<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
export function Seq(): Seq<any, any>;
export interface Seq<K, V> extends Collection<K, V> {
  readonly size: number | undefined;
  cacheResult(): this;
  map<M>(mapper: (value: V, key: K, iter: this) => M, context?: any): Seq<K, M>;
  flatMap<M>(mapper: (value: V, key: K, iter: this) => Iterable<M>, context?: any): Seq<K, M>;
  filter<F extends V>(predicate: (value: V, key: K, iter: this) => value is F, context?: any): Seq<K, F>;
  filter(predicate: (value: V, key: K, iter: this) => any, context?: any): this;
}
```

----------------------------------------

TITLE: Implicit Any Type Error for Function Parameters (TypeScript)
DESCRIPTION: This snippet demonstrates implicit 'any' type errors for parameters 'x' and 'z' in a function expression. TypeScript flags these parameters with TS7006 because their types are not explicitly defined and cannot be inferred from usage, leading to a less type-safe codebase.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyParametersInModule.errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
var m_f12 = (x, y: any, z) => "";
```

----------------------------------------

TITLE: Importing ES Module in CommonJS TypeScript JSX (.tsx)
DESCRIPTION: This TypeScript JSX file (.tsx) is implicitly a CommonJS module. It encounters TS1479 when trying to statically import an ECMAScript module (./module.mjs). The suggested fix is to add "type": "module" to package.json to convert the project to ES modules.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesCJSResolvingToESM1_emptyPackageJson.errors.txt#_snippet_5

LANGUAGE: TypeScript
CODE:
```
import {} from "./module.mjs";
```

----------------------------------------

TITLE: Chaining Promise.then with Mixed Callbacks (OK)
DESCRIPTION: This snippet demonstrates a successful chain of `then` calls on a promise `s10`. It uses different callback functions (`testFunctionP`, `nIPromise`, `sIPromise`, `sPromise`) for fulfillment, rejection, and progress, showing a valid type assignment and chaining.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/promisePermutations.errors.txt#_snippet_42

LANGUAGE: TypeScript
CODE:
```
var s10g = s10.then(testFunctionP, nIPromise, sIPromise).then(sPromise, sIPromise, sIPromise); // ok
```

----------------------------------------

TITLE: Defining a Variable with Multiple JSDoc Types in JavaScript
DESCRIPTION: This snippet defines a JavaScript variable 'v' and uses JSDoc comments to declare that it can be either a 'number' or a 'string'. This demonstrates how TypeScript's type checker can leverage JSDoc annotations in plain JavaScript files to provide type safety and analysis without requiring a full conversion to TypeScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/jsFileCompilationSyntaxError.errors.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
/**
  * @type {number}
  * @type {string}
  */
var v;
```

----------------------------------------

TITLE: Relative Dynamic Import in ES Modules (TS2834 Error)
DESCRIPTION: This TypeScript snippet demonstrates a relative dynamic import in an ECMAScript module. It intentionally triggers a TS2834 error because the import path './foo' lacks an explicit file extension, which is a requirement when TypeScript's module resolution is configured to 'node16' or 'nodenext'. To resolve this error, the import path must be updated to include the appropriate file extension, such as './foo.js' or './foo.ts'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/moduleResolutionWithoutExtension5.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import("./foo").then(x => x);
```

----------------------------------------

TITLE: Configuring Root Package as ES Module (JSON)
DESCRIPTION: This 'package.json' snippet configures the root package to be an ES Module ("type": "module"). This setting influences how TypeScript resolves and transpiles imports and exports within the project, particularly for default imports.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportHelpersCollisions3(module=nodenext).errors.txt#_snippet_2

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Main Project Package.json Configuration
DESCRIPTION: This `package.json` file configures the main project. The `"type": "module"` field explicitly declares the package as an ECMAScript module, influencing how `.js` and `.ts` files are interpreted by default.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackagePatternExportsTrailers(module=node16).errors.txt#_snippet_6

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Valid IPromise Chaining with Consistent Callbacks - TypeScript
DESCRIPTION: This example illustrates a correct and compatible chain of `IPromise.then()` calls. The `sIPromise` functions are consistently used as arguments, satisfying the expected overload signatures and resulting in no TypeScript errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/promisePermutations.errors.txt#_snippet_26

LANGUAGE: TypeScript
CODE:
```
var r6b = r6.then(sIPromise, sIPromise, sIPromise).then(sIPromise, sIPromise, sIPromise); // ok
```

----------------------------------------

TITLE: Incorrect Import Assignment for ECMAScript Modules in TypeScript
DESCRIPTION: This snippet shows an `import assignment` (`import CJSy = require(...)`) which is an error (TS1202) when the TypeScript project targets ECMAScript modules. The error suggests using `import * as ns from 'mod'`, `import {a} from 'mod'`, or `import d from 'mod'` instead for compatibility.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/verbatimModuleSyntaxRestrictionsESM(esmoduleinterop=false).errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import CJSy = require("./decl");
```

----------------------------------------

TITLE: Iterating with TypeScript For-Of Loop and Destructuring
DESCRIPTION: This snippet demonstrates a `for...of` loop in TypeScript, which iterates over an iterable (returned by `getRobots()`). It utilizes array destructuring to assign elements from each iterated item to `numberA3` (with a default value of -1) and `robotAInfo` (as a rest array).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfArrayBindingPatternDefaultValues.sourcemap.txt#_snippet_72

LANGUAGE: TypeScript
CODE:
```
for (let [numberA3 = -1, ...robotAInfo] of getRobots()) {
```

----------------------------------------

TITLE: Accessing Symbol.iterator in TypeScript (ES5 Target)
DESCRIPTION: This snippet demonstrates an attempt to use `Symbol.iterator` as a computed property name and as a property accessor within a TypeScript module. The code is intended for an ES5 target, which by default does not include the necessary 'Symbol' runtime library, leading to the TS2585 error. To resolve this, the TypeScript compiler's 'lib' option should be set to 'es2015' or later.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/ES5SymbolProperty2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
module M {
    var Symbol: any;

    export class C {
        [Symbol.iterator]() { }
    }
    (new C)[Symbol.iterator];
}

(new M.C)[Symbol.iterator];
```

----------------------------------------

TITLE: Logging a Variable in TypeScript
DESCRIPTION: This snippet demonstrates how to log the value of the 'nameA' variable to the console. It is typically used for debugging purposes to inspect variable states during program execution.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForObjectBindingPattern.sourcemap.txt#_snippet_26

LANGUAGE: TypeScript
CODE:
```
console.log(nameA);
```

----------------------------------------

TITLE: TypeScript Module Import and Export Aliases
DESCRIPTION: This section demonstrates various ways to import and re-export the `a` module (which itself re-exports `mod`). It shows default imports, named default imports, and namespace imports, along with equality checks to confirm their references.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/esModuleInteropDefaultImports.errors.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
    import a from "./a";
    import { default as b } from "./a";
    import c, { default as d } from "./a";
    import * as self from "./b";
    export { default } from "./a";
    export { default as def } from "./a";
    
    a === b;
    b === c;
    c === d;
    d === self.default;
    self.default === self.def;
```

----------------------------------------

TITLE: Defining Package Exports for Type Definitions - JSON
DESCRIPTION: This `package.json` snippet defines the exports for the `@types/foo` package, specifying different entry points for `import` (ESM) and `require` (CommonJS) resolutions. This configuration is crucial for TypeScript's module resolution to correctly find type declarations based on the module system used.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/resolutionModeImportType1(moduleresolution=node10).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "name": "@types/foo",
      "version": "1.0.0",
      "exports": {
        ".": {
          "import": "./index.d.mts",
          "require": "./index.d.cts"
        }
      }
    }
```

----------------------------------------

TITLE: Define Package Exports and Type Versions in package.json
DESCRIPTION: This package.json demonstrates how to configure module exports and type declaration versions using the 'exports' and 'typesVersions' fields. It shows different patterns for direct exports, conditional exports (including type-specific conditions), and version-specific type declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsBlocksTypesVersions(module=node20).errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "name": "exports-and-types-versions",
      "version": "1.0.0",
      "exports": {
        "./foo": "./dist/foo.js",
        "./yep": {
          "types": "./types/foo.d.ts",
          "default": "./dist/foo.js"
        },
        "./versioned-yep": {
          "types@>=4": "./types/foo.d.ts"
        },
        "./versioned-nah": {
          "types@<4": "./types/foo.d.ts"
        }
      },
      "typesVersions": {
        "*": {
          "foo": ["./types/foo.d.ts"],
          "nope": ["./types/foo.d.ts"],
          "versioned-nah": ["./types/foo.d.ts"]
        }
      }
    }
```

----------------------------------------

TITLE: ES Module Import Error in TypeScript index.ts
DESCRIPTION: This snippet from `index.ts` demonstrates a `TS2307` error where the module 'inner/other.js' cannot be found. It highlights a common issue with ES module resolution when imports do not correctly map to declared exports or file paths, despite the presence of type declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsSpecifierGenerationConditions(module=node18).errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// esm format file
import { Thing } from "inner/other.js"; // should fail
export const a = (await import("inner")).x();
```

----------------------------------------

TITLE: Interface with Assertion Signature and Usage
DESCRIPTION: This snippet defines an interface 'Thing' that includes an assertion signature 'isGood(): asserts this is GoodThing'. The 'example1' function demonstrates how calling 'thing.isGood()' within a loop narrows the type of 'thing' to 'GoodThing', allowing access to properties like 'thing.good' with the narrowed type.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/assertionTypePredicates1.errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
    interface Thing {
        good: boolean;
        isGood(): asserts this is GoodThing;
    }
    
    interface GoodThing {
        good: true;
    }
    
    function example1(things: Thing[]) {
        for (let thing of things) {
            thing.isGood();
            thing.good;
        }
    }
```

----------------------------------------

TITLE: Dynamic Import Missing Extension in TypeScript (Node16/Nodenext)
DESCRIPTION: This snippet shows a dynamic `import()` statement for `./index` without an explicit file extension. When TypeScript's `--moduleResolution` is set to `node16` or `nodenext`, ECMAScript imports require explicit file extensions, resulting in a `TS2835` error. The error suggests adding `.mjs`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node16).errors.txt#_snippet_57

LANGUAGE: TypeScript
CODE:
```
const _m36 = import("./index");
```

----------------------------------------

TITLE: Accessing Properties on Object After 'in' Checks in TypeScript
DESCRIPTION: This function shows how TypeScript allows property access on an 'object' type after successful 'in' operator checks for string, numeric, and symbol literal keys. It confirms that properties can be accessed using both dot notation and bracket notation for string keys, and bracket notation for numeric and symbol keys.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/inKeywordTypeguard(strict=false).errors.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
const sym = Symbol();

function f8(x: object) {
    if ("a" in x && 1 in x && sym in x) {
        x.a;
        x["a"];
        x[1];
        x["1"];
        x[sym];
    }
}
```

----------------------------------------

TITLE: Defining FieldFeedback2 Component with Explicit 'when' Prop Type (TypeScript)
DESCRIPTION: This snippet defines `FieldFeedback2`, a React component extending `FieldFeedback`, with a more explicit type for its `when` prop via the `MyPropsProps` interface, ensuring it must be a function returning a boolean. It also sets `defaultProps` for `when` and demonstrates calling `this.props.when` within the `render` method, which is always defined due to `defaultProps`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/reactDefaultPropsInferenceSuccess.errors.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
interface MyPropsProps extends Props {
      when: (value: string) => boolean;
    }
    
    class FieldFeedback2<P extends MyPropsProps = MyPropsProps> extends FieldFeedback<P> {
      static defaultProps = {
        when: () => true
      };
    
      render() {
        this.props.when("now"); // OK, always defined
        return <div>Hello</div>;
      }
    }
```

----------------------------------------

TITLE: Root Project package.json Configuration
DESCRIPTION: This `package.json` defines the root project's metadata, marking it as an ECMAScript module (`"type": "module"`). It also specifies conditional exports for different module formats (`cjs`, `mjs`) and a default entry point, influencing how other modules can import its contents.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackageExports(module=node16).errors.txt#_snippet_7

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module",
    "exports": {
        "./cjs": "./index.cjs",
        "./mjs": "./index.mjs",
        ".": "./index.js"
    }
}
```

----------------------------------------

TITLE: Defining State and Argument Types with Mapped Types in TypeScript
DESCRIPTION: These type definitions (`State`, `Args1`, `Args2`) are used to model application state and function arguments, demonstrating the use of index signatures and nested `Partial` and `Readonly` mapped types for flexible and immutable data structures. `State` defines a generic object, while `Args1` and `Args2` show different compositions of `Partial` and `Readonly`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/mappedTypes5.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
type State = {
    [key: string]: string | boolean | number | null;
};

type Args1<T extends State> = {
    readonly previous: Readonly<Partial<T>>;
    readonly current: Readonly<Partial<T>>;
};

type Args2<T extends State> = {
    readonly previous: Partial<Readonly<T>>;
    readonly current: Partial<Readonly<T>>;
};
```

----------------------------------------

TITLE: TypeScript Class `super` Call `this` Access Error
DESCRIPTION: This snippet illustrates a `TS17009` error in TypeScript. It occurs because `this.z` is accessed as an argument to `super()` before the `super` constructor has been fully called and initialized the `this` context of the derived class `E`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/baseCheck.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
class E extends C { constructor(public z: number) { super(0, this.z) } }
```

----------------------------------------

TITLE: Declaring `const` in Module Block (TypeScript)
DESCRIPTION: Shows the declaration of `const` variables within a TypeScript module block, including a nested block. `const` variables are scoped to their respective blocks within the module.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/constDeclarations-validContexts.errors.txt#_snippet_18

LANGUAGE: TypeScript
CODE:
```
module m {
    const c22 = 0;

    {
          const c23 = 0;
    }
}
```

----------------------------------------

TITLE: TypeScript ESM Module Exports
DESCRIPTION: Shows standard ES module export syntax (`export * from` and `export * as`) in an ES module context. This code compiles without errors, highlighting the difference in module resolution and helper requirements compared to the CommonJS example.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesImportHelpersCollisions2(module=node20).errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export * from "fs";
export * as fs from "fs";
```

----------------------------------------

TITLE: Type Narrowing with Array Destructuring and Rest Parameters in TypeScript
DESCRIPTION: The `f40` function demonstrates type narrowing when destructuring an array using rest parameters. By checking the `kind` (first element of the tuple), TypeScript correctly narrows the type of `data` (the second element), allowing type-specific operations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/dependentDestructuredVariables.errors.txt#_snippet_14

LANGUAGE: TypeScript
CODE:
```
function f40(...[kind, data]: Args) {
    if (kind === 'A') {
        data.toFixed();
    }
    if (kind === 'B') {
        data.toUpperCase();
    }
}
```

----------------------------------------

TITLE: Configuring TypeScript Compiler Options
DESCRIPTION: This snippet defines the TypeScript compiler options, setting `module` to `esnext` and `moduleResolution` to `bundler` for modern module handling. `noEmit` is true to prevent output file generation, and `types` is an empty array, indicating no default type roots are used.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/resolutionModeTripleSlash1.errors.txt#_snippet_0

LANGUAGE: JSON
CODE:
```
{
      "compilerOptions": {
        "module": "esnext",
        "moduleResolution": "bundler",
        "noEmit": true,
        "types": []
      }
    }
```

----------------------------------------

TITLE: Demonstrating TypeScript Error TS18050: Null Property Access
DESCRIPTION: This snippet illustrates the TypeScript error TS18050, which arises when an attempt is made to invoke a method (`toBAZ()`) on a `null` value. TypeScript prevents this operation at compile time because `null` does not have any properties or methods, ensuring type safety and preventing runtime errors.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/propertyAccess4.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
null.toBAZ();
```

----------------------------------------

TITLE: Defining an ECMAScript Module in TypeScript (.mts)
DESCRIPTION: This code defines a simple ECMAScript module using the '.mts' extension. The 'export {};' statement indicates it's a module, even if it exports nothing. This file type is incompatible with CommonJS 'require' calls, triggering TS1479 when imported incorrectly.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesCJSResolvingToESM2_cjsPackageJson.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
export {};
```

----------------------------------------

TITLE: Type Narrowing with 'instanceof' in TypeScript
DESCRIPTION: The 'f1' function demonstrates how TypeScript performs type narrowing using the 'instanceof' operator. Within the 'if' block, the type of 'node' is narrowed to 'A'. In the 'else' block, it's narrowed to 'B'. Outside the conditional, the type reverts to the original union 'A | B'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/intersectionWithConflictingPrivates.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function f1(node: A | B) {
  if (node instanceof A || node instanceof A) {
    node;  // A
  }
  else {
    node;  // B
  }
  node;  // A | B
}
```

----------------------------------------

TITLE: Defining React Components and Interfaces in TypeScript
DESCRIPTION: This snippet defines a React functional component `Comp` that expects a `Prop` interface, which includes `a` (number), `b` (string), and a `children` property of type `Button`. It also defines a `Button` class component. These definitions set up the types and components used in subsequent JSX examples.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/checkJsxChildrenProperty5.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import React = require('react');

interface Prop {
    a: number,
    b: string,
    children: Button;
}

class Button extends React.Component<any, any> {
    render() {
        return (<div>My Button</div>)
    }
}

function Comp(p: Prop) {
    return <div>{p.b}</div>;
}
```

----------------------------------------

TITLE: Demonstrating TypeScript Method Signature Incompatibility in Inheritance
DESCRIPTION: This TypeScript code defines a base class `C` and two derived classes `D` and `E`. It illustrates how modifying method signatures in subclasses, specifically by dropping required parameters (`D`) and adding optional ones with different types (`E`), can lead to type incompatibility (TS2322) when attempting to assign an instance of the most derived class (`E`) to a base class type (`C`). The error highlights that `E<string>` is not assignable to `C<string>` due to incompatible `foo` method types, specifically the `y` parameter.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/derivedClassTransitivity3.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
// subclassing is not transitive when you can remove required parameters and add optional parameters
    
    class C<T> {
        foo(x: T, y: T) { }
    }
    
    class D<T> extends C<T> {
        foo(x: T) { } // ok to drop parameters
    }
    
    class E<T> extends D<T> {
        foo(x: T, y?: number) { } // ok to add optional parameters
    }
    
    var c: C<string>;
    var d: D<string>;
    var e: E<string>;
    c = e;
    var r = c.foo('', '');
    var r2 = e.foo('', 1);
```

----------------------------------------

TITLE: Handling TypeScript Type Error: Array to Tuple (Fewer Elements)
DESCRIPTION: This snippet illustrates a common TypeScript type error where a general array type, `(string | number | boolean)[]`, is not assignable to a fixed-length tuple type, `[string, number, boolean]`. The error occurs because the array might contain fewer elements than the required tuple length, violating the tuple's structural integrity. The specific error message is: "Argument of type '(string | number | boolean)[]' is not assignable to parameter of type '[string, number, boolean]'. Target requires 3 element(s) but source may have fewer."
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/argumentExpressionContextualTyping.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
function baz(x: [string, number, boolean]) { }
var array = ["string", 1, true];
baz(array);
```

----------------------------------------

TITLE: Successful ECMAScript Module Imports (index.mjs) - TypeScript
DESCRIPTION: This block demonstrates a series of successful ECMAScript module imports within `index.mjs`. It shows correct relative import paths with explicit file extensions (`.js`, `.mjs`, `.cjs`), adhering to strict module resolution rules like `node16` or `nodenext`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJs1(module=node16).errors.txt#_snippet_47

LANGUAGE: TypeScript
CODE:
```
import * as m1 from "./index.js";
import * as m2 from "./index.mjs";
import * as m3 from "./index.cjs";
import * as m4 from "./subfolder/index.js";
import * as m5 from "./subfolder/index.mjs";
import * as m6 from "./subfolder/index.cjs";
import * as m7 from "./subfolder2/index.js";
import * as m8 from "./subfolder2/index.mjs";
import * as m9 from "./subfolder2/index.cjs";
import * as m10 from "./subfolder2/another/index.js";
import * as m11 from "./subfolder2/another/index.mjs";
import * as m12 from "./subfolder2/another/index.cjs";
```

----------------------------------------

TITLE: Demonstrating Abstract Class Instantiation Error in TypeScript
DESCRIPTION: This snippet defines an abstract class 'A' with an abstract method 'foo'. It then shows a concrete class 'B' extending 'A' and implementing 'foo', which can be instantiated. Finally, it defines another abstract class 'C' extending 'A' and attempts to instantiate 'C' directly, resulting in a TS2511 error because abstract classes cannot be instantiated.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/classAbstractUsingAbstractMethod1.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
abstract class A {
    abstract foo() : number;
}

class B extends A {
    foo() { return 1; }
}

abstract class C extends A  {
    abstract foo() : number;
}

var a = new B;
a.foo();

a = new C; // error, cannot instantiate abstract class.
```

----------------------------------------

TITLE: Equality Narrowing of Generic Type T with Undefined and Null in TypeScript
DESCRIPTION: This function f23 demonstrates type narrowing for a generic type T unioned with undefined and null. It shows that x !== undefined narrows x to T & {} | null, x !== null narrows x to T & {} | undefined, and loose equality != undefined or != null effectively narrows x to T & {}, removing both null and undefined.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownControlFlow.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
function f23<T>(x: T | undefined | null) {
    if (x !== undefined) {
        x;  // T & {} | null
    }
    if (x !== null) {
        x;  // T & {} | undefined
    }
    if (x != undefined) {
        x;  // T & {}
    }
    if (x != null) {
        x;  // T & {}
    }
}
```

----------------------------------------

TITLE: Incorrect Prop Assignment to `EmptyPropSFC` (Unknown Prop) in TypeScript JSX
DESCRIPTION: This snippet illustrates a `TS2322` error when an unknown prop `prop1` is passed to `EmptyPropSFC`, which expects no explicit props. TypeScript indicates that `prop1` does not exist on `IntrinsicAttributes`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxStatelessFunctionComponents1.errors.txt#_snippet_11

LANGUAGE: TypeScript
CODE:
```
let i = <EmptyPropSFC prop1 />
```

----------------------------------------

TITLE: Narrowing Discriminated Union with If/Else in TypeScript
DESCRIPTION: Demonstrates type narrowing for a discriminated union type using `if/else if/else` statements. The `kind` property acts as the discriminant, allowing access to specific properties (`a`, `b`, or `c`) based on its boolean or string value.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/discriminatedUnionTypes2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function f10(x : { kind: false, a: string } | { kind: true, b: string } | { kind: string, c: string }) {
    if (x.kind === false) {
        x.a;
    }
    else if (x.kind === true) {
        x.b;
    }
    else {
        x.c;
    }
}
```

----------------------------------------

TITLE: Defining Package Exports in package.json
DESCRIPTION: This `package.json` defines the `pkg` module, specifying conditional exports for `import` (ESM) and `require` (CommonJS). This configuration dictates how different module systems resolve paths within the package, influencing which declaration file is used.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesTripleSlashReferenceModeOverride2(module=node16).errors.txt#_snippet_1

LANGUAGE: JSON
CODE:
```
{
    "name": "pkg",
    "version": "0.0.1",
    "exports": {
        "import": "./import.js",
        "require": "./require.js"
    }
}
```

----------------------------------------

TITLE: Type Narrowing for Object Types with typeof in TypeScript
DESCRIPTION: Illustrates type narrowing for a generic type `T` constrained to `{} | undefined`. When `typeof x === "object"` is true, `x` is narrowed to `T & object`, effectively removing `undefined` and `null` (if `null` were possible for `T`).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/unknownControlFlow.errors.txt#_snippet_12

LANGUAGE: TypeScript
CODE:
```
function f32<T extends {} | undefined>(x: T) {
    if (typeof x === "object") {
        x;  // T & object
    }
}
```

----------------------------------------

TITLE: Defining Type Versions in package.json (No Exports)
DESCRIPTION: This package.json configuration exclusively uses the 'typesVersions' field to map module names to their declaration files. Unlike the previous example, it does not include an 'exports' field, which can influence how TypeScript resolves types.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesExportsBlocksTypesVersions(module=node18).errors.txt#_snippet_3

LANGUAGE: JSON
CODE:
```
{
  "name": "just-types-versions",
  "version": "1.0.0",
  "typesVersions": {
    "*": {
      "foo": ["./types/foo.d.ts"]
    }
  }
}
```

----------------------------------------

TITLE: Defining React-like Component Base Types in TypeScript
DESCRIPTION: These interfaces and classes define the fundamental structure for React-like components, distinguishing between class components (`Component`, `ComponentClass`) and functional components (`FunctionComponent`). The `ComponentType` union type provides a unified type for either kind of component, serving as a base for further type manipulations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/circularlyConstrainedMappedTypeContainingConditionalNoInfiniteInstantiationDepth.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare class Component<P> {
    constructor(props: Readonly<P>);
    constructor(props: P, context?: any);
    readonly props: Readonly<P> & Readonly<{ children?: {} }>;
}
interface ComponentClass<P = {}> {
    new (props: P, context?: any): Component<P>;
    propTypes?: WeakValidationMap<P>;
    defaultProps?: Partial<P>;
    displayName?: string;
}
interface FunctionComponent<P = {}> {
    (props: P & { children?: {} }, context?: any): {} | null;
    propTypes?: WeakValidationMap<P>;
    defaultProps?: Partial<P>;
    displayName?: string;
}
type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;
```

----------------------------------------

TITLE: Assigning String Literals to Template Literal Types in TypeScript
DESCRIPTION: This snippet demonstrates the assignment of string literals to a variable typed as a template literal ``${number}.${number}.${number}``. It shows that a concrete string literal like `'1.1.1'` is assignable to this type. Furthermore, it illustrates various type assertions using different template literal patterns, confirming that specific parts of the string can be typed as `number` placeholders while maintaining compatibility with the overall structure.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/templateLiteralTypes3.errors.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function f2() {
    let x: `${number}.${number}.${number}`;
    x = '1.1.1';
    x = '1.1.1' as `1.1.${number}`;
    x = '1.1.1' as `1.${number}.1`;
    x = '1.1.1' as `1.${number}.${number}`;
    x = '1.1.1' as `${number}.1.1`;
    x = '1.1.1' as `${number}.1.${number}`;
    x = '1.1.1' as `${number}.${number}.1`;
    x = '1.1.1' as `${number}.${number}.${number}`;
}
```

----------------------------------------

TITLE: Function Expression Returning Type Parameter (Inferred) - TypeScript
DESCRIPTION: Shows a generic function expression where the return type is inferred from the type parameter 'T'. The type of 'T' is in turn inferred from the argument passed to the function during its invocation.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/functionImplementations.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
var n = function <T>(x: T) {
    return x;
} (4);
```

----------------------------------------

TITLE: Demonstrating Missing Required Prop Error with Aliased Component in TSX
DESCRIPTION: This snippet shows a TypeScript error (TS2322) when attempting to instantiate a React component (`<T />`) without providing a required property. `T` is an alias for `TestMod.Test`, which expects a `reqd` prop, but none is supplied.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/tsxAttributeResolution12.errors.txt#_snippet_2

LANGUAGE: TSX
CODE:
```
const T = TestMod.Test;
var t1 = <T />;
```

----------------------------------------

TITLE: Implementing `Foo` Class with Type Guard in TypeScript
DESCRIPTION: This class `Foo` is generic over a string type `T` and includes a `data` property that can be `T` or `undefined`. It features a `hasData` method acting as a user-defined type guard, which narrows `this` to `DatafulFoo<T>` when true, allowing safe access to `this.data` and its string methods like `toLocaleLowerCase`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/spreadObjectOrFalsy.errors.txt#_snippet_8

LANGUAGE: TypeScript
CODE:
```
class Foo<T extends string> {
    data: T | undefined;
    bar() {
        if (this.hasData()) {
            this.data.toLocaleLowerCase();
        }
    }
    hasData(): this is DatafulFoo<T> {
        return true;
    }
}
```

----------------------------------------

TITLE: Defining Async Disposable Interface in TypeScript
DESCRIPTION: This snippet defines the `MyAsyncDisposable` interface, which includes a `value` property and the `[Symbol.asyncDispose]()` method, making objects conforming to it asynchronously disposable. This interface is used for type checking `await using` declarations.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/usingDeclarationsWithObjectLiterals1.errors.txt#_snippet_4

LANGUAGE: TypeScript
CODE:
```
interface MyAsyncDisposable {
  value: number;
  [Symbol.asyncDispose](): Promise<void>;
}
```

----------------------------------------

TITLE: Basic Variable, Class, and Function Declaration in TypeScript
DESCRIPTION: This TypeScript snippet illustrates fundamental language constructs by defining a global variable 'a1', a class 'c1' with a public property 'p1', instantiating the class, and declaring a function 'f1' that returns the class instance. It serves as a simple example of basic TypeScript syntax.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/project/mapRootAbsolutePathSingleFileSpecifyOutputFile/node/mapRootAbsolutePathSingleFileSpecifyOutputFile.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
var a1 = 10;
class c1 {
    public p1: number;
}

var instance1 = new c1();
function f1() {
    return instance1;
}
```

----------------------------------------

TITLE: Configuring Inner Module Package.json for Exports in Node.js
DESCRIPTION: This JSON snippet defines the 'package.json' for an inner module named 'inner'. It uses the 'exports' field to specify entry points for CommonJS ('./cjs'), ECMAScript modules ('./mjs'), and a default entry ('.'). This allows the inner module to be imported by other modules in the project, providing clear resolution paths.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesPackageExports(module=node18).errors.txt#_snippet_8

LANGUAGE: JSON
CODE:
```
{
        "name": "inner",
        "private": true,
        "exports": {
            "./cjs": "./index.cjs",
            "./mjs": "./index.mjs",
            ".": "./index.js"
        }
    }
```

----------------------------------------

TITLE: Demonstrating Type Parameter Incompatibility in TypeScript
DESCRIPTION: This TypeScript function `foo<T,U>()` illustrates type incompatibility when attempting to assign function types with distinct, unconstrained generic parameters. The assignments `x = y` and `y = x` both result in a TS2322 error because TypeScript cannot guarantee that `T` and `U` are compatible, as they could be instantiated with arbitrary, unrelated types. This highlights the need for explicit type constraints (e.g., `U extends T`) or identical type parameters for successful assignment.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/typeParameterArgumentEquivalence2.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
function foo<T,U>() {
    var x: (item: U) => boolean;
    var y: (item: T) => boolean;
    x = y;  // Should be an error
    y = x;  // Shound be an error
}
```

----------------------------------------

TITLE: Defining foo Function - TypeScript
DESCRIPTION: This snippet defines a TypeScript function `foo` that takes a `greeting` string as input. It demonstrates how to create and return a new instance of the `Greeter` class, passing the provided greeting to its constructor.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationClasses.sourcemap.txt#_snippet_10

LANGUAGE: TypeScript
CODE:
```
function foo(greeting: string) {
    return new Greeter(greeting);
}
```

----------------------------------------

TITLE: Declaring Async Iterator Types for Await Using in TypeScript
DESCRIPTION: This snippet declares constant variables with different asynchronous iterator types (`AsyncIterator`, `AsyncIteratorObject`, `AsyncGenerator`) to be used as initializers for `await using` declarations. These declarations set up the context for testing the `await using` syntax.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/awaitUsingDeclarationsWithAsyncIteratorObject.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare const ai: AsyncIterator<string, undefined>;
declare const aio: AsyncIteratorObject<string, undefined, unknown>;
declare const ag: AsyncGenerator<string, void>;
```

----------------------------------------

TITLE: Using `createMachine` with Specific Event Handler in TypeScript
DESCRIPTION: Demonstrates how to use the `createMachine` function to define a state machine configuration. It sets up a schema with `FOO` and `BAR` event types and provides an `on` handler specifically for the `FOO` event, ensuring `ev.type` is correctly inferred as 'FOO'.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/contextualTypeFunctionObjectPropertyIntersection.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
createMachine({
  schema: {
    events: {} as { type: "FOO" } | { type: "BAR" },
  },
  on: {
    FOO: (ev) => {
      ev.type; // should be 'FOO'
    },
  },
});
```

----------------------------------------

TITLE: Root Package.json Configuration for ES Modules
DESCRIPTION: This `package.json` snippet configures the root package to be an ES module by setting `"type": "module"`. This crucial setting dictates how `.js` files within the package are interpreted by Node.js and TypeScript, enabling ES module syntax by default.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsPackagePatternExports(module=node18).errors.txt#_snippet_6

LANGUAGE: JSON
CODE:
```
{
    "name": "package",
    "private": true,
    "type": "module"
}
```

----------------------------------------

TITLE: Configuring Conditional Exports for TypeScript Packages (JSON)
DESCRIPTION: This JSON snippet defines conditional exports for a TypeScript package, typically found within the `exports` field of `package.json`. It specifies distinct paths for type definitions (`.d.mts`, `.d.cts`) and JavaScript implementations (`.mjs`, `.cjs`) based on the module resolution context (`import` for ESM, `require` for CommonJS) and environment (`types` for TypeScript, `node` for Node.js runtime).
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModulesAllowJsConditionalPackageExports(module=node18).errors.txt#_snippet_8

LANGUAGE: JSON
CODE:
```
"./types": {
    "types": {
        "import": "./index.d.mts",
        "require": "./index.d.cts"
    },
    "node": {
        "import": "./index.mjs",
        "require": "./index.cjs"
    }
}
```

----------------------------------------

TITLE: Array Destructuring with Default Values in TypeScript
DESCRIPTION: This snippet illustrates array destructuring assignment in TypeScript, where `primarySkillC` and `secondarySkillC` are assigned values from an array. Default values ('noSkill') are provided, which will be used if the corresponding element in the assigned array is `undefined`.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatementArrayBindingPatternDefaultValues2.sourcemap.txt#_snippet_13

LANGUAGE: TypeScript
CODE:
```
[primarySkillC = "noSkill", secondarySkillC = "noSkill"] = ["noSkill", "noSkill"]
```

----------------------------------------

TITLE: Exporting a Class (TypeScript)
DESCRIPTION: This snippet shows the correct way to export a class named `C` in TypeScript. Exporting a class makes it accessible to other modules, enabling modular code organization and reusability.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/invalidSyntaxNamespaceImportWithAMD.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export class C { }
```

----------------------------------------

TITLE: Complex Conditional Types and Utility Types for API Response Handling in TypeScript (#33568)
DESCRIPTION: This extensive snippet defines a set of interconnected types (`IRootResponse`, `IExportCallback`, `IRecord`, `IRecordResponse`, `IResponse`, `GetPropertyNamesOfType`, `GetAllPropertiesOfType`) and functions (`save`, `exportCommand`) to model a flexible API response handling system. It showcases advanced TypeScript features like conditional types, mapped types, and utility types (`Pick`, `Required`, `Extract`) to achieve type-safe property access and function callbacks, addressing a scenario from GitHub issue #33568.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/conditionalTypes2.errors.txt#_snippet_34

LANGUAGE: TypeScript
CODE:
```
declare function save(_response: IRootResponse<string>): void;

exportCommand(save);

declare function exportCommand<TResponse>(functionToCall: IExportCallback<TResponse>): void;

interface IExportCallback<TResponse> {
	(response: IRootResponse<TResponse>): void;
}

type IRootResponse<TResponse> =
	TResponse extends IRecord ? IRecordResponse<TResponse> : IResponse<TResponse>;

interface IRecord {
	readonly Id: string;
}

declare type IRecordResponse<T extends IRecord> = IResponse<T> & {
	sendRecord(): void;
};

declare type IResponse<T> = {
	sendValue(name: keyof GetAllPropertiesOfType<T, string>): void;
};

declare type GetPropertyNamesOfType<T, RestrictToType> = {
	[PropertyName in Extract<keyof T, string>]: T[PropertyName] extends RestrictToType ? PropertyName : never
}[Extract<keyof T, string>];

declare type GetAllPropertiesOfType<T, RestrictToType> = Pick<
	T,
	GetPropertyNamesOfType<Required<T>, RestrictToType>
>;
```

----------------------------------------

TITLE: Demonstrating TypeScript Type Mismatch Errors
DESCRIPTION: This snippet imports objects from `items.ts` and attempts to pass them to a function `nFoo` that expects an argument of type `IFoo`. Since `IFoo` requires a `foo: string` property and the imported objects only have `foob: string`, TypeScript correctly flags `TS2345` errors, indicating a property is missing.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/exportDefaultStripsFreshness.errors.txt#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import B, {q} from "./items";
    
interface IFoo {
    foo: string;
}
    
function nFoo(x: IFoo) {}
    
    
nFoo(q); // for comparison
nFoo(B);
```

----------------------------------------

TITLE: Illustrating TS7013 Implicit Any Error in TypeScript Interface Constructor
DESCRIPTION: This snippet demonstrates the TS7013 error in TypeScript. A construct signature within the 'Entry' interface, 'new ()', lacks a return type annotation. When 'noImplicitAny' is enabled, TypeScript flags this as an error because the constructor implicitly returns 'any', promoting explicit type declarations for better type safety.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/noImplicitAnyForwardReferencedInterface.errors.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
declare var x: Entry;

interface Entry {
    // Should return error for implicit any.
    new ();
}
```

----------------------------------------

TITLE: TypeScript Source: Object Literal Destructuring
DESCRIPTION: This TypeScript snippet demonstrates object destructuring directly from an object literal. It declares a variable 'c' of type 'string' and then extracts 'name' and 'skill' properties from the inline object '{ name: "Edger", skill: "cutting edges" }', assigning them to 'nameC' and 'skillC'. This is the source code that compiles to the corresponding emitted JavaScript.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringVariableStatement1.sourcemap.txt#_snippet_7

LANGUAGE: TypeScript
CODE:
```
var c: string,
{ name: nameC, skill: skillC } = { name: "Edger", skill: "cutting edges" };
```

----------------------------------------

TITLE: Iterating with Destructuring and Default Values in TypeScript
DESCRIPTION: This TypeScript snippet illustrates a `for...of` loop iterating over an array `[robotA, robotB]`. It uses array destructuring to extract `numberA2`, `nameA2`, and `skillA2` from each element, providing default values (`-1`, `"noName"`, `"skill"`) if the corresponding properties are undefined.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/sourceMapValidationDestructuringForOfArrayBindingPatternDefaultValues.sourcemap.txt#_snippet_52

LANGUAGE: TypeScript
CODE:
```
for (let [numberA2 = -1, nameA2 = "noName", skillA2 = "skill"] of [robotA, robotB]) {
```

----------------------------------------

TITLE: Dynamic Import with Missing Extension (Another Subfolder)
DESCRIPTION: This snippet illustrates a dynamic 'import()' call for another subfolder without an explicit file extension. When 'moduleResolution' is 'node16' or 'nodenext', the ECMAScript resolver requires explicit extensions, suggesting a '.mjs' extension might resolve the issue.
SOURCE: https://github.com/microsoft/typescript/blob/main/tests/baselines/reference/nodeModules1(module=nodenext).errors.txt#_snippet_17

LANGUAGE: TypeScript
CODE:
```
const _m40 = import("./subfolder2");
```
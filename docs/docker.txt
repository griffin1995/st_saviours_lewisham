TITLE: Full Docker Daemon Configuration Example (Windows)
DESCRIPTION: This snippet provides a comprehensive example of all available configuration options for the Docker daemon's `daemon.json` file on Windows. It illustrates the structure and typical values for various settings, including authorization plugins, bridge networks, containerd paths, data roots, debugging, network options, runtimes, ulimits, DNS settings, execution options, experimental features, fixed CIDR, group, host gateway IP, hosts, insecure registries, labels, logging, concurrent limits, MTU, PID file, raw logs, registry mirrors, shutdown timeout, storage drivers, swarm settings, and TLS configurations.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/dockerd.md#_snippet_51

LANGUAGE: json
CODE:
```
{
  "authorization-plugins": [],
  "bridge": "",
  "containerd": "\\.\pipe\containerd-containerd",
  "containerd-namespace": "docker",
  "containerd-plugins-namespace": "docker-plugins",
  "data-root": "",
  "debug": true,
  "default-network-opts": {},
  "default-runtime": "",
  "default-ulimits": {},
  "dns": [],
  "dns-opts": [],
  "dns-search": [],
  "exec-opts": [],
  "experimental": false,
  "features": {},
  "fixed-cidr": "",
  "group": "",
  "host-gateway-ip": "",
  "hosts": [],
  "insecure-registries": [],
  "labels": [],
  "log-driver": "",
  "log-format": "text",
  "log-level": "",
  "max-concurrent-downloads": 3,
  "max-concurrent-uploads": 5,
  "max-download-attempts": 5,
  "mtu": 0,
  "pidfile": "",
  "raw-logs": false,
  "registry-mirrors": [],
  "shutdown-timeout": 15,
  "storage-driver": "",
  "storage-opts": [],
  "swarm-default-advertise-addr": "",
  "tlscacert": "",
  "tlscert": "",
  "tlskey": "",
  "tlsverify": true
}
```

----------------------------------------

TITLE: Run Bash in Docker Compose Service
DESCRIPTION: Demonstrates how to run a one-time `bash` command within the `web` service container defined in your Docker Compose configuration.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_run.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker compose run web bash
```

----------------------------------------

TITLE: Build Docker Image for Python Flask Application
DESCRIPTION: Provides instructions for Docker to build a container image for the Flask application. It sets up the Python environment, installs dependencies from `requirements.txt`, copies the application code, and configures the container to run the Flask development server on port 5000.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/gettingstarted.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM python:3.10-alpine
WORKDIR /code
ENV FLASK_APP=app.py
ENV FLASK_RUN_HOST=0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
EXPOSE 5000
COPY . .
CMD ["flask", "run", "--debug"]
```

----------------------------------------

TITLE: Docker Compose Configuration for Python Application
DESCRIPTION: This `compose.yaml` file defines a Docker Compose service named 'server'. It specifies that the service should be built from the Dockerfile in the current directory and maps port 8000 from the container to the host, making the application accessible.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/containerize.md#_snippet_5

LANGUAGE: yaml
CODE:
```
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    ports:
      - 8000:8000
```

----------------------------------------

TITLE: Create a basic multi-stage Dockerfile for Go application
DESCRIPTION: This Dockerfile demonstrates a fundamental multi-stage build. It compiles a Go 'hello, world' application in the first stage using a `golang` base image, then copies only the resulting binary into a minimal `scratch` image in the second stage. This approach significantly reduces the final image size by excluding build tools and intermediate artifacts.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-stage.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM golang:{{% param "example_go_version" %}}
WORKDIR /src
COPY <<EOF ./main.go
package main

import "fmt"

func main() {
  fmt.Println("hello, world")
}
EOF
RUN go build -o /bin/hello ./main.go

FROM scratch
COPY --from=0 /bin/hello /bin/hello
CMD ["/bin/hello"]
```

----------------------------------------

TITLE: Define GitHub Actions Workflow for Docker CI/CD
DESCRIPTION: This YAML configuration outlines a GitHub Actions workflow that automates the build, test, and push process for a Docker image. It logs into Docker Hub using secrets, sets up Docker Buildx, builds and tests the image, and finally builds and pushes the multi-platform image to Docker Hub, tagging it with the repository name and 'latest'.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/php/configure-ci-cd.md#_snippet_1

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and test
        uses: docker/build-push-action@v6
        with:
          target: test
          load: true

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          target: final
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Define GitHub Actions Workflow for Docker Build and Push
DESCRIPTION: This YAML configuration defines a GitHub Actions workflow named 'ci'. It triggers on pushes to the `main` branch, runs on `ubuntu-latest`, logs into Docker Hub using provided credentials, sets up Docker Buildx, and then builds and pushes the Docker image to Docker Hub for both `linux/amd64` and `linux/arm64` platforms. The image is tagged with the Docker username and repository name.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/cpp/configure-ci-cd.md#_snippet_2

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Define and use named build stages in a Dockerfile
DESCRIPTION: This Dockerfile illustrates how to name build stages using `AS <NAME>` in the `FROM` instruction. Naming stages (e.g., `AS build`) improves readability and makes `COPY --from` instructions more robust, as they refer to names instead of potentially changing integer indices.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-stage.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM golang:{{% param "example_go_version" %}} AS build
WORKDIR /src
COPY <<EOF /src/main.go
package main

import "fmt"

func main() {
  fmt.Println("hello, world")
}
EOF
RUN go build -o /bin/hello ./main.go

FROM scratch
COPY --from=build /bin/hello /bin/hello
CMD ["/bin/hello"]
```

----------------------------------------

TITLE: Building and Serving React App with Multi-Stage Dockerfile
DESCRIPTION: This Dockerfile defines a multi-stage build process for a React.js application. The first stage ('builder') compiles the React app, while the second stage ('runner') uses Nginx to serve the static build output, ensuring a small, secure, and efficient final image. It leverages build arguments for versioning and copies the Nginx configuration.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/containerize.md#_snippet_6

LANGUAGE: Dockerfile
CODE:
```
ARG NODE_VERSION=22.14.0-alpine
ARG NGINX_VERSION=alpine3.21

# Use a lightweight Node.js image for building (customizable via ARG)
FROM node:${NODE_VERSION} AS builder

# Set the working directory inside the container
WORKDIR /app

# Copy package-related files first to leverage Docker's caching mechanism
COPY package.json package-lock.json ./

# Install project dependencies using npm ci (ensures a clean, reproducible install)
RUN --mount=type=cache,target=/root/.npm npm ci

# Copy the rest of the application source code into the container
COPY . .

# Build the React.js application (outputs to /app/dist)
RUN npm run build

# =========================================
# Stage 2: Prepare Nginx to Serve Static Files
# =========================================

FROM nginxinc/nginx-unprivileged:${NGINX_VERSION} AS runner

# Use a built-in non-root user for security best practices
USER nginx

# Copy custom Nginx config
COPY nginx.conf /etc/nginx/nginx.conf

# Copy the static build output from the build stage to Nginx's default HTML serving directory
COPY --chown=nginx:nginx  --from=builder /app/dist /usr/share/nginx/html

# Expose port 8080 to allow HTTP traffic
# Note: The default NGINX container now listens on port 8080 instead of 80 
EXPOSE 8080

# Start Nginx directly with custom config
ENTRYPOINT ["nginx", "-c", "/etc/nginx/nginx.conf"]
CMD ["-g", "daemon off;"]
```

----------------------------------------

TITLE: Docker Compose Service Startup Order with depends_on and healthcheck
DESCRIPTION: This Docker Compose example illustrates how to define service dependencies and control their startup order. It uses `depends_on` with `condition: service_healthy` for the `db` service, requiring it to pass its `healthcheck` before the `web` service starts. It also shows `condition: service_started` for `redis` and `restart: true` to ensure dependent services restart when their dependencies are updated. The `healthcheck` for PostgreSQL (`db`) is defined using `pg_isready`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/startup-order.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
        restart: true
      redis:
        condition: service_started
  redis:
    image: redis
  db:
    image: postgres
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      retries: 5
      start_period: 30s
      timeout: 10s
```

----------------------------------------

TITLE: Building and Running Services with Docker Compose
DESCRIPTION: This command builds and starts all services defined in the `docker-compose.yml` file. It creates networks, containers, and attaches to their logs, allowing the services to run together.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/go-prometheus-monitoring/compose.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker compose up
```

----------------------------------------

TITLE: Dockerfile for Secret Mount with GITHUB_TOKEN
DESCRIPTION: This Dockerfile demonstrates how to use a build secret, specifically GITHUB_TOKEN, by mounting it into the build container. The RUN --mount=type=secret,id=github_token,env=GITHUB_TOKEN instruction makes the secret available as an environment variable during the build process.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/secrets.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine
RUN --mount=type=secret,id=github_token,env=GITHUB_TOKEN ...
```

----------------------------------------

TITLE: Dockerfile RUN: Combining apt-get update and install
DESCRIPTION: Emphasizes the best practice of combining `apt-get update` and `apt-get install` into a single `RUN` instruction. This prevents caching issues and ensures the installation of the latest package versions in Debian-based Docker images.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_9

LANGUAGE: dockerfile
CODE:
```
RUN apt-get update && apt-get install -y --no-install-recommends \
    package-bar \
    package-baz \
    package-foo
```

----------------------------------------

TITLE: Map Container Port 80 to Host Port 80
DESCRIPTION: Demonstrates how to map a container's port 80 to the host's port 80 using the `-p` argument when running an Nginx container. This makes the service running inside the container accessible on the host's localhost:80.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/features/networking.md#_snippet_0

LANGUAGE: console
CODE:
```
docker run -p 80:80 -d nginx
```

----------------------------------------

TITLE: Run MySQL Container with Port Mapping via Docker CLI
DESCRIPTION: Launches a new MySQL Docker container, mapping host port 3307 to container port 3306. It also sets the container name to 'my-mysql' and configures the root password and database name using environment variables.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_4

LANGUAGE: console
CODE:
```
docker run -p 3307:3306 --name my-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=mydb -d mysql:latest
```

----------------------------------------

TITLE: GitHub Actions Workflow for Docker Build and Push
DESCRIPTION: This YAML configuration defines a GitHub Actions workflow named 'ci'. It triggers on pushes to the `main` branch, logs into Docker Hub using secrets and variables, sets up Docker Buildx, and then builds and pushes the Docker image to Docker Hub with a tag based on the Docker username and repository name.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/configure-ci-cd.md#_snippet_2

LANGUAGE: YAML
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Kubernetes YAML for Rust Application and PostgreSQL Deployment
DESCRIPTION: This YAML file defines the Kubernetes resources required to deploy a Rust application and its PostgreSQL database. It includes two Deployment objects (one for the Rust server and one for PostgreSQL) and two Service objects to expose them. The Rust server deployment includes an initContainer to ensure the database is ready before the application starts.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/deploy.md#_snippet_0

LANGUAGE: YAML
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    service: server
  name: server
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: server
  strategy: {}
  template:
    metadata:
      labels:
        service: server
    spec:
      initContainers:
        - name: wait-for-db
          image: busybox:1.28
          command:
            [
              "sh",
              "-c",
              'until nc -zv db 5432; do echo "waiting for db"; sleep 2; done;',
            ]
      containers:
        - image: DOCKER_USERNAME/REPO_NAME
          name: server
          imagePullPolicy: Always
          ports:
            - containerPort: 8000
              hostPort: 5000
              protocol: TCP
          env:
            - name: ADDRESS
              value: 0.0.0.0:8000
            - name: PG_DBNAME
              value: example
            - name: PG_HOST
              value: db
            - name: PG_PASSWORD
              value: mysecretpassword
            - name: PG_USER
              value: postgres
            - name: RUST_LOG
              value: debug
          resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    service: db
  name: db
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: db
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        service: db
    spec:
      containers:
        - env:
            - name: POSTGRES_DB
              value: example
            - name: POSTGRES_PASSWORD
              value: mysecretpassword
            - name: POSTGRES_USER
              value: postgres
          image: postgres
          name: db
          ports:
            - containerPort: 5432
              protocol: TCP
          resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: server
  name: server
  namespace: default
spec:
  type: NodePort
  ports:
    - name: "5000"
      port: 5000
      targetPort: 8000
      nodePort: 30001
  selector:
    service: server
status:
  loadBalancer: {}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: db
  name: db
  namespace: default
spec:
  ports:
    - name: "5432"
      port: 5432
      targetPort: 5432
  selector:
    service: db
status:
  loadBalancer: {}
```

----------------------------------------

TITLE: Interact with Detached Docker Containers
DESCRIPTION: Demonstrates common commands to interact with a container running in the background. This includes `docker ps` to list running containers, `docker logs` to view the container's output, and `docker attach` to re-attach to its standard I/O streams.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker run -d nginx
0246aa4d1448a401cabd2ce8f242192b6e7af721527e48a810463366c7ff54f1
$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS        PORTS     NAMES
0246aa4d1448   nginx     "/docker-entrypoint.…"   2 seconds ago   Up 1 second   80/tcp    pedantic_liskov
$ docker logs -n 5 0246aa4d1448
2023/11/06 15:58:23 [notice] 1#1: start worker process 33
2023/11/06 15:58:23 [notice] 1#1: start worker process 34
2023/11/06 15:58:23 [notice] 1#1: start worker process 35
2023/11/06 15:58:23 [notice] 1#1: start worker process 36
2023/11/06 15:58:23 [notice] 1#1: start worker process 37
$ docker attach 0246aa4d1448
^C
2023/11/06 15:58:40 [notice] 1#1: signal 2 (SIGINT) received, exiting
```

----------------------------------------

TITLE: Configure GitHub Actions for Docker Build Cloud
DESCRIPTION: This YAML configuration demonstrates how to set up a GitHub Actions workflow to use Docker Build Cloud. It includes steps for logging into Docker Hub, setting up Docker Buildx with the cloud driver, and building/pushing an image. It conditionally pushes to a registry or exports to cache based on the event type (pull request vs. push).
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build-cloud/ci.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - "main"

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PAT }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: cloud
          endpoint: "<ORG>/default"
          install: true
      
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          tags: "<IMAGE>"
          # For pull requests, export results to the build cache.
          # Otherwise, push to a registry.
          outputs: ${{ github.event_name == 'pull_request' && 'type=cacheonly' || 'type=registry' }}
```

----------------------------------------

TITLE: Run Docker Rust Image with Port Publishing
DESCRIPTION: Runs the Docker Rust image and publishes container port 8000 to host port 3001 using the `--publish` (or `-p`) flag. This allows external access to the application running inside the container via the specified host port.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/run-containers.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker run --publish 3001:8000 docker-rust-image
```

----------------------------------------

TITLE: Start Docker Compose Application
DESCRIPTION: Initiates and starts all services defined in the `compose.yaml` file. This command creates and configures networks, volumes, and services as specified, bringing the entire application stack online.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/intro/compose-application-model.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker compose up
```

----------------------------------------

TITLE: Run Hello World Docker Container in Console
DESCRIPTION: Demonstrates running the 'hello-world' Docker image directly in a console environment.
SOURCE: https://github.com/docker/docs/blob/main/content/contribute/components/accordions.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker run hello-world
```

----------------------------------------

TITLE: Authenticate Docker Hub using Docker Engine
DESCRIPTION: For standalone Docker Engine installations, authenticate with Docker Hub by running the `docker login` command from a terminal. This command securely signs you into your Docker Hub account.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/docker-hub/usage/pulls.md#_snippet_0

LANGUAGE: APIDOC
CODE:
```
docker login
```

----------------------------------------

TITLE: Map Container Port 80 to Custom Host Port 8000
DESCRIPTION: Illustrates how to map a container's port 80 to a different host port (8000) to avoid conflicts. Connections to `localhost:8000` on the host will be forwarded to port 80 inside the Nginx container.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/features/networking.md#_snippet_1

LANGUAGE: console
CODE:
```
docker run -p 8000:80 -d nginx
```

----------------------------------------

TITLE: Run second Postgres Docker container instance with port override
DESCRIPTION: Starts another Postgres container in the background, setting a password and mapping its internal port `5432` to host port `5433`. This demonstrates overriding the host port to prevent conflicts with an already running instance of the same container, allowing multiple instances to coexist.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/overriding-container-defaults.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker run -d -e POSTGRES_PASSWORD=secret -p 5433:5432 postgres
```

----------------------------------------

TITLE: Run Docker image in foreground
DESCRIPTION: Execute a Docker image as a container. This command runs the container in the foreground, keeping the terminal attached until the container is stopped manually. The output shows the application starting.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/run-containers.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker run docker-gs-ping
```

LANGUAGE: text
CODE:
```
   ____    __
  / __/___/ /  ___
 / _// __/ _ \\/ _ \\
/___/\\__/_//_/\\___/ v4.10.2
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O\
⇨ http server started on [::]:8080
```

----------------------------------------

TITLE: Example Dockerfile for Image Layering
DESCRIPTION: This Dockerfile illustrates how various instructions contribute to the layered structure of a Docker image. It demonstrates that commands like `FROM`, `COPY`, and `RUN` create new layers, while `LABEL` and `CMD` primarily modify metadata without adding new layers. The example also highlights that removing files still results in a new layer, contributing to the overall image size.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/drivers/_index.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM ubuntu:22.04
LABEL org.opencontainers.image.authors="org@example.com"
COPY . /app
RUN make /app
RUN rm -r $HOME/.cache
CMD python /app/app.py
```

----------------------------------------

TITLE: Docker Compose Configuration for Node.js with PostgreSQL and Secrets
DESCRIPTION: This YAML configuration defines a multi-service Docker application including a Node.js server and a PostgreSQL database. It demonstrates the use of Docker secrets for securely managing the database password, ensures data persistence with a named volume, and sets up health checks for the database service.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/develop.md#_snippet_2

LANGUAGE: yaml
CODE:
```
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    environment:
      NODE_ENV: production
      POSTGRES_HOST: db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD_FILE: /run/secrets/db-password
      POSTGRES_DB: example
    ports:
      - 3000:3000

    # The commented out section below is an example of how to define a PostgreSQL
    # database that your application can use. `depends_on` tells Docker Compose to
    # start the database before your application. The `db-data` volume persists the
    # database data between container restarts. The `db-password` secret is used
    # to set the database password. You must create `db/password.txt` and add
    # a password of your choosing to it before running `docker compose up`.

    depends_on:
      db:
        condition: service_healthy
    secrets:
      - db-password
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Configure Ollama Service with GPU Access in Docker Compose
DESCRIPTION: This `compose.yaml` snippet defines the `ollama` service, pulling the `ollama/ollama:latest` image and exposing port 11434. It mounts a named volume (`ollama_volume`) for persistent data and configures GPU access for the container using the `nvidia` driver and `gpu` capabilities, essential for accelerated LLM inference. This setup is recommended for Linux with Docker Engine or Windows 10/11 with Docker Desktop and a CUDA-supported GPU.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/genai-pdf-bot/develop.md#_snippet_2

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
    ports:
      - 8000:8000
    env_file:
      - .env
    depends_on:
      database:
        condition: service_healthy
  database:
    image: neo4j:5.11
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=${NEO4J_USERNAME}/${NEO4J_PASSWORD}
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "wget --no-verbose --tries=1 --spider localhost:7474 || exit 1",
        ]
      interval: 5s
      timeout: 3s
      retries: 5
  ollama:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_volume:/root/.ollama
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
volumes:
  ollama_volume:
```

----------------------------------------

TITLE: Run Docker Compose Application in Foreground
DESCRIPTION: Executes the `docker compose up` command to build images and start services defined in the `docker-compose.yaml` file. The `--build` flag ensures images are rebuilt if necessary. The application runs in the foreground, displaying logs in the terminal.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/containerize.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Define GitHub Actions Workflow for Docker Build and Push
DESCRIPTION: This YAML configuration defines a GitHub Actions workflow named 'ci' that triggers on pushes to the `main` branch. It logs into Docker Hub, sets up Docker Buildx, and then builds and pushes a Docker image for `linux/amd64` and `linux/arm64` platforms to Docker Hub, tagging it with the Docker username and repository name.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/deno/configure-ci-cd.md#_snippet_2

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      -
        name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      -
        name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Define Docker Compose services for MySQL and phpMyAdmin
DESCRIPTION: This YAML configuration defines two services: `db` for a MySQL database and `phpmyadmin` for a phpMyAdmin interface. It sets up environment variables for database initialization and connection, maps host ports to container ports, and uses a named volume for persistent database storage. The phpMyAdmin service is configured to connect to the `db` service using its service name.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_24

LANGUAGE: yaml
CODE:
```
services:
  db:
    image: mysql:latest
    environment:
      MYSQL_ROOT_PASSWORD: my-secret-pw
      MYSQL_DATABASE: mydb
    ports:
      - 3307:3306
    volumes:
      - my-db-volume:/var/lib/mysql

  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest
    environment:
      PMA_HOST: db
      PMA_PORT: 3306
      MYSQL_ROOT_PASSWORD: my-secret-pw
    ports:
      - 8080:80
    depends_on:
      - db

volumes:
  my-db-volume:
```

----------------------------------------

TITLE: Run Docker Container using CLI
DESCRIPTION: Demonstrates how to start a Docker container in detached mode, mapping container port 80 to host port 8080, using the `docker run` command. The command outputs the full container ID upon successful execution.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-container.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker run -d -p 8080:80 docker/welcome-to-docker
```

----------------------------------------

TITLE: Verifying Docker Installation with Hello-World - Console
DESCRIPTION: This command verifies a successful Docker installation by running the `hello-world` test image. Docker downloads the image, creates and runs a container, which then prints a confirmation message to the console before exiting, indicating that Docker Engine is operational.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/debian.md#_snippet_6

LANGUAGE: console
CODE:
```
$ sudo docker run hello-world
```

----------------------------------------

TITLE: Start a Postgres container with a named volume
DESCRIPTION: Starts a PostgreSQL database container in detached mode, setting a password, and mounting a volume named `postgres_data` to the default data directory of PostgreSQL. This ensures database files persist across container restarts.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/persisting-container-data.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker run --name=db -e POSTGRES_PASSWORD=secret -d -v postgres_data:/var/lib/postgresql/data postgres
```

----------------------------------------

TITLE: List Running Docker Containers
DESCRIPTION: This command displays a table of all currently running Docker containers, showing details such as ID, image, command, status, exposed ports, and assigned names. It helps in monitoring active container instances.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/run-containers.md#_snippet_6

LANGUAGE: console
CODE:
```
CONTAINER ID   IMAGE                   COMMAND         CREATED         STATUS         PORTS                    NAMES
3074745e412c   docker-rust-image       "/bin/server"   8 seconds ago   Up 7 seconds   0.0.0.0:3001->8000/tcp   wonderful_kalam
```

----------------------------------------

TITLE: Build and Push DHI-based Docker Image
DESCRIPTION: This command builds the Docker image from the Dockerfile and pushes it to your Docker Hub repository, tagging it for version control.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/dhi/how-to/policies.md#_snippet_1

LANGUAGE: console
CODE:
```
docker build \
  --push \
  -t YOUR_ORG/my-dhi-app:v1 .
```

----------------------------------------

TITLE: Deploy Application to Kubernetes
DESCRIPTION: Deploys the application defined in 'docker-rust-kubernetes.yaml' to a Kubernetes cluster using kubectl.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/deploy.md#_snippet_1

LANGUAGE: console
CODE:
```
$ kubectl apply -f docker-rust-kubernetes.yaml
```

----------------------------------------

TITLE: Standard .dockerignore File for Docker Builds
DESCRIPTION: This snippet provides the recommended contents for a `.dockerignore` file. It specifies files and directories that should be excluded from the Docker build context, preventing unnecessary data from being copied into the container image. This helps optimize build times and reduce image size. It includes common patterns for various development environments.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_6

LANGUAGE: dockerignore
CODE:
```
# Include any files or directories that you don't want to be copied to your
# container here (e.g., local build artifacts, temporary files, etc.).
#
# For more help, visit the .dockerignore file reference guide at
# https://docs.docker.com/go/build-context-dockerignore/

**/.DS_Store
**/__pycache__
**/.venv
**/.classpath
**/.dockerignore
**/.env
**/.git
**/.gitignore
**/.project
**/.settings
**/.toolstarget
**/.vs
**/*.*proj.user
**/*.dbmdl
**/*.jfm
**/bin
**/charts
**/docker-compose*
**/compose.y*ml
**/Dockerfile*
**/node_modules
**/npm-debug.log
**/obj
**/secrets.dev.yaml
**/values.dev.yaml
LICENSE
README.md
```

----------------------------------------

TITLE: Defining Production Docker Compose Services
DESCRIPTION: This YAML snippet defines a Docker Compose configuration for a production environment, orchestrating multiple services like Nginx (web), PHP-FPM, PHP-CLI, PostgreSQL, and Redis. It includes detailed configurations for builds, volume mounts (e.g., read-only for Nginx, writable for PHP-FPM), network connectivity, port exposure, environment variables, and crucial health checks to ensure service readiness and dependencies are met before startup.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/production-setup.md#_snippet_14

LANGUAGE: yaml
CODE:
```
services:
  web:
    build:
      context: .
      dockerfile: ./docker/production/nginx/Dockerfile
    restart: unless-stopped # Automatically restart unless the service is explicitly stopped
    volumes:
      # Mount the 'laravel-storage' volume to '/var/www/storage' inside the container.
      # -----------------------------------------------------------
      # This volume stores persistent data like uploaded files and cache.
      # The ':ro' option mounts it as read-only in the 'web' service because Nginx only needs to read these files.
      # The 'php-fpm' service mounts the same volume without ':ro' to allow write operations.
      # -----------------------------------------------------------
      - laravel-storage-production:/var/www/storage:ro
    networks:
      - laravel-production
    ports:
      # Map port 80 inside the container to the port specified by 'NGINX_PORT' on the host machine.
      # -----------------------------------------------------------
      # This allows external access to the Nginx web server running inside the container.
      # For example, if 'NGINX_PORT' is set to '8080', accessing 'http://localhost:8080' will reach the application.
      # -----------------------------------------------------------
      - "${NGINX_PORT:-80}:80"
    depends_on:
      php-fpm:
        condition: service_healthy # Wait for php-fpm health check

  php-fpm:
    # For the php-fpm service, we will create a custom image to install the necessary PHP extensions and setup proper permissions.
    build:
      context: .
      dockerfile: ./docker/common/php-fpm/Dockerfile
      target: production # Use the 'production' stage in the Dockerfile
    restart: unless-stopped
    volumes:
      - laravel-storage-production:/var/www/storage # Mount the storage volume
    env_file:
      - .env
    networks:
      - laravel-production
    healthcheck:
      test: ["CMD-SHELL", "php-fpm-healthcheck || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 3
    # The 'depends_on' attribute with 'condition: service_healthy' ensures that
    # this service will not start until the 'postgres' service passes its health check.
    # This prevents the application from trying to connect to the database before it's ready.
    depends_on:
      postgres:
        condition: service_healthy

  # The 'php-cli' service provides a command-line interface for running Artisan commands and other CLI tasks.
  # -----------------------------------------------------------
  # This is useful for running migrations, seeders, or any custom scripts.
  # It shares the same codebase and environment as the 'php-fpm' service.
  # -----------------------------------------------------------
  php-cli:
    build:
      context: .
      dockerfile: ./docker/php-cli/Dockerfile
    tty: true # Enables an interactive terminal
    stdin_open: true # Keeps standard input open for 'docker exec'
    env_file:
      - .env
    networks:
      - laravel

  postgres:
    image: postgres:16
    restart: unless-stopped
    user: postgres
    ports:
      - "${POSTGRES_PORT}:5432"
    environment:
      - POSTGRES_DB=${POSTGRES_DATABASE}
      - POSTGRES_USER=${POSTGRES_USERNAME}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres-data-production:/var/lib/postgresql/data
    networks:
      - laravel-production
    # Health check for PostgreSQL
    # -----------------------------------------------------------
    # Health checks allow Docker to determine if a service is operational.
    # The 'pg_isready' command checks if PostgreSQL is ready to accept connections.
    # This prevents dependent services from starting before the database is ready.
    # -----------------------------------------------------------
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:alpine
    restart: unless-stopped # Automatically restart unless the service is explicitly stopped
    networks:
      - laravel-production
    # Health check for Redis
    # -----------------------------------------------------------
    # Checks if Redis is responding to the 'PING' command.
    # This ensures that the service is not only running but also operational.
    # -----------------------------------------------------------
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3

networks:
  # Attach the service to the 'laravel-production' network.
  # -----------------------------------------------------------
  # This custom network allows all services within it to communicate using their service names as hostnames.
```

----------------------------------------

TITLE: Sign in to Docker via CLI
DESCRIPTION: Demonstrates how to sign in to your Docker account from the command line using the `docker login` command. It also highlights security considerations regarding credential storage, noting that credentials are base64-encoded in `.docker/config.json`, and recommends using Docker credential helpers or personal access tokens for enhanced security.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/accounts/create-account.md#_snippet_0

LANGUAGE: Shell
CODE:
```
docker login
```

----------------------------------------

TITLE: Multi-stage Dockerfile for Go Application
DESCRIPTION: Presents a multi-stage Dockerfile for building and testing a Go application. It uses a `golang` base image for the build stage to compile the application, then copies the binary to a leaner image, and includes a separate stage for running tests.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/build-images.md#_snippet_20

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

# Build the application from source
FROM golang:1.19 AS build-stage

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY *.go ./

RUN CGO_ENABLED=0 GOOS=linux go build -o /docker-gs-ping

# Run the tests in the container
FROM build-stage AS run-test-stage
RUN go test -v ./...
```

----------------------------------------

TITLE: GitHub Actions Workflow for Docker Local Cache
DESCRIPTION: This GitHub Actions workflow demonstrates how to use `actions/cache` with Buildx's local cache exporter to manage Docker layer caching. It includes steps for Docker login, Buildx setup, caching Docker layers, building and pushing with local cache, and a workaround to move the new cache entries due to a known issue with growing cache size.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/cache.md#_snippet_8

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: ${{ runner.temp }}/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: user/app:latest
          cache-from: type=local,src=${{ runner.temp }}/.buildx-cache
          cache-to: type=local,dest=${{ runner.temp }}/.buildx-cache-new,mode=max

      - # Temp fix
        # https://github.com/docker/build-push-action/issues/252
        # https://github.com/moby/buildkit/issues/1896
        name: Move cache
        run: |
          rm -rf ${{ runner.temp }}/.buildx-cache
          mv ${{ runner.temp }}/.buildx-cache-new ${{ runner.temp }}/.buildx-cache
```

----------------------------------------

TITLE: Kubernetes YAML for .NET Application Deployment
DESCRIPTION: This YAML file defines the Kubernetes resources required to deploy a .NET application and its PostgreSQL database. It includes two Deployments (one for the .NET server and one for the database) and two Services (one NodePort for the server and one for the database), enabling local testing and debugging on Kubernetes. Remember to replace `DOCKER_USERNAME/REPO_NAME` with your actual Docker image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/dotnet/deploy.md#_snippet_0

LANGUAGE: YAML
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    service: server
  name: server
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: server
  strategy: {}
  template:
    metadata:
      labels:
        service: server
    spec:
      initContainers:
        - name: wait-for-db
          image: busybox:1.28
          command:
            [
              "sh",
              "-c",
              'until nc -zv db 5432; do echo "waiting for db"; sleep 2; done;',
            ]
      containers:
        - image: DOCKER_USERNAME/REPO_NAME
          name: server
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
              hostPort: 8080
              protocol: TCP
          resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    service: db
  name: db
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: db
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        service: db
    spec:
      containers:
        - env:
            - name: POSTGRES_DB
              value: example
            - name: POSTGRES_PASSWORD
              value: example
          image: postgres
          name: db
          ports:
            - containerPort: 5432
              protocol: TCP
          resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: server
  name: server
  namespace: default
spec:
  type: NodePort
  ports:
    - name: "8080"
      port: 8080
      targetPort: 8080
      nodePort: 30001
  selector:
    service: server
status:
  loadBalancer: {}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: db
  name: db
  namespace: default
spec:
  ports:
    - name: "5432"
      port: 5432
      targetPort: 5432
  selector:
    service: db
status:
  loadBalancer: {}
```

----------------------------------------

TITLE: Apply Docker cache mounts for various language package managers
DESCRIPTION: Provides examples of integrating Docker cache mounts with different programming language package managers (Go, Apt, Python, Ruby, Rust, .NET, PHP) to optimize build times. It highlights the importance of consulting specific tool documentation for correct cache mount options, such as `sharing=locked` for Apt due to its exclusive access requirements.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/optimize.md#_snippet_8

LANGUAGE: go
CODE:
```
RUN --mount=type=cache,target=/go/pkg/mod \
    go build -o /app/hello
```

LANGUAGE: apt
CODE:
```
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
  --mount=type=cache,target=/var/lib/apt,sharing=locked \
  apt update && apt-get --no-install-recommends install -y gcc
```

LANGUAGE: python
CODE:
```
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install -r requirements.txt
```

LANGUAGE: ruby
CODE:
```
RUN --mount=type=cache,target=/root/.gem \
    bundle install
```

LANGUAGE: rust
CODE:
```
RUN --mount=type=cache,target=/app/target/ \
    --mount=type=cache,target=/usr/local/cargo/git/db \
    --mount=type=cache,target=/usr/local/cargo/registry/ \
    cargo build
```

LANGUAGE: .net
CODE:
```
RUN --mount=type=cache,target=/root/.nuget/packages \
    dotnet restore
```

LANGUAGE: php
CODE:
```
RUN --mount=type=cache,target=/tmp/cache \
    composer install
```

----------------------------------------

TITLE: Dockerfile Set Environment Variables with ENV Instruction
DESCRIPTION: Sets an environment variable, FLASK_APP=hello, within the Docker image using the ENV instruction. This variable is crucial for the Flask framework to locate and run the application.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/dockerfile.md#_snippet_9

LANGUAGE: dockerfile
CODE:
```
ENV FLASK_APP=hello
```

----------------------------------------

TITLE: Define and Use a Simple Docker Compose Secret
DESCRIPTION: This example demonstrates how to define a simple secret at the top-level of your Compose file and grant a service access to it. The 'myapp' service is given access to 'my_secret', which is mounted as a file at '/run/secrets/my_secret' inside the container, containing the contents of './my_secret.txt'.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/use-secrets.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  myapp:
    image: myapp:latest
    secrets:
      - my_secret
secrets:
  my_secret:
    file: ./my_secret.txt
```

----------------------------------------

TITLE: List Running Docker Containers
DESCRIPTION: This command displays a list of all active Docker containers on your machine, similar to the `ps` command for Linux processes. It provides details such as container ID, image, command, creation time, status, exposed ports, and assigned names.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/run-containers.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker ps

CONTAINER ID   IMAGE            COMMAND             CREATED          STATUS          PORTS                    NAMES
d75e61fcad1e   docker-gs-ping   "/docker-gs-ping"   41 seconds ago   Up 40 seconds   0.0.0.0:8080->8080/tcp   inspiring_ishizaka
```

----------------------------------------

TITLE: Verify Docker Engine installation using hello-world image
DESCRIPTION: Confirms a successful Docker Engine installation by running the official `hello-world` image. This command downloads the image, executes it in a container, and prints a confirmation message upon completion.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/raspberry-pi-os.md#_snippet_5

LANGUAGE: bash
CODE:
```
$ sudo docker run hello-world
```

----------------------------------------

TITLE: Common Dockerfile Instructions Reference
DESCRIPTION: A reference list of common Dockerfile instructions, explaining their purpose, basic syntax, and typical usage within a Dockerfile. This section provides a quick overview for building container images.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/writing-a-dockerfile.md#_snippet_1

LANGUAGE: APIDOC
CODE:
```
FROM <image> - Specifies the base image that the build will extend.
WORKDIR <path> - Specifies the "working directory" or the path in the image where files will be copied and commands will be executed.
COPY <host-path> <image-path> - Tells the builder to copy files from the host and put them into the container image.
RUN <command> - Tells the builder to run the specified command.
ENV <name> <value> - Sets an environment variable that a running container will use.
EXPOSE <port-number> - Sets configuration on the image that indicates a port the image would like to expose.
USER <user-or-uid> - Sets the default user for all subsequent instructions.
CMD ["<command>", "<arg1>"] - Sets the default command a container using this image will run.
```

----------------------------------------

TITLE: FROM Instruction Syntax (Basic) in Dockerfile
DESCRIPTION: This snippet shows the basic syntax for the `FROM` instruction, which initializes a new build stage and sets the base image. It can optionally specify a platform and assign a name to the build stage for multi-stage builds.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_38

LANGUAGE: Dockerfile
CODE:
```
FROM [--platform=<platform>] <image> [AS <name>]
```

----------------------------------------

TITLE: GitHub Actions Workflow to Build and Push Docker Image
DESCRIPTION: This YAML workflow defines a CI/CD pipeline for a Dockerized application. It triggers on pushes to the `main` branch, logs into Docker Hub using repository variables and secrets, sets up Docker Buildx, and then builds and pushes the Docker image to Docker Hub with a `latest` tag, using the Docker username and repository name.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/configure-github-actions.md#_snippet_0

LANGUAGE: YAML
CODE:
```
name: Build and push Docker image

on:
  push:
    branches:
      - main

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Example: Publishing host port 8080 to container port 80
DESCRIPTION: This command provides a concrete example of publishing port 8080 on the host machine to port 80 within an Nginx container. Any traffic sent to host port 8080 will be forwarded to the Nginx application listening on port 80 inside the container.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/publishing-ports.md#_snippet_1

LANGUAGE: bash
CODE:
```
$ docker run -d -p 8080:80 nginx
```

----------------------------------------

TITLE: Initialize Docker Assets with Docker Init for Python
DESCRIPTION: Demonstrates using the `docker init` command to automatically generate Docker-related files for a Python application. It guides the user through the interactive prompts, specifying Python as the platform, version 3.11.4, port 8000, and the `uvicorn` command to run the FastAPI application.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/containerize.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

? What application platform does your project use? Python
? What version of Python do you want to use? 3.11.4
? What port do you want your app to listen on? 8000
? What is the command to run your app? python3 -m uvicorn app:app --host=0.0.0.0 --port=8000
```

----------------------------------------

TITLE: Pin Base Image Versions in Dockerfile
DESCRIPTION: Discusses the mutability of image tags and the benefits of pinning base image versions to specific digests in Dockerfiles to ensure consistent builds, prevent breaking changes, and maintain an audit trail for supply chain integrity.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_4

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine:3.21
```

----------------------------------------

TITLE: Complete Basic Dockerfile for Node.js Application
DESCRIPTION: Presents the full Dockerfile combining all essential instructions for a basic Node.js application: setting the base image, working directory, copying files, installing dependencies, and defining the startup command.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/writing-a-dockerfile.md#_snippet_7

LANGUAGE: dockerfile
CODE:
```
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "./src/index.js"]
```

----------------------------------------

TITLE: GitHub Actions Workflow for Go Project with BuildKit Cache Dance
DESCRIPTION: This GitHub Actions workflow integrates the `reproducible-containers/buildkit-cache-dance` action to persist BuildKit cache mounts between GitHub Actions runs. It includes steps for Docker login, QEMU setup, Buildx setup, Docker metadata, Go build cache, injecting the cache, and finally building and pushing the Docker image with GHA cache.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/cache.md#_snippet_7

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: user/app
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Go Build Cache for Docker
        uses: actions/cache@v4
        with:
          path: go-build-cache
          key: ${{ runner.os }}-go-build-cache-${{ hashFiles('**/go.sum') }}

      - name: Inject go-build-cache
        uses: reproducible-containers/buildkit-cache-dance@4b2444fec0c0fb9dbf175a96c094720a692ef810 # v2.1.4
        with:
          cache-source: go-build-cache

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          cache-from: type=gha
          cache-to: type=gha,mode=max
          file: build/package/Dockerfile
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64
```

----------------------------------------

TITLE: Build Docker Image from Current Directory
DESCRIPTION: This command builds a Docker image using the Dockerfile and other files in the current directory as the build context. The resulting image will not have a specific name, but an ID will be provided in the output.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/build-tag-and-publish-an-image.md#_snippet_0

LANGUAGE: bash
CODE:
```
docker build .
```

----------------------------------------

TITLE: Start Docker Compose Stack
DESCRIPTION: This console command starts all services defined in the `compose.yaml` file. It brings up the Kafka cluster and any other associated services, making them ready for use.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/kafka.md#_snippet_13

LANGUAGE: console
CODE:
```
$ docker compose up
```

----------------------------------------

TITLE: Build and Push Multi-platform Docker Image with GitHub Actions
DESCRIPTION: This GitHub Actions workflow demonstrates how to build and push a multi-platform Docker image to Docker Hub. It uses `docker/login-action` for authentication, `docker/setup-qemu-action` for QEMU emulation to support multiple architectures, and `docker/build-push-action` to build for `linux/amd64` and `linux/arm64` platforms and push the image.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/multi-platform.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: user/app:latest
```

----------------------------------------

TITLE: Optimized Dockerfile for Dependency Caching
DESCRIPTION: This Dockerfile is restructured to leverage Docker's layer caching more effectively. By copying only `package.json` and `yarn.lock` first, the `yarn install` step is cached and only re-executed if these dependency definition files change, significantly speeding up subsequent builds when only application code changes.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/09_image_best.md#_snippet_4

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM node:lts-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production
COPY . .
CMD ["node", "src/index.js"]
```

----------------------------------------

TITLE: Build a Docker image from a Dockerfile
DESCRIPTION: Use the `docker build` command to create a Docker image from a Dockerfile and a specified context. The `--tag` flag allows naming and versioning the image (e.g., `name:tag`), defaulting to 'latest' if not provided. The command requires a path to the build context, typically '.' for the current directory.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/build-images.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker build --tag docker-rust-image .
```

----------------------------------------

TITLE: Define and Use Docker Secrets in Compose
DESCRIPTION: This YAML configuration demonstrates how to define and use Docker secrets within a Docker Compose file to secure sensitive data for services like MySQL and WordPress. It shows how to declare secrets at the top level, link them to services, and configure services to read secret values from mounted files (e.g., /run/secrets/<secret_name>) using file-based environment variables.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/swarm/secrets.md#_snippet_49

LANGUAGE: yaml
CODE:
```
services:
   db:
     image: mysql:latest
     volumes:
       - db_data:/var/lib/mysql
     environment:
       MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD_FILE: /run/secrets/db_password
     secrets:
       - db_root_password
       - db_password

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - "8000:80"
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD_FILE: /run/secrets/db_password
     secrets:
       - db_password


secrets:
   db_password:
     file: db_password.txt
   db_root_password:
     file: db_root_password.txt

volumes:
    db_data:
```

----------------------------------------

TITLE: Build and push Docker image with Scout attestations
DESCRIPTION: This command builds a Docker image and pushes it to a registry. It includes `--provenance=true` and `--sbom=true` flags to attach build attestations, which enable more detailed analysis results from Docker Scout. Replace `<org>/<image:tag>` with your desired organization, image name, and tag.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/explore/analysis.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker build --push --tag <org>/<image:tag> --provenance=true --sbom=true .
```

----------------------------------------

TITLE: Set Working Directory in Dockerfile
DESCRIPTION: The `WORKDIR` instruction defines the working directory inside the Docker container. Subsequent commands like `COPY` and `RUN` will execute relative to this directory, which is set to `/app`.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/multi-stage-builds.md#_snippet_4

LANGUAGE: dockerfile
CODE:
```
WORKDIR /app
```

----------------------------------------

TITLE: docker compose logs command options
DESCRIPTION: Detailed options for the `docker compose logs` command, including their types, defaults, and descriptions for controlling log output.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_logs.md#_snippet_0

LANGUAGE: APIDOC
CODE:
```
Command: docker compose logs
Description: Displays log output from services

Options:
  --dry-run (bool): Execute command in dry run mode
    Default: (empty)
  -f, --follow (bool): Follow log output
    Default: (empty)
  --index (int): index of the container if service has multiple replicas
    Default: 0
  --no-color (bool): Produce monochrome output
    Default: (empty)
  --no-log-prefix (bool): Don't print prefix in logs
    Default: (empty)
  --since (string): Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
    Default: (empty)
  -n, --tail (string): Number of lines to show from the end of the logs for each container
    Default: all
  -t, --timestamps (bool): Show timestamps
    Default: (empty)
  --until (string): Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
    Default: (empty)
```

----------------------------------------

TITLE: Dockerfile: Define Build Arguments for Component Versions
DESCRIPTION: This Dockerfile demonstrates using ARG to define build arguments for component versions (e.g., Node.js, Alpine). These arguments provide default values but can be overridden via the docker build --build-arg flag, enabling flexible version management without Dockerfile modifications. The example showcases a multi-stage build process.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/variables.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

ARG NODE_VERSION="{{% param example_node_version %}}"
ARG ALPINE_VERSION="{{% param example_alpine_version %}}"

FROM node:${NODE_VERSION}-alpine${ALPINE_VERSION} AS base
WORKDIR /src

FROM base AS build
COPY package*.json ./
RUN npm ci
RUN npm run build

FROM base AS production
COPY package*.json ./
RUN npm ci --omit=dev && npm cache clean --force
COPY --from=build /src/dist/ .
CMD ["node", "app.js"]
```

----------------------------------------

TITLE: Build and Push Docker Image with BuildKit
DESCRIPTION: Command to build a Docker image using the configured BuildKit builder and push it to a container registry. Replace `<username>` with your actual Docker Hub username or the appropriate registry prefix.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/buildkit/_index.md#_snippet_9

LANGUAGE: Console
CODE:
```
docker buildx build --push -t <username>/hello-buildkit .
```

----------------------------------------

TITLE: Configure Docker Compose Service Stop Signal
DESCRIPTION: Demonstrates how to explicitly set the `stop_signal` for a service in a `compose.yaml` file. This allows the application inside the container to gracefully shut down upon receiving a specific signal (e.g., `SIGINT`), preventing the default 10-second timeout before a forceful `SIGKILL`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/support-and-feedback/faq.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  web:
    build: .
    stop_signal: SIGINT
```

----------------------------------------

TITLE: GitHub Actions CI/CD Workflow for Docker .NET Application
DESCRIPTION: A YAML configuration for a GitHub Actions workflow that builds, tests, and pushes a Docker image to Docker Hub. It includes steps for logging into Docker Hub, setting up Buildx, and building/pushing the image for multiple platforms based on a .NET application.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/dotnet/configure-ci-cd.md#_snippet_3

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and test
        uses: docker/build-push-action@v6
        with:
          target: build
          load: true

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          target: final
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Defining ENTRYPOINT in Exec Form (Dockerfile)
DESCRIPTION: This snippet shows the preferred "exec form" syntax for the `ENTRYPOINT` instruction. In this form, the command and its arguments are specified as a JSON array, allowing the executable to run directly as PID 1 and receive Unix signals.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_121

LANGUAGE: Dockerfile
CODE:
```
ENTRYPOINT ["executable", "param1", "param2"]
```

----------------------------------------

TITLE: Docker: General `docker run` Command Syntax
DESCRIPTION: Provides the general command-line syntax for `docker run`, showing how options, image, and optional commands/arguments are structured. It highlights that `COMMAND` and `ARG` can override defaults set in the Dockerfile `CMD` instruction.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_49

LANGUAGE: console
CODE:
```
$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
```

----------------------------------------

TITLE: Create a Dockerfile for a simple Nginx website
DESCRIPTION: This Dockerfile extends the Nginx image from Docker Hub to create a simple website. With just a few lines, you can easily set up, customize, and share a static website using Docker.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/docker-hub/quickstart.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM nginx
RUN echo "<h1>Hello world from Docker!</h1>" > /usr/share/nginx/html/index.html
```

----------------------------------------

TITLE: Build Docker Image from Dockerfile
DESCRIPTION: This command builds a Docker image from a Dockerfile. The '-t test:latest' option assigns the name 'test' and tag 'latest' to the resulting image. The dot '.' sets the build context to the current directory, indicating where the Dockerfile and other necessary files are located.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/dockerfile.md#_snippet_13

LANGUAGE: console
CODE:
```
$ docker build -t test:latest .
```

----------------------------------------

TITLE: Compose Variable Interpolation Syntax Formats
DESCRIPTION: Details the supported interpolation syntax for unquoted and double-quoted values in Compose files, including direct substitution, default values, required values, and alternative values for both braced and unbraced expressions.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/environment-variables/variable-interpolation.md#_snippet_1

LANGUAGE: APIDOC
CODE:
```
Interpolation Syntax:
- Braced expressions:
  - Direct substitution: ${VAR} -> value of VAR
  - Default value:
    - ${VAR:-default} -> value of VAR if set and non-empty, otherwise 'default'
    - ${VAR-default} -> value of VAR if set, otherwise 'default'
  - Required value:
    - ${VAR:?error} -> value of VAR if set and non-empty, otherwise exit with error
    - ${VAR?error} -> value of VAR if set, otherwise exit with error
  - Alternative value:
    - ${VAR:+replacement} -> 'replacement' if VAR is set and non-empty, otherwise empty
    - ${VAR+replacement} -> 'replacement' if VAR is set, otherwise empty
- Unbraced expressions: $VAR (direct substitution)
```

----------------------------------------

TITLE: Consume Secrets as Environment Variables in Dockerfile
DESCRIPTION: Shows how to expose multiple secrets directly as environment variables within the build container using the `env` option in the Dockerfile's `RUN --mount` flag, simplifying access for applications.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/secrets.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
RUN --mount=type=secret,id=aws-key-id,env=AWS_ACCESS_KEY_ID \\
    --mount=type=secret,id=aws-secret-key,env=AWS_SECRET_ACCESS_KEY \\
    --mount=type=secret,id=aws-session-token,env=AWS_SESSION_TOKEN \\
    aws s3 cp ...
```

----------------------------------------

TITLE: Mounting Secret as Environment Variable in Dockerfile
DESCRIPTION: This Dockerfile example illustrates mounting a secret directly as an environment variable. It uses `RUN --mount=type=secret,id=API_KEY,env=API_KEY` to make the `API_KEY` secret available as an environment variable named `API_KEY` for a subsequent command, preventing sensitive data from being written to the filesystem.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_52

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine
RUN --mount=type=secret,id=API_KEY,env=API_KEY \
    some-command --token-from-env $API_KEY
```

----------------------------------------

TITLE: Access MySQL container shell using Docker CLI
DESCRIPTION: This command uses `docker exec` to open an interactive bash shell inside a running MySQL container. The `-it` flags ensure an interactive terminal, `my-mysql` is the container name, and `bash` is the command executed within the container to open the shell. This allows direct interaction with the container's file system and applications.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker exec -it my-mysql bash
```

----------------------------------------

TITLE: Bring down Docker application with Compose
DESCRIPTION: This command stops and removes all containers, networks, and optionally volumes associated with the current Compose project. Using `--volumes` ensures that any named volumes are also removed, providing a clean slate.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/swarm/stack-deploy.md#_snippet_11

LANGUAGE: console
CODE:
```
$ docker compose down --volumes

Stopping stackdemo_web_1 ... done
Stopping stackdemo_redis_1 ... done
Removing stackdemo_web_1 ... done
Removing stackdemo_redis_1 ... done
Removing network stackdemo_default
```

----------------------------------------

TITLE: Start Docker Compose Application
DESCRIPTION: This command starts the application defined in `compose.yaml` using Docker Compose. The `--build` flag ensures that service images are rebuilt if necessary before starting the containers.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_11

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Manually Create Docker Compose File
DESCRIPTION: A `compose.yaml` file that defines a 'server' service for the Python application. It specifies building the service from the current directory's Dockerfile and maps port 8001 from the host to the container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_4

LANGUAGE: yaml
CODE:
```
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    ports:
      - 8001:8001
```

----------------------------------------

TITLE: Define Dockerfile for Node.js Application
DESCRIPTION: This Dockerfile defines the steps to build a Docker image for a Node.js application. It sets the base image, working directory, copies application files, installs dependencies, exposes a port, and specifies the command to run the application.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/using-the-build-cache.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
EXPOSE 3000
CMD ["node", "./src/index.js"]
```

----------------------------------------

TITLE: Overriding Default Container Command in YAML
DESCRIPTION: This example shows how to override the default command declared by a container image, such as Dockerfile's `CMD`. The specified command `bundle exec thin -p 3000` will be executed when the service starts.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_10

LANGUAGE: YAML
CODE:
```
command: bundle exec thin -p 3000
```

----------------------------------------

TITLE: List all Docker containers
DESCRIPTION: Use this command to list all Docker containers, including those that are stopped or exited, providing a comprehensive view of container presence.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/troubleshoot-and-support/faqs/linuxfaqs.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker container ls -a
```

----------------------------------------

TITLE: Create Dockerfile for Node.js Application
DESCRIPTION: Defines a multi-stage Dockerfile for a Node.js application. It sets up the Node.js environment, installs dependencies, copies source files, exposes port 3000, and specifies the application's entry point. It leverages Docker's build cache for efficient builds.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/containerize.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1

# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Dockerfile reference guide at
# https://docs.docker.com/go/dockerfile-reference/

# Want to help us make this template better? Share your feedback here: https://forms.gle/ybq9Krt8jtBL3iCk7

ARG NODE_VERSION=18.0.0

FROM node:${NODE_VERSION}-alpine

# Use production node environment by default.
ENV NODE_ENV production


WORKDIR /usr/src/app

# Download dependencies as a separate step to take advantage of Docker's caching.
# Leverage a cache mount to /root/.npm to speed up subsequent builds.
# Leverage a bind mounts to package.json and package-lock.json to avoid having to copy them into
# into this layer.
RUN --mount=type=bind,source=package.json,target=package.json \
    --mount=type=bind,source=package-lock.json,target=package-lock.json \
    --mount=type=cache,target=/root/.npm \
    npm ci --omit=dev

# Run the application as a non-root user.
USER node

# Copy the rest of the source files into the image.
COPY . .

# Expose the port that the application listens on.
EXPOSE 3000

# Run the application.
CMD node src/index.js
```

----------------------------------------

TITLE: Defining Build Cache Export Locations in Docker Compose
DESCRIPTION: This snippet demonstrates how to specify locations for exporting build cache using `cache_to`. This allows sharing build cache with future builds, improving efficiency, and supports various target types like registry and local paths.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/build.md#_snippet_13

LANGUAGE: yaml
CODE:
```
build:
  context: .
  cache_to:
   - user/app:cache
   - type=local,dest=path/to/cache
```

----------------------------------------

TITLE: Generate SBOM and Provenance Attestations for Docker Images
DESCRIPTION: This YAML snippet updates a GitHub Actions workflow to generate Software Bill of Materials (SBOM) and provenance attestations during the Docker image build process. It requires adding `docker/setup-buildx-action` before the build step and enabling `provenance` and `sbom` flags in `docker/build-push-action`.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/gha.md#_snippet_5

LANGUAGE: yaml
CODE:
```
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          annotations: ${{ steps.meta.outputs.annotations }}
          provenance: true
          sbom: true
```

----------------------------------------

TITLE: Building and Caching Docker Images with Registry Backend
DESCRIPTION: This command demonstrates how to build a Docker image using `docker buildx` while leveraging the `registry` cache backend. It pushes the resulting image to a specified registry and simultaneously exports and imports build cache layers to/from a separate cache image in the registry. Key parameters include `ref` for the cache image location and optional `parameters` for fine-tuning cache behavior.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/backends/registry.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker buildx build --push -t <registry>/<image> \
  --cache-to type=registry,ref=<registry>/<cache-image>[,parameters...] \
  --cache-from type=registry,ref=<registry>/<cache-image> .
```

----------------------------------------

TITLE: Kubernetes YAML for PostgreSQL Database Deployment
DESCRIPTION: This YAML configuration defines the necessary Kubernetes objects for deploying a PostgreSQL database. It includes a Deployment for a single PostgreSQL replica, a Service to expose it, a PersistentVolumeClaim for data persistence, and a Secret to securely store the database password. This setup enables a robust local database environment for development.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/deploy.md#_snippet_0

LANGUAGE: yaml
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: example
            - name: POSTGRES_USER
              value: postgres
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_PASSWORD
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
  namespace: default
spec:
  ports:
    - port: 5432
  selector:
    app: postgres
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
  namespace: default
type: Opaque
data:
  POSTGRES_PASSWORD: cG9zdGdyZXNfcGFzc3dvcmQ= # Base64 encoded password (e.g., 'postgres_password')
```

----------------------------------------

TITLE: List Critical Vulnerabilities by Package with Docker Scout CVEs
DESCRIPTION: The `docker scout cves` command provides a detailed view of vulnerabilities. This specific example uses flags `--format only-packages`, `--only-vuln-packages`, and `--only-severity critical` to list only critical vulnerabilities found in vulnerable packages within the `postgres:13.1` image.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/explore/analysis.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker scout cves --format only-packages --only-vuln-packages \
  --only-severity critical postgres:13.1
    ✓ SBOM of image already cached, 187 packages indexed
    ✗ Detected 10 vulnerable packages with a total of 17 vulnerabilities

     Name            Version         Type        Vulnerabilities
───────────────────────────────────────────────────────────────────────────
  dpkg        1.19.7                 deb      1C     0H     0M     0L
  glibc       2.28-10                deb      4C     0H     0M     0L
  gnutls28    3.6.7-4+deb10u6        deb      2C     0H     0M     0L
  libbsd      0.9.1-2                deb      1C     0H     0M     0L
  libksba     1.3.5-2                deb      2C     0H     0M     0L
  libtasn1-6  4.13-3                 deb      1C     0H     0M     0L
  lz4         1.8.3-1                deb      1C     0H     0M     0L
  openldap    2.4.47+dfsg-3+deb10u5  deb      1C     0H     0M     0L
  openssl     1.1.1d-0+deb10u4       deb      3C     0H     0M     0L
  zlib        1:1.2.11.dfsg-1        deb      1C     0H     0M     0L
```

----------------------------------------

TITLE: Configuring Docker Compose for React.js Production and Development
DESCRIPTION: This `compose.yaml` defines two services: `react-prod` for the production build using `Dockerfile` and `react-dev` for the development environment using `Dockerfile.dev`. The `react-dev` service includes `develop.watch` to automatically sync file changes from the host to the container, enabling live reloading.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/develop.md#_snippet_1

LANGUAGE: yaml
CODE:
```
services:
  react-prod:
    build:
      context: .
      dockerfile: Dockerfile
    image: docker-reactjs-sample
    ports:
      - "8080:8080"

  react-dev:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "5173:5173"
    develop:
      watch:
        - action: sync
          path: .
          target: /app
```

----------------------------------------

TITLE: Dockerfile Instructions Reference
DESCRIPTION: A reference of the most common Dockerfile instructions, detailing their purpose and usage.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/dockerfile.md#_snippet_0

LANGUAGE: APIDOC
CODE:
```
Instruction: FROM <image>
  Description: Defines a base for your image.
Instruction: RUN <command>
  Description: Executes any commands in a new layer on top of the current image and commits the result. RUN also has a shell form for running commands.
Instruction: WORKDIR <directory>
  Description: Sets the working directory for any RUN, CMD, ENTRYPOINT, COPY, and ADD instructions that follow it in the Dockerfile.
Instruction: COPY <src> <dest>
  Description: Copies new files or directories from <src> and adds them to the filesystem of the container at the path <dest>.
Instruction: CMD <command>
  Description: Lets you define the default program that is run once you start the container based on this image. Each Dockerfile only has one CMD, and only the last CMD instance is respected when multiple exist.
```

----------------------------------------

TITLE: Reuse a previous Docker build stage as a new base
DESCRIPTION: This Dockerfile illustrates how to define a common base stage (`builder`) and then use it as the starting point for multiple subsequent stages (`build1`, `build2`). This pattern is beneficial for scenarios where multiple final images share common initial setup or dependencies, promoting modularity and reducing redundancy.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-stage.md#_snippet_5

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM alpine:latest AS builder
RUN apk --no-cache add build-base

FROM builder AS build1
COPY source1.cpp source.cpp
RUN g++ -o /binary source.cpp

FROM builder AS build2
COPY source2.cpp source.cpp
RUN g++ -o /binary source.cpp
```

----------------------------------------

TITLE: Define PostgreSQL database service and volume in compose.yaml
DESCRIPTION: This YAML configuration defines a 'db' service using the 'postgres' image, sets up data persistence with a 'db-data' volume, and uses a 'db-password' secret for the database password. It also includes a health check for the database. The 'server' service is configured to depend on the 'db' service.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/develop.md#_snippet_0

LANGUAGE: yaml
CODE:
```
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    environment:
      NODE_ENV: production
    ports:
      - 3000:3000

    # The commented out section below is an example of how to define a PostgreSQL
    # database that your application can use. `depends_on` tells Docker Compose to
    # start the database before your application. The `db-data` volume persists the
    # database data between container restarts. The `db-password` secret is used
    # to set the database password. You must create `db/password.txt` and add
    # a password of your choosing to it before running `docker compose up`.

    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Kubernetes YAML for Go Application and Database Deployment
DESCRIPTION: This Kubernetes YAML file defines the necessary resources for deploying a Go application and its PostgreSQL database. It includes two Deployments (one for the Go server and one for the PostgreSQL database) and two Services (one NodePort service for the server and one ClusterIP service for the database), along with an init container to ensure the server waits for the database to be ready.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/deploy.md#_snippet_0

LANGUAGE: yaml
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    service: server
  name: server
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: server
  strategy: {}
  template:
    metadata:
      labels:
        service: server
    spec:
      initContainers:
        - name: wait-for-db
          image: busybox:1.28
          command:
            [
              "sh",
              "-c",
              'until nc -zv db 5432; do echo "waiting for db"; sleep 2; done;',
            ]
      containers:
        - env:
            - name: PGDATABASE
              value: mydb
            - name: PGPASSWORD
              value: whatever
            - name: PGHOST
              value: db
            - name: PGPORT
              value: "5432"
            - name: PGUSER
              value: postgres
          image: DOCKER_USERNAME/REPO_NAME
          name: server
          imagePullPolicy: Always
          ports:
            - containerPort: 8080
              hostPort: 8080
              protocol: TCP
          resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    service: db
  name: db
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: db
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        service: db
    spec:
      containers:
        - env:
            - name: POSTGRES_DB
              value: mydb
            - name: POSTGRES_PASSWORD
              value: whatever
            - name: POSTGRES_USER
              value: postgres
          image: postgres
          name: db
          ports:
            - containerPort: 5432
              protocol: TCP
          resources: {}
      restartPolicy: Always
status: {}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: server
  name: server
  namespace: default
spec:
  type: NodePort
  ports:
    - name: "8080"
      port: 8080
      targetPort: 8080
      nodePort: 30001
  selector:
    service: server
status:
  loadBalancer: {}
---
apiVersion: v1
kind: Service
metadata:
  labels:
    service: db
  name: db
  namespace: default
spec:
  ports:
    - name: "5432"
      port: 5432
      targetPort: 5432
  selector:
    service: db
status:
  loadBalancer: {}
```

----------------------------------------

TITLE: Dockerfile for Lean Multi-stage Build
DESCRIPTION: This Dockerfile defines the second stage of a multi-stage build process. It uses a 'distroless' base image to create a very lean final image by copying only the compiled application binary from a previous build stage. The image exposes port 8080 and runs the application as a non-root user.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/build-images.md#_snippet_21

LANGUAGE: Dockerfile
CODE:
```
FROM gcr.io/distroless/base-debian11 AS build-release-stage

WORKDIR /

COPY --from=build-stage /docker-gs-ping /docker-gs-ping

EXPOSE 8080

USER nonroot:nonroot

ENTRYPOINT ["/docker-gs-ping"]
```

----------------------------------------

TITLE: Running Docker Compose with Watch Mode
DESCRIPTION: This command starts the Docker Compose application in watch mode, which monitors the configured paths for changes and automatically updates services as specified in the docker-compose.yaml file. This allows for live development without manual restarts, significantly improving developer productivity.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/develop.md#_snippet_10

LANGUAGE: console
CODE:
```
$ docker compose watch
```

----------------------------------------

TITLE: Docker Compose Configuration for PostgreSQL Database
DESCRIPTION: This snippet demonstrates how to define a PostgreSQL database service within a `docker-compose.yml` file. It includes configurations for `depends_on` to ensure the database starts before the application, `volumes` for data persistence, `secrets` for secure password management, and a `healthcheck` to verify database readiness. A `db/password.txt` file is required for the secret.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_5

LANGUAGE: yaml
CODE:
```
depends_on:
  db:
    condition: service_healthy
db:
  image: postgres
  restart: always
  user: postgres
  secrets:
    - db-password
  volumes:
    - db-data:/var/lib/postgresql/data
  environment:
    - POSTGRES_DB=example
    - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
  expose:
    - 5432
  healthcheck:
    test: [ "CMD", "pg_isready" ]
    interval: 10s
    timeout: 5s
    retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Exclude Files from Docker Build Context with .dockerignore
DESCRIPTION: This `.dockerignore` file specifies patterns for files and directories that should be excluded when Docker builds an image. This helps to reduce the build context size, speed up builds, and prevent sensitive or unnecessary files from being copied into the container image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/containerize.md#_snippet_5

LANGUAGE: text
CODE:
```
# Include any files or directories that you don't want to be copied to your
# container here (e.g., local build artifacts, temporary files, etc.).
#
# For more help, visit the .dockerignore file reference guide at

```

----------------------------------------

TITLE: Caching Apt Packages with Dockerfile RUN --mount=type=cache
DESCRIPTION: This example illustrates caching `apt` packages using multiple `RUN --mount=type=cache` directives. It configures `apt` to keep downloaded packages and uses `sharing=locked` for both `/var/cache/apt` and `/var/lib/apt` to ensure exclusive access, preventing race conditions during parallel builds.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_49

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM ubuntu
RUN rm -f /etc/apt/apt.conf.d/docker-clean; echo 'Binary::apt::APT::Keep-Downloaded-Packages "true";' > /etc/apt/apt.conf.d/keep-cache
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
  --mount=type=cache,target=/var/lib/apt,sharing=locked \
  apt update && apt-get --no-install-recommends install -y gcc
```

----------------------------------------

TITLE: Verifying Docker Engine Installation with Hello-World Image
DESCRIPTION: This command verifies the successful installation of Docker Engine by running the `hello-world` image. Docker downloads the image, creates a container, executes it, prints a confirmation message, and then exits, confirming Docker's operational status.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/ubuntu.md#_snippet_5

LANGUAGE: console
CODE:
```
$ sudo docker run hello-world
```

----------------------------------------

TITLE: Specify the base image for a Docker build
DESCRIPTION: This command sets the foundation for the Docker image build. It uses 'python:3.8-slim', a lightweight version of the Python 3.8 image, optimized for size and speed. This choice reduces the overall Docker image size, leading to quicker downloads and a smaller attack surface for security vulnerabilities, especially useful for Python-based applications.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/text-summarization.md#_snippet_8

LANGUAGE: dockerfile
CODE:
```
FROM python:3.8-slim
```

----------------------------------------

TITLE: Configure Docker Compose Watch for Automatic Updates
DESCRIPTION: This YAML configuration adds a `develop.watch` section to the `server` service in `compose.yaml`. It instructs Docker Compose to automatically rebuild the service when changes are detected in the specified path, enabling live updates during development.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/dotnet/develop.md#_snippet_11

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
      target: final
    ports:
      - 8080:8080
    depends_on:
      db:
        condition: service_healthy
    develop:
      watch:
        - action: rebuild
          path: .
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Accessing S3 with Dockerfile RUN --mount=type=secret
DESCRIPTION: This Dockerfile snippet demonstrates how to securely access AWS S3 during a build using a secret mount. It installs `awscli` and then uses `RUN --mount=type=secret` to provide AWS credentials to the `aws s3 cp` command without embedding them into the image. The secret is mounted as a file at `/root/.aws/credentials`.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_50

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM python:3
RUN pip install awscli
RUN --mount=type=secret,id=aws,target=/root/.aws/credentials \
  aws s3 cp s3://... ...
```

----------------------------------------

TITLE: Build and Run GenAI Video Bot with Docker Compose
DESCRIPTION: Executes the Docker Compose command to build the application's services and start them, based on the `docker-compose.yaml` file. This command compiles necessary components and launches the services.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/genai-video-bot/index.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Create Kubernetes Deployment and Service YAML
DESCRIPTION: Defines a Kubernetes Deployment for a C++ application and a NodePort Service to expose it. The Deployment creates a single replica of the application pod, using a specified Docker image. The Service routes external traffic from port 30001 to the application's internal port 8080.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/cpp/deploy.md#_snippet_0

LANGUAGE: YAML
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: docker-c-plus-plus-demo
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: ok-api
  template:
    metadata:
      labels:
        service: ok-api
    spec:
      containers:
        - name: ok-api-service
          image: DOCKER_USERNAME/REPO_NAME
          imagePullPolicy: Always
---
apiVersion: v1
kind: Service
metadata:
  name: service-entrypoint
  namespace: default
spec:
  type: NodePort
  selector:
    service: ok-api
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30001
```

----------------------------------------

TITLE: Using Registry Backend for Buildx Cache Export and Import
DESCRIPTION: This command demonstrates how to use the `registry` cache backend with `docker buildx build`. It exports the build cache to a specified registry image using `--cache-to` and imports it from the same location using `--cache-from`, enabling shared cache for faster builds.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/backends/_index.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker buildx build --push -t <registry>/<image> \
  --cache-to type=registry,ref=<registry>/<cache-image>[,parameters...] \
  --cache-from type=registry,ref=<registry>/<cache-image>[,parameters...] .
```

----------------------------------------

TITLE: Start Docker Compose services with build
DESCRIPTION: Command to build the Docker image (if necessary) and start the services defined in 'docker-compose.yml' in detached mode, allowing the terminal to be used for other commands.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/pre-seeding.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker compose up -d --build
```

----------------------------------------

TITLE: Build and Push Docker Image with Registry Cache in GitHub Actions
DESCRIPTION: This GitHub Actions workflow illustrates how to build and push a Docker image using the registry cache exporter. It logs into Docker Hub, configures Buildx, and then builds and pushes the image, importing and exporting cache layers from a specified registry reference to enable 'max' cache mode.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/cache.md#_snippet_1

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: user/app:latest
          cache-from: type=registry,ref=user/app:buildcache
          cache-to: type=registry,ref=user/app:buildcache,mode=max
```

----------------------------------------

TITLE: GitLab CI/CD: Build and Push Multi-Platform Docker Image
DESCRIPTION: Defines a GitLab CI/CD job to build a multi-platform Docker image (linux/amd64, linux/arm64) and push it to a registry. The image is tagged with the short commit SHA.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build-cloud/ci.md#_snippet_2

LANGUAGE: yaml
CODE:
```
build_push:
  stage: build
  script:
    - |
      docker buildx build \
        --platform linux/amd64,linux/arm64 \
        --tag "${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}" \
        --push .
```

----------------------------------------

TITLE: Push Docker Image to Docker Hub
DESCRIPTION: Pushes the built Docker image to Docker Hub, making it available remotely. Ensure to replace <DOCKER_USERNAME> with your Docker username.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/introduction/build-and-push-first-image.md#_snippet_4

LANGUAGE: Shell
CODE:
```
docker push <DOCKER_USERNAME>/getting-started-todo-app
```

----------------------------------------

TITLE: Shell script for multi-architecture Docker image build and push
DESCRIPTION: A comprehensive shell script demonstrating how to download and set up Docker Buildx, log in to Docker Hub, connect to a cloud builder, and then perform both cache-only and full multi-architecture image builds. It highlights the use of Personal Access Tokens for security.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build-cloud/ci.md#_snippet_14

LANGUAGE: bash
CODE:
```
#!/bin/bash

# Get download link for latest buildx binary. Set $ARCH to the CPU architecture (e.g. amd64, arm64)
ARCH=amd64
BUILDX_URL=$(curl -s https://raw.githubusercontent.com/docker/actions-toolkit/main/.github/buildx-lab-releases.json | jq -r ".latest.assets[] | select(endswith(\"linux-$ARCH\"))")

# Download docker buildx with Build Cloud support
mkdir -vp ~/.docker/cli-plugins/
curl --silent -L --output ~/.docker/cli-plugins/docker-buildx $BUILDX_URL
chmod a+x ~/.docker/cli-plugins/docker-buildx

# Login to Docker Hub. For security reasons $DOCKER_PAT should be a Personal Access Token. See https://docs.docker.com/build-cloud/ci/#creating-access-tokens
echo "$DOCKER_PAT" | docker login --username $DOCKER_USER --password-stdin

# Connect to your builder and set it as the default builder
docker buildx create --use --driver cloud "<ORG>/default"

# Cache-only image build
docker buildx build \
    --tag temp \
    --output type=cacheonly \
    .

# Build, tag, and push a multi-arch docker image
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --push \
    --tag "<IMAGE>" \
    .
```

----------------------------------------

TITLE: Docker Compose: Referencing .env Variables in compose.yaml
DESCRIPTION: This YAML snippet demonstrates how to reference environment variables defined in a .env file within a compose.yaml service definition. The ${VAR_NAME} syntax allows Docker Compose to substitute the variable's value from the .env file into the container's environment.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/environment-variables/variable-interpolation.md#_snippet_3

LANGUAGE: yaml
CODE:
```
services:
  webapp:
    image: my-webapp-image
    environment:
      - DEBUG=${DEBUG}
```

----------------------------------------

TITLE: Initialize Docker Files with docker init
DESCRIPTION: Runs the `docker init` CLI utility to automatically generate essential Docker files (.dockerignore, Dockerfile, compose.yaml, README.Docker.md) for a Rust project, prompting for application platform, Rust version, and server port.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/develop.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

? What application platform does your project use? Rust
? What version of Rust do you want to use? 1.70.0
? What port does your server listen on? 8000
```

----------------------------------------

TITLE: Run Bun application with Docker Compose in foreground
DESCRIPTION: This command builds the Docker image and starts the Bun application container in the foreground using Docker Compose. Access the application at `http://localhost:3000`.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/bun/containerize.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Inspect Docker Image Layers and History
DESCRIPTION: This command displays the history of a Docker image, showing each layer, its size, and the command used to create it. It is useful for understanding how an image was constructed and for debugging build issues. The output details the commands that built each layer, such as 'COPY' and 'CMD' instructions. The '--no-trunc' flag can be used to view full commands, though it may affect readability.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-an-image.md#_snippet_3

LANGUAGE: console
CODE:
```
docker image history docker/welcome-to-docker
```

----------------------------------------

TITLE: Restrict Docker container CPU and memory usage
DESCRIPTION: Illustrates how to limit a Docker container's resource consumption using the `--memory` and `--cpus` flags with `docker run`. The example sets a memory limit of 512 MB and a CPU quota of 0.5 (half a core) for a `postgres` container, preventing it from consuming excessive host resources.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/overriding-container-defaults.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker run -e POSTGRES_PASSWORD=secret --memory="512m" --cpus="0.5" postgres
```

----------------------------------------

TITLE: Optimize Dockerfile for Node.js Dependency Caching
DESCRIPTION: This Dockerfile demonstrates an optimized build strategy for Node.js applications. By copying `package.json` and `yarn.lock` before installing dependencies, Docker's layer caching is leveraged. This ensures that `yarn install --production` is only re-executed when the dependency files change, significantly reducing build times for subsequent image builds where only application code is modified.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/using-the-build-cache.md#_snippet_8

LANGUAGE: dockerfile
CODE:
```
FROM node:20-alpine
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --production 
COPY . . 
EXPOSE 3000
CMD ["node", "src/index.js"]
```

----------------------------------------

TITLE: List Downloaded Docker Images
DESCRIPTION: This command lists all Docker images currently available on your system, displaying repository, tag, image ID, creation date, and size. It helps users quickly identify images they have pulled or built. An example output shows 'docker/welcome-to-docker' with a size of 29.7MB.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-an-image.md#_snippet_2

LANGUAGE: console
CODE:
```
docker image ls
```

----------------------------------------

TITLE: View Kubernetes Pod Logs and Output
DESCRIPTION: This command retrieves the logs from the 'demo' Kubernetes Pod, which is running a ping process. The output displays the standard output of the container, confirming the ping is active and healthy.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/orchestration.md#_snippet_10

LANGUAGE: console
CODE:
```
$ kubectl logs demo
```

LANGUAGE: shell
CODE:
```
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: seq=0 ttl=37 time=21.393 ms
64 bytes from 8.8.8.8: seq=1 ttl=37 time=15.320 ms
64 bytes from 8.8.8.8: seq=2 ttl=37 time=11.111 ms
...
```

----------------------------------------

TITLE: Understanding Dockerfile for Layer Caching
DESCRIPTION: Introduces a Dockerfile snippet to illustrate the concept of layer caching and how changes in a layer affect subsequent layers, impacting build times. This snippet serves as a reference for optimizing Docker image builds by strategically ordering instructions.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/09_image_best.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```

```

----------------------------------------

TITLE: Manually Create Dockerfile for Python Application
DESCRIPTION: Defines a multi-stage Dockerfile for a Python application, starting from a slim Python base image. It sets environment variables, creates a non-privileged user, installs dependencies using pip caching, copies application code, and exposes port 8000, following Docker best practices for security and efficiency.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/containerize.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Dockerfile reference guide at
# https://docs.docker.com/go/dockerfile-reference/

# Want to help us make this template better? Share your feedback here: https://forms.gle/ybq9Krt8jtBL3iCk7

ARG PYTHON_VERSION=3.11.4
FROM python:${PYTHON_VERSION}-slim AS base

# Prevents Python from writing pyc files.
ENV PYTHONDONTWRITEBYTECODE=1

# Keeps Python from buffering stdout and stderr to avoid situations where
# the application crashes without emitting any logs due to buffering.
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Create a non-privileged user that the app will run under.
# See https://docs.docker.com/go/dockerfile-user-best-practices/
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser

# Download dependencies as a separate step to take advantage of Docker's caching.
# Leverage a cache mount to /root/.cache/pip to speed up subsequent builds.
# Leverage a bind mount to requirements.txt to avoid having to copy them into
# into this layer.
RUN --mount=type=cache,target=/root/.cache/pip \
    --mount=type=bind,source=requirements.txt,target=requirements.txt \
    python -m pip install -r requirements.txt

# Switch to the non-privileged user to run the application.
USER appuser

# Copy the source code into the container.
COPY . .

# Expose the port that the application listens on.
EXPOSE 8000
```

----------------------------------------

TITLE: Configure Compose Watch in compose.yml
DESCRIPTION: This YAML configuration adds a `develop` section with `watch` instructions to the `ok-api` service in the `compose.yml` file. It specifies that changes in the current directory (`.`) should trigger a `rebuild` action, enabling automatic updates of the service when code is modified.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/cpp/develop.md#_snippet_1

LANGUAGE: yaml
CODE:
```
services:
  ok-api:
    image: ok-api
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    develop:
      watch:
        - action: rebuild
          path: .
```

----------------------------------------

TITLE: Initializing Docker Configuration Files for React.js
DESCRIPTION: This command uses the `docker init` CLI tool to interactively scaffold essential Docker configuration files, including `Dockerfile`, `.dockerignore`, `compose.yaml`, and `README.Docker.md`. It simplifies the initial setup for containerizing the React.js application.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/containerize.md#_snippet_2

LANGUAGE: console
CODE:
```
docker init
```

----------------------------------------

TITLE: Run Interactive PostgreSQL Shell in Linked Docker Compose Service
DESCRIPTION: Shows how to run an interactive `psql` shell within a linked `db` service container, automatically starting linked services if they are not already running.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_run.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker compose run db psql -h db -U docker
```

----------------------------------------

TITLE: Build and Push Docker Image with `docker/build-push-action`
DESCRIPTION: This YAML snippet demonstrates how to use the `docker/build-push-action` GitHub Action to build and push a Docker image to a registry. It includes conditional pushing based on the event type (not pull request) and uses outputs from a metadata action for tags and annotations.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/gha.md#_snippet_4

LANGUAGE: yaml
CODE:
```
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          annotations: ${{ steps.meta.outputs.annotations }}
```

----------------------------------------

TITLE: Initialize Docker Assets with Docker Init
DESCRIPTION: Example interaction with the `docker init` CLI, demonstrating how to automatically generate Docker-related files (.dockerignore, Dockerfile, compose.yaml, README.Docker.md) for a Python project, specifying Python version, port, and run command.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

? What application platform does your project use? Python
? What version of Python do you want to use? 3.11.4
? What port do you want your app to listen on? 8001
? What is the command to run your app? python3 -m uvicorn app:app --host=0.0.0.0 --port=8001
```

----------------------------------------

TITLE: Run Docker container with published port
DESCRIPTION: Start a Docker container and publish a port from the container to the host using the `--publish` (or `-p`) flag. The format `[host_port]:[container_port]` maps the container's internal port to a specified port on the host, allowing external access.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/run-containers.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker run --publish 8080:8080 docker-gs-ping
```

----------------------------------------

TITLE: Define Docker Compose services for Node.js and PostgreSQL
DESCRIPTION: This YAML snippet defines the services for a Node.js application and a PostgreSQL database. It includes configurations for image, restart policy, secrets, volumes, environment variables, exposed ports, and health checks for the database service.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/containerize.md#_snippet_4

LANGUAGE: yaml
CODE:
```
#         condition: service_healthy
#   db:
#     image: postgres
#     restart: always
#     user: postgres
#     secrets:
#       - db-password
#     volumes:
#       - db-data:/var/lib/postgresql/data
#     environment:
#       - POSTGRES_DB=example
#       - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
#     expose:
#       - 5432
#     healthcheck:
#       test: [ "CMD", "pg_isready" ]
#       interval: 10s
#       timeout: 5s
#       retries: 5
# volumes:
#   db-data:
# secrets:
#   db-password:
#     file: db/password.txt
```

----------------------------------------

TITLE: Publishing a specific port with Docker
DESCRIPTION: This command demonstrates the basic syntax for publishing a host port to a container port using the `docker run -p` flag. It sets up a forwarding rule from `HOST_PORT` on the host machine to `CONTAINER_PORT` inside the `nginx` container.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/publishing-ports.md#_snippet_0

LANGUAGE: bash
CODE:
```
$ docker run -d -p HOST_PORT:CONTAINER_PORT nginx
```

----------------------------------------

TITLE: Dockerfile RUN: Comprehensive apt-get Best Practices
DESCRIPTION: Presents a complete `RUN` instruction incorporating all recommended `apt-get` practices: combining `update` and `install`, using version pinning (`s3cmd=1.1.*`), and cleaning up the apt cache (`rm -rf /var/lib/apt/lists/*`) to reduce image size and ensure up-to-date packages.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_13

LANGUAGE: dockerfile
CODE:
```
RUN apt-get update && apt-get install -y --no-install-recommends \
    aufs-tools \
    automake \
    build-essential \
    curl \
    dpkg-sig \
    libcap-dev \
    libsqlite3-dev \
    mercurial \
    reprepro \
    ruby1.9.1 \
    ruby1.9.1-dev \
    s3cmd=1.1.* \
    && rm -rf /var/lib/apt/lists/*
```

----------------------------------------

TITLE: Build and Run Spring Boot Application with Multi-Stage Dockerfile
DESCRIPTION: This multi-stage Dockerfile optimizes the build process for a Spring Boot application. It includes stages for packaging the application with Maven, extracting application layers for efficient caching, and finally creating a minimal runtime image using a JRE base, running as a non-privileged user.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/containerize.md#_snippet_3

LANGUAGE: Dockerfile
CODE:
```
FROM deps as package

WORKDIR /build

COPY ./src src/
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 \
    ./mvnw package -DskipTests && \
    mv target/$(./mvnw help:evaluate -Dexpression=project.artifactId -q -DforceStdout)-$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout).jar target/app.jar

################################################################################

# Create a stage for extracting the application into separate layers.
# Take advantage of Spring Boot's layer tools and Docker's caching by extracting
# the packaged application into separate layers that can be copied into the final stage.
# See Spring's docs for reference:
# https://docs.spring.io/spring-boot/docs/current/reference/html/container-images.html
FROM package as extract

WORKDIR /build

RUN java -Djarmode=layertools -jar target/app.jar extract --destination target/extracted

################################################################################

# Create a new stage for running the application that contains the minimal
# runtime dependencies for the application. This often uses a different base
# image from the install or build stage where the necessary files are copied
# from the install stage.
#
# The example below uses eclipse-turmin's JRE image as the foundation for running the app.
# By specifying the "17-jre-jammy" tag, it will also use whatever happens to be the
# most recent version of that tag when you build your Dockerfile.
# If reproducibility is important, consider using a specific digest SHA, like
# eclipse-temurin@sha256:99cede493dfd88720b610eb8077c8688d3cca50003d76d1d539b0efc8cca72b4.
FROM eclipse-temurin:21-jre-jammy AS final

# Create a non-privileged user that the app will run under.
# See https://docs.docker.com/go/dockerfile-user-best-practices/
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser
USER appuser

# Copy the executable from the "package" stage.
COPY --from=extract build/target/extracted/dependencies/ ./
COPY --from=extract build/target/extracted/spring-boot-loader/ ./
COPY --from=extract build/target/extracted/snapshot-dependencies/ ./
COPY --from=extract build/target/extracted/application/ ./

EXPOSE 8080

ENTRYPOINT [ "java", "org.springframework.boot.loader.launch.JarLauncher" ]
```

----------------------------------------

TITLE: Example Docker Compose Application Definition
DESCRIPTION: A comprehensive `compose.yml` example demonstrating a multi-container application with a frontend and backend service. It illustrates the definition of services, networks, volumes, configurations, and secrets, showcasing how to structure a complex Docker Compose application.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/intro/compose-application-model.md#_snippet_5

LANGUAGE: yml
CODE:
```
services:
  frontend:
    image: example/webapp
    ports:
      - "443:8043"
    networks:
      - front-tier
      - back-tier
    configs:
      - httpd-config
    secrets:
      - server-certificate

  backend:
    image: example/database
    volumes:
      - db-data:/etc/data
    networks:
      - back-tier

volumes:
  db-data:
    driver: flocker
    driver_opts:
      size: "10GiB"

configs:
  httpd-config:
    external: true

secrets:
  server-certificate:
    external: true

networks:
  # The presence of these objects is sufficient to define them
  front-tier: {}
  back-tier: {}
```

----------------------------------------

TITLE: Running Docker Container with Bind Mount for Development (Git Bash)
DESCRIPTION: This command demonstrates how to run a Docker container for development purposes, specifically using Git Bash. It includes port mapping (`-dp`), setting the working directory (`-w`), and crucially, bind mounting the current host directory (`--mount type=bind,src="/$(pwd)",target=/app`) into the container. The container then executes `yarn install` and `yarn run dev` to set up and start the development server, which uses `nodemon` to watch for file changes.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/06_bind_mounts.md#_snippet_10

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 \
    -w //app --mount type=bind,src="/$(pwd)",target=/app \
    node:18-alpine \
    sh -c "yarn install && yarn run dev"
```

----------------------------------------

TITLE: GitHub Actions Workflow for Docker Image Build and Push
DESCRIPTION: This YAML configuration defines a GitHub Actions workflow named 'ci' that triggers on pushes to the `main` branch. It includes steps to log into Docker Hub using repository variables and secrets, set up Docker Buildx, and then build and push a multi-platform Docker image to Docker Hub, tagging it with the repository name and 'latest'. This automates the CI/CD process for the R application's Docker image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/r/configure-ci-cd.md#_snippet_1

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Publish container port 80 to a specific host port 8000
DESCRIPTION: Shows two equivalent `docker run` commands to publish container port 8 to host port 8000, using both the `--publish` and `-p` flags for explicit port mapping. This allows the container's service on port 80 to be accessed via host's localhost:8000.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/features/networking.md#_snippet_16

LANGUAGE: console
CODE:
```
docker run --publish 8000:80 --name webserver nginx
```

LANGUAGE: console
CODE:
```
docker run -p 8000:80 --name webserver nginx
```

----------------------------------------

TITLE: List all Docker images
DESCRIPTION: This command lists all Docker images currently on your system, including those not associated with any running containers.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/troubleshoot-and-support/faqs/linuxfaqs.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker image ls
```

----------------------------------------

TITLE: Build Docker Image and Export SBOMs Locally
DESCRIPTION: This console command builds a Docker image with SBOM generation enabled (`--sbom=true`) and exports the output, including the generated SBOMs, to a local directory named `out`. It then lists the contents of the `out` directory to show the generated SBOM files.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/metadata/attestations/sbom.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker buildx build \
  --sbom=true \
  --output type=local,dest=out .
$ ls -1 out | grep sbom
sbom-hugo.spdx.json
sbom.spdx.json
```

----------------------------------------

TITLE: Full GitHub Actions Workflow for Building and Pushing Docker Images
DESCRIPTION: This complete GitHub Actions workflow demonstrates best practices for building and pushing Docker images. It includes steps for checking out code, extracting image metadata, logging into Docker Hub, setting up Buildx, and building/pushing the image with SBOM and provenance attestations enabled. It's designed for `push` and `pull_request` events on the `main` branch.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/gha.md#_snippet_6

LANGUAGE: yaml
CODE:
```
name: Build and Push Docker Image

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract Docker image metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.DOCKER_USERNAME }}/my-image

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          annotations: ${{ steps.meta.outputs.annotations }}
          provenance: true
          sbom: true
```

----------------------------------------

TITLE: Multi-Stage Dockerfile for Spring Boot Local Development
DESCRIPTION: This Dockerfile defines a multi-stage build process for a Spring Boot application. It includes stages for dependency resolution, application packaging, layer extraction for optimized image size, and a dedicated 'development' stage that enables JVM debugging on port 8000, suitable for local development workflows.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/develop.md#_snippet_3

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM eclipse-temurin:21-jdk-jammy as deps
WORKDIR /build
COPY --chmod=0755 mvnw mvnw
COPY .mvn/ .mvn/
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 ./mvnw dependency:go-offline -DskipTests

FROM deps as package
WORKDIR /build
COPY ./src src/
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 \
    ./mvnw package -DskipTests && \
    mv target/$(./mvnw help:evaluate -Dexpression=project.artifactId -q -DforceStdout)-$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout).jar target/app.jar

FROM package as extract
WORKDIR /build
RUN java -Djarmode=layertools -jar target/app.jar extract --destination target/extracted

FROM extract as development
WORKDIR /build
RUN cp -r /build/target/extracted/dependencies/. ./
RUN cp -r /build/target/extracted/spring-boot-loader/. ./
RUN cp -r /build/target/extracted/snapshot-dependencies/. ./
RUN cp -r /build/target/extracted/application/. ./
ENV JAVA_TOOL_OPTIONS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000
CMD [ "java", "-Dspring.profiles.active=postgres", "org.springframework.boot.loader.launch.JarLauncher" ]

FROM eclipse-temurin:21-jre-jammy AS final
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser
USER appuser
COPY --from=extract build/target/extracted/dependencies/ ./
COPY --from=extract build/target/extracted/spring-boot-loader/ ./
COPY --from=extract build/target/extracted/snapshot-dependencies/ ./
COPY --from=extract build/target/extracted/application/ ./
EXPOSE 8080
ENTRYPOINT [ "java", "-Dspring.profiles.active=postgres", "org.springframework.boot.loader.launch.JarLauncher" ]
```

----------------------------------------

TITLE: Configure Docker Bake for Production Image Features
DESCRIPTION: This HCL snippet defines a `_common` target in a Docker Bake file to apply multi-platform build settings (linux/amd64, linux/arm64), an OCI image author annotation, and provenance/SBOM attestations. This common configuration is then inherited by specific service targets (`vote`, `result`, `worker`), ensuring consistent application of production-grade features across multiple images.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/compose-bake/index.md#_snippet_14

LANGUAGE: HCL
CODE:
```
group "default" {
  targets = ["vote", "result", "worker"]
}

target "_common" {
  annotations = ["org.opencontainers.image.authors=username"]
  platforms = ["linux/amd64", "linux/arm64"]
  attest = [
    "type=provenance,mode=max",
    "type=sbom"
  ]
}

target "vote" {
  inherits = ["_common"]
  target = "final"
}

target "result" {
  inherits = ["_common"]
}

target "worker" {
  inherits = ["_common"]
}
```

----------------------------------------

TITLE: Docker Compose Up Command Operational Behavior
DESCRIPTION: This section describes the core functionality and behavior of the `docker compose up` command. It explains how the command handles service creation, linking, output aggregation, background execution, configuration changes, and exit codes under various conditions.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_up.md#_snippet_2

LANGUAGE: APIDOC
CODE:
```
Builds, (re)creates, starts, and attaches to containers for a service.

Unless they are already running, this command also starts any linked services.

The `docker compose up` command aggregates the output of each container (like `docker compose logs --follow` does).
One can optionally select a subset of services to attach to using `--attach` flag, or exclude some services using 
`--no-attach` to prevent output to be flooded by some verbose services. 

When the command exits, all containers are stopped. Running `docker compose up --detach` starts the containers in the
background and leaves them running.

If there are existing containers for a service, and the service’s configuration or image was changed after the
container’s creation, `docker compose up` picks up the changes by stopping and recreating the containers
(preserving mounted volumes). To prevent Compose from picking up changes, use the `--no-recreate` flag.

If you want to force Compose to stop and recreate all containers, use the `--force-recreate` flag.

If the process encounters an error, the exit code for this command is `1`.
If the process is interrupted using `SIGINT` (ctrl + C) or `SIGTERM`, the containers are stopped, and the exit code is `0`.
```

----------------------------------------

TITLE: Correct Dockerfile ENTRYPOINT (Exec Form)
DESCRIPTION: Shows the recommended exec form (JSON array) for ENTRYPOINT, ensuring the application runs as PID 1 and correctly receives OS signals for graceful shutdown.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/rules/json-args-recommended.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM alpine
ENTRYPOINT ["my-program", "start"]
```

----------------------------------------

TITLE: Setting Temporary Environment Variable for a Single RUN Command - Dockerfile
DESCRIPTION: This example illustrates how to set an environment variable that is only active for the duration of a single `RUN` command. This approach is useful for build-time specific configurations that should not persist in the final image, preventing unexpected side effects.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_79

LANGUAGE: Dockerfile
CODE:
```
RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y ...
```

----------------------------------------

TITLE: General Docker Run Command Syntax
DESCRIPTION: Illustrates the general syntax for the `docker run` command, including optional parameters, the image reference (name, tag, or digest), and any commands or arguments to be executed inside the container upon startup.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker run [OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
```

----------------------------------------

TITLE: Set environment variables in Docker containers with docker run -e
DESCRIPTION: Shows how to set a single environment variable inside a container using the `-e` flag with `docker run`. The example sets an environment variable named `foo` with the value `bar` for a `postgres` container, then executes `env` to display all environment variables, including the newly set one.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/overriding-container-defaults.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker run -e foo=bar postgres env
```

----------------------------------------

TITLE: Bad Practice: Using ARG for AWS Secret Key in Dockerfile
DESCRIPTION: This Dockerfile snippet demonstrates an insecure practice where AWS_SECRET_ACCESS_KEY is passed using the ARG command. This method is problematic because the secret persists in the final image, making it vulnerable to exposure. It violates the security rule against embedding sensitive data directly in Dockerfile commands like ARG or ENV.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/rules/secrets-used-in-arg-or-env.md#_snippet_1

LANGUAGE: dockerfile
CODE:
```
FROM scratch
ARG AWS_SECRET_ACCESS_KEY
```

----------------------------------------

TITLE: Running a Docker Welcome Container via CLI
DESCRIPTION: This command starts a Docker container in detached mode, mapping port 8080 on the host to port 80 inside the container. It uses the `docker/welcome-to-docker` image to launch a simple web server, making it accessible via `http://localhost:8080`.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/introduction/get-docker-desktop.md#_snippet_0

LANGUAGE: Shell
CODE:
```
$ docker run -d -p 8080:80 docker/welcome-to-docker
```

----------------------------------------

TITLE: Build Docker Image for Basic NLP Application
DESCRIPTION: This command builds a Docker image named `basic-nlp` from the Dockerfile located in the current directory. The `-t` flag tags the image for easy referencing, and the `.` specifies the current directory as the build context.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/sentiment-analysis.md#_snippet_16

LANGUAGE: console
CODE:
```
$ docker build -t basic-nlp .
```

----------------------------------------

TITLE: Define Container Startup Command (Exec Form)
DESCRIPTION: This Dockerfile CMD instruction specifies the command to run when a container based on this image starts. It uses the 'exec form' to directly execute the Flask development server, listening on all network interfaces on port 8000. This form is generally preferred for better signal handling.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/dockerfile.md#_snippet_11

LANGUAGE: dockerfile
CODE:
```
CMD ["flask", "run", "--host", "0.0.0.0", "--port", "8000"]
```

----------------------------------------

TITLE: Run Docker Container in Detached Mode
DESCRIPTION: Explains how to run a Docker container in the background using the `-d` or `--detach` flag. This allows the container to run without occupying the terminal window, returning control to the user immediately.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker run -d <IMAGE>
```

----------------------------------------

TITLE: Defining a Laravel Development Environment with Docker Compose
DESCRIPTION: This YAML configuration defines a multi-service Docker Compose setup for a Laravel development environment. It includes `web` (Nginx), `php-fpm`, `workspace`, `postgres`, and `redis` services, along with network and volume definitions. It mounts application code for live updates, configures Nginx, builds custom PHP-FPM and workspace images with Xdebug, and sets up PostgreSQL and Redis. Dependencies ensure services start in the correct order.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/development-setup.md#_snippet_3

LANGUAGE: YAML
CODE:
```
services:
  web:
    image: nginx:latest # Using the default Nginx image with custom configuration.
    volumes:
      # Mount the application code for live updates
      - ./:/var/www
      # Mount the Nginx configuration file
      - ./docker/development/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
    ports:
      # Map port 80 inside the container to the port specified by 'NGINX_PORT' on the host machine
      - "80:80"
    environment:
      - NGINX_HOST=localhost
    networks:
      - laravel-development
    depends_on:
      php-fpm:
        condition: service_started # Wait for php-fpm to start

  php-fpm:
    # For the php-fpm service, we will use our common PHP-FPM Dockerfile with the development target
    build:
      context: .
      dockerfile: ./docker/common/php-fpm/Dockerfile
      target: development
      args:
        UID: ${UID:-1000}
        GID: ${GID:-1000}
        XDEBUG_ENABLED: ${XDEBUG_ENABLED:-true}
        XDEBUG_MODE: develop,coverage,debug,profile
        XDEBUG_HOST: ${XDEBUG_HOST:-host.docker.internal}
        XDEBUG_IDE_KEY: ${XDEBUG_IDE_KEY:-DOCKER}
        XDEBUG_LOG: /dev/stdout
        XDEBUG_LOG_LEVEL: 0
    env_file:
      # Load the environment variables from the Laravel application
      - .env
    user: "${UID:-1000}:${GID:-1000}"
    volumes:
      # Mount the application code for live updates
      - ./:/var/www
    networks:
      - laravel-development
    depends_on:
      postgres:
        condition: service_started # Wait for postgres to start

  workspace:
    # For the workspace service, we will also create a custom image to install and setup all the necessary stuff.
    build:
      context: .
      dockerfile: ./docker/development/workspace/Dockerfile
      args:
        UID: ${UID:-1000}
        GID: ${GID:-1000}
        XDEBUG_ENABLED: ${XDEBUG_ENABLED:-true}
        XDEBUG_MODE: develop,coverage,debug,profile
        XDEBUG_HOST: ${XDEBUG_HOST:-host.docker.internal}
        XDEBUG_IDE_KEY: ${XDEBUG_IDE_KEY:-DOCKER}
        XDEBUG_LOG: /dev/stdout
        XDEBUG_LOG_LEVEL: 0
    tty: true # Enables an interactive terminal
    stdin_open: true # Keeps standard input open for 'docker exec'
    env_file:
      - .env
    volumes:
      - ./:/var/www
    networks:
      - laravel-development

  postgres:
    image: postgres:16
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    environment:
      - POSTGRES_DB=app
      - POSTGRES_USER=laravel
      - POSTGRES_PASSWORD=secret
    volumes:
      - postgres-data-development:/var/lib/postgresql/data
    networks:
      - laravel-development

  redis:
    image: redis:alpine
    networks:
      - laravel-development

networks:
  laravel-development:

volumes:
  postgres-data-development:
```

----------------------------------------

TITLE: Define Kubernetes Deployment and Service for a Todo App
DESCRIPTION: This YAML file defines a Kubernetes Deployment for the 'getting-started' container image and a NodePort Service to expose it. The Deployment ensures one replica of the application pod, while the Service routes external traffic from host port 30001 to container port 3000, making the Todo app accessible.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/kube-deploy.md#_snippet_0

LANGUAGE: yaml
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: bb-demo
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      bb: web
  template:
    metadata:
      labels:
        bb: web
    spec:
      containers:
        - name: bb-site
          image: getting-started
          imagePullPolicy: Never
---
apiVersion: v1
kind: Service
metadata:
  name: bb-entrypoint
  namespace: default
spec:
  type: NodePort
  selector:
    bb: web
  ports:
    - port: 3000
      targetPort: 3000
      nodePort: 30001
```

----------------------------------------

TITLE: Build Python Application with Dockerfile
DESCRIPTION: Example Dockerfile to create a ready-to-run Python application, including dependency installation, source code copying, port exposure, and user setup. This Dockerfile demonstrates best practices like using a non-root user and defining a clear entrypoint.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/writing-a-dockerfile.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
FROM python:3.12
WORKDIR /usr/local/app

# Install the application dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy in the source code
COPY src ./src
EXPOSE 5000

# Setup an app user so the container doesn't run as the root user
RUN useradd app
USER app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
```

----------------------------------------

TITLE: Define Ollama LLM Service with GPU Support in Docker Compose
DESCRIPTION: This YAML snippet adds the Ollama LLM service to `docker-compose.yaml`, configuring it to run in a container with GPU access. It specifies the image, container name, port mapping, and resource reservations for NVIDIA GPUs, suitable for Linux and Windows 11 with Docker Desktop.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rag-ollama/develop.md#_snippet_2

LANGUAGE: yaml
CODE:
```
ollama:
  image: ollama/ollama
  container_name: ollama
  ports:
    - "8000:8000"
  deploy:
    resources:
      reservations:
        devices:
          - driver: nvidia
            count: 1
            capabilities: [gpu]
```

----------------------------------------

TITLE: Create file in ephemeral Docker container
DESCRIPTION: Demonstrates that files created within a container's scratch space are not persisted by starting an Alpine container and creating `greeting.txt`.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/05_persisting_data.md#_snippet_0

LANGUAGE: console
CODE:
```
docker run --rm alpine touch greeting.txt
```

----------------------------------------

TITLE: Verify Running Docker Containers
DESCRIPTION: Command to list all currently running Docker containers, displaying their IDs, images, commands, status, ports, and names.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/multi-container-applications.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker ps
```

----------------------------------------

TITLE: Configure Docker Compose for Neo4j Database Service
DESCRIPTION: This YAML snippet updates the `compose.yaml` file to include a Neo4j database service. It defines the Neo4j image, port mappings, environment variables for authentication, and a health check. It also configures the `server` service to depend on the `database` service and load environment variables from a `.env` file.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/genai-pdf-bot/develop.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
    ports:
      - 8000:8000
    env_file:
      - .env
    depends_on:
      database:
        condition: service_healthy
  database:
    image: neo4j:5.11
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=${NEO4J_USERNAME}/${NEO4J_PASSWORD}
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider localhost:7474 || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 5
```

----------------------------------------

TITLE: Dockerfile Base Image Definition with FROM Instruction
DESCRIPTION: Sets the base image for the Docker build using the FROM instruction. This example uses ubuntu:22.04, establishing the foundational environment for subsequent build steps.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/dockerfile.md#_snippet_5

LANGUAGE: dockerfile
CODE:
```
FROM ubuntu:22.04
```

----------------------------------------

TITLE: Stop and Remove Docker Compose Application
DESCRIPTION: Use the `docker compose down` command to stop and remove containers and networks defined in your `compose.yaml` file. To also remove named volumes, add the `--volumes` flag. The Docker Desktop Dashboard provides a graphical option to delete the app stack, but it does not remove volumes.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_16

LANGUAGE: Shell
CODE:
```
docker compose down
```

LANGUAGE: Shell
CODE:
```
docker compose down --volumes
```

----------------------------------------

TITLE: Dockerfile instruction to create a non-root user
DESCRIPTION: Example of using `RUN` to create a dedicated non-root user and group (`postgres`) in a Dockerfile, which is a best practice for security. Includes the `--no-log-init` flag workaround for a Go bug.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_35

LANGUAGE: dockerfile
CODE:
```
RUN groupadd -r postgres && useradd --no-log-init -r -g postgres postgres
```

----------------------------------------

TITLE: Run Docker Compose to Build and Start GenAI Application
DESCRIPTION: This command uses Docker Compose to build the application images and start the services defined in the `docker-compose.yml` file. It initiates the containerization process, making the GenAI application accessible.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/genai-pdf-bot/containerize.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Verifying Docker Engine Installation (hello-world)
DESCRIPTION: This command verifies the Docker Engine installation by pulling and running the 'hello-world' test image in a container. A successful execution indicates that Docker is correctly installed and operational, printing a confirmation message to the console.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/fedora.md#_snippet_7

LANGUAGE: console
CODE:
```
$ sudo docker run hello-world
```

----------------------------------------

TITLE: Inspect Docker Image SBOM: List Installed Packages and Versions
DESCRIPTION: This command uses `docker buildx imagetools inspect` with a Go template to parse the SBOM and list all installed packages along with their version information. It iterates through the `.SBOM.SPDX.packages` array to extract `name` and `versionInfo` for each package.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/metadata/attestations/sbom.md#_snippet_9

LANGUAGE: console
CODE:
```
$ docker buildx imagetools inspect <namespace>/<image>:<version> \
    --format "{{ range .SBOM.SPDX.packages }}{{ .name }}@{{ .versionInfo }}{{ println }}{{ end }}"
```

----------------------------------------

TITLE: Publishing Ports at Runtime - Console
DESCRIPTION: This console command snippet illustrates how to explicitly publish and map specific ports (both TCP and UDP) when running a Docker container using the `-p` flag. This overrides any `EXPOSE` settings in the Dockerfile and makes the ports accessible from the host.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_75

LANGUAGE: console
CODE:
```
$ docker run -p 80:80/tcp -p 80:80/udp ...
```

----------------------------------------

TITLE: Updated Docker Compose Configuration for Local Development
DESCRIPTION: This `compose.yaml` file defines a multi-service application, including a 'server' (Rust application) and a 'db' (PostgreSQL database). It configures build context, ports, environment variables for the server, and sets up the database with persistent volumes, secrets, and a health check. It highlights the necessary uncommented database instructions and added environment variables.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/develop.md#_snippet_10

LANGUAGE: yaml
CODE:
```
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker compose reference guide at
# https://docs.docker.com/reference/compose-file/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
      target: final
    ports:
      - 8000:8000
    environment:
      - PG_DBNAME=example
      - PG_HOST=db
      - PG_USER=postgres
      - PG_PASSWORD=mysecretpassword
      - ADDRESS=0.0.0.0:8000
      - RUST_LOG=debug
    # The commented out section below is an example of how to define a PostgreSQL
    # database that your application can use. `depends_on` tells Docker Compose to
    # start the database before your application. The `db-data` volume persists the
    # database data between container restarts. The `db-password` secret is used
    # to set the database password. You must create `db/password.txt` and add
    # a password of your choosing to it before running `docker compose up`.
    depends_on:
      db:
        condition: service_healthy
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: CI/CD Workflow for Angular Application with Docker
DESCRIPTION: This GitHub Actions workflow automates the continuous integration and deployment process for an Angular application containerized with Docker. It triggers on pushes and pull requests to the `main` branch, performing steps such as checking out code, setting up Docker Buildx, caching Docker layers and npm dependencies, building a development image for testing, running Angular Jasmine tests inside a container, logging into Docker Hub, and finally building and pushing the production Docker image with `latest` and short SHA tags.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/angular/configure-github-actions.md#_snippet_5

LANGUAGE: yaml
CODE:
```
name: CI/CD – Angular Application with Docker

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

jobs:
  build-test-push:
    name: Build, Test, and Push Docker Image
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout source code
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2. Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3. Cache Docker layers
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # 4. Cache npm dependencies
      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      # 5. Extract metadata
      - name: Extract metadata
        id: meta
        run: |
          echo "REPO_NAME=${GITHUB_REPOSITORY##*/}" >> "$GITHUB_OUTPUT"
          echo "SHORT_SHA=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # 6. Build dev Docker image
      - name: Build Docker image for tests
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.dev
          tags: ${{ steps.meta.outputs.REPO_NAME }}-dev:latest
          load: true
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      # 7. Run Angular tests with Jasmine
      - name: Run Angular Jasmine tests inside container
        run: |
          docker run --rm \
            --workdir /app \
            --entrypoint "" \
            ${{ steps.meta.outputs.REPO_NAME }}-dev:latest \
            sh -c "npm ci && npm run test -- --ci --runInBand"
        env:
          CI: true
          NODE_ENV: test
        timeout-minutes: 10

      # 8. Log in to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 9. Build and push production image
      - name: Build and push production image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKERHUB_PROJECT_NAME }}:latest
            ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKERHUB_PROJECT_NAME }}:${{ steps.meta.outputs.SHORT_SHA }}
          cache-from: type=local,src=/tmp/.buildx-cache
```

----------------------------------------

TITLE: Define Kubernetes Deployment and Service for PHP App
DESCRIPTION: This YAML file defines two Kubernetes objects: a Deployment named "docker-php-demo" with one replica for a PHP application using a specified Docker image, and a NodePort Service named "php-entrypoint" to expose the application on host port 30001.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/php/deploy.md#_snippet_0

LANGUAGE: YAML
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: docker-php-demo
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      hello-php: web
  template:
    metadata:
      labels:
        hello-php: web
    spec:
      containers:
        - name: hello-site
          image: DOCKER_USERNAME/REPO_NAME
          imagePullPolicy: Always
---
apiVersion: v1
kind: Service
metadata:
  name: php-entrypoint
  namespace: default
spec:
  type: NodePort
  selector:
    hello-php: web
  ports:
    - port: 80
      targetPort: 80
      nodePort: 30001
```

----------------------------------------

TITLE: Defining Container Health Checks in Docker Compose
DESCRIPTION: Configures health checks for services, including the test command, interval, timeout, retries, start period, and start interval. It also demonstrates how to disable health checks or use different command formats.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_52

LANGUAGE: yml
CODE:
```
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost"]
  interval: 1m30s
  timeout: 10s
  retries: 3
  start_period: 40s
  start_interval: 5s
```

LANGUAGE: yml
CODE:
```
# Hit the local web app
test: ["CMD", "curl", "-f", "http://localhost"]
```

LANGUAGE: yml
CODE:
```
test: ["CMD-SHELL", "curl -f http://localhost || exit 1"]
```

LANGUAGE: yml
CODE:
```
test: curl -f https://localhost || exit 1
```

LANGUAGE: yml
CODE:
```
healthcheck:
  disable: true
```

----------------------------------------

TITLE: Diagram: Registry, Repository, and Image Relationship
DESCRIPTION: Illustrates the hierarchical relationship between a container registry, its repositories, and the images stored within those repositories, showing how images are organized.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-registry.md#_snippet_0

LANGUAGE: goat
CODE:
```
+---------------------------------------+
|               Registry                |
|---------------------------------------|
|                                       |
|    +-----------------------------+    |
|    |        Repository A         |    |
|    |-----------------------------|    |
|    |   Image: project-a:v1.0     |    |
|    |   Image: project-a:v2.0     |    |
|    +-----------------------------+    |
|                                       |
|    +-----------------------------+    |
|    |        Repository B         |    |
|    |-----------------------------|    |
|    |   Image: project-b:v1.0     |    |
|    |   Image: project-b:v1.1     |    |
|    |   Image: project-b:v2.0     |    |
|    +-----------------------------+    |
|                                       |
+---------------------------------------+
```

----------------------------------------

TITLE: Prune Docker Images
DESCRIPTION: Commands to remove unused Docker images, including dangling images, all unused images, and images filtered by creation time. By default, a prompt is shown, which can be bypassed with `-f` or `--force`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/manage-resources/pruning.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker image prune

WARNING! This will remove all dangling images.
Are you sure you want to continue? [y/N] y
```

LANGUAGE: console
CODE:
```
$ docker image prune -a

WARNING! This will remove all images without at least one container associated to them.
Are you sure you want to continue? [y/N] y
```

LANGUAGE: console
CODE:
```
$ docker image prune -a --filter "until=24h"
```

----------------------------------------

TITLE: Manually Create Dockerfile for Python Application
DESCRIPTION: A Dockerfile for a Python application, defining the base image, environment variables, working directory, user creation, dependency installation, and the command to run the application. It leverages Docker's caching for efficient builds.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Dockerfile reference guide at
# https://docs.docker.com/go/dockerfile-reference/

# Want to help us make this template better? Share your feedback here: https://   forms.gle/ybq9Krt8jtBL3iCk7

ARG PYTHON_VERSION=3.11.4
FROM python:${PYTHON_VERSION}-slim as base

# Prevents Python from writing pyc files.
ENV PYTHONDONTWRITEBYTECODE=1

# Keeps Python from buffering stdout and stderr to avoid situations where
# the application crashes without emitting any logs due to buffering.
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Create a non-privileged user that the app will run under.
# See https://docs.docker.com/go/dockerfile-user-best-practices/
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser

# Download dependencies as a separate step to take advantage of Docker's    caching.
# Leverage a cache mount to /root/.cache/pip to speed up subsequent builds.
# Leverage a bind mount to requirements.txt to avoid having to copy them into
# into this layer.
RUN --mount=type=cache,target=/root/.cache/pip \
    --mount=type=bind,source=requirements.txt,target=requirements.txt \
    python -m pip install -r requirements.txt

# Switch to the non-privileged user to run the application.
USER appuser

# Copy the source code into the container.
COPY . .

# Expose the port that the application listens on.
EXPOSE 8001

# Run the application.
CMD python3 -m uvicorn app:app --host=0.0.0.0 --port=8001
```

----------------------------------------

TITLE: Initialize Docker Assets with Docker Init
DESCRIPTION: Demonstrates how to use the `docker init` command to automatically generate Docker assets for a Node.js application, including `.dockerignore`, `Dockerfile`, `compose.yaml`, and `README.Docker.md`. It shows the interactive prompts and recommended answers for a Node.js project.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/containerize.md#_snippet_1

LANGUAGE: Shell
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

? What application platform does your project use? Node
? What version of Node do you want to use? 18.0.0
? Which package manager do you want to use? npm
? What command do you want to use to start the app: node src/index.js
? What port does your server listen on? 3000
```

----------------------------------------

TITLE: Build Docker Image (Initial and Cached)
DESCRIPTION: This command builds a Docker image from the current directory, tagging it as 'getting-started'. The first execution will perform a full build, while subsequent builds (especially after Dockerfile optimizations) will demonstrate faster build times due to layer caching.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/09_image_best.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker build -t getting-started .
```

----------------------------------------

TITLE: Build Docker Image (Cached Build)
DESCRIPTION: This command builds the Docker image, tagging it as `node-app:3.0`. When executed after a minor application code change (without altering `package.json`), this build demonstrates the effectiveness of Docker's layer caching, resulting in a much faster build time as dependency layers are reused.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/using-the-build-cache.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker build -t node-app:3.0 .
```

----------------------------------------

TITLE: Complete Docker Compose File for Node.js App and MySQL
DESCRIPTION: The full `compose.yaml` configuration for a multi-service application, including a Node.js `app` service and a `mysql` database service, with port mapping, volumes, and environment variables.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_11

LANGUAGE: yaml
CODE:
```
services:
  app:
    image: node:18-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 127.0.0.1:3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:8.0
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
```

----------------------------------------

TITLE: Basic Dockerfile Format
DESCRIPTION: This snippet illustrates the fundamental structure of a Dockerfile, showing how comments are denoted with a `#` and instructions are followed by their arguments. Instructions are conventionally uppercase for clarity.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# Comment
INSTRUCTION arguments
```

----------------------------------------

TITLE: Define GitHub Actions Workflow for Docker CI/CD
DESCRIPTION: This YAML configuration defines a GitHub Actions workflow named 'ci' that triggers on pushes to the 'main' branch. It logs into Docker Hub using GitHub variables and secrets, sets up Docker Buildx, and then builds and pushes a multi-platform Docker image to Docker Hub, tagging it with the repository name and 'latest'.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/configure-ci-cd.md#_snippet_2

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Create Docker Bind Mount
DESCRIPTION: Demonstrates how to create a Docker bind mount using the `--mount` flag. It specifies the `type` as `bind`, the `source` path on the host, and the `target` destination inside the container, enabling file sharing.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_9

LANGUAGE: console
CODE:
```
$ docker run -it --mount type=bind,source=[PATH],target=[PATH] busybox
```

----------------------------------------

TITLE: Enable SSH Agent Forwarding in Docker Compose
DESCRIPTION: This Docker Compose configuration enables SSH agent forwarding for a service. It binds the host's SSH agent socket into the container and sets the `SSH_AUTH_SOCK` environment variable, allowing the service to use the host's SSH agent.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/features/networking.md#_snippet_11

LANGUAGE: yaml
CODE:
```
services:
  web:
    image: nginx:alpine
    volumes:
      - type: bind
        source: /run/host-services/ssh-auth.sock
        target: /run/host-services/ssh-auth.sock
    environment:
      - SSH_AUTH_SOCK=/run/host-services/ssh-auth.sock
```

----------------------------------------

TITLE: Defining Container Entrypoint (Dockerfile)
DESCRIPTION: This command sets the default entrypoint for the container to /usr/local/bin/entrypoint.sh. This script will be executed when the container starts, allowing for initial setup or configuration before the main command runs.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/production-setup.md#_snippet_7

LANGUAGE: Dockerfile
CODE:
```
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]
```

----------------------------------------

TITLE: Start Docker Container with Read-Write Bind Mount
DESCRIPTION: Starts a detached Docker container named 'devtest' with the 'nginx:latest' image. It bind-mounts the host's 'target' directory (relative to current working directory) to the container's '/app' directory, allowing read-write access for development artifacts.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/bind-mounts.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker run -d \
  -it \
  --name devtest \
  --mount type=bind,source=\"$(pwd)\"/target,target=/app \
  nginx:latest
```

LANGUAGE: console
CODE:
```
$ docker run -d \
  -it \
  --name devtest \
  -v \"$(pwd)\"/target:/app \
  nginx:latest
```

----------------------------------------

TITLE: Clean Up Unused Docker Objects
DESCRIPTION: The `docker system prune` command is a powerful tool to reclaim disk space by removing all stopped containers, unused networks, dangling images, and build cache. This helps optimize Docker's disk footprint.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/troubleshoot-and-support/faqs/macfaqs.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker system prune
```

----------------------------------------

TITLE: Specify the base image in Dockerfile
DESCRIPTION: This command sets the foundation for the build. `python:3.8-slim` is a lightweight version of the Python 3.8 image, optimized for size and speed. Using this slim image reduces the overall size of your Docker image, leading to quicker downloads and less surface area for security vulnerabilities. This is particularly useful for a Python-based application where you might not need the full standard Python image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/sentiment-analysis.md#_snippet_8

LANGUAGE: dockerfile
CODE:
```
FROM python:3.8-slim
```

----------------------------------------

TITLE: Partial Dockerfile for React.js Multi-Stage Build
DESCRIPTION: This snippet shows the beginning of the optimized Dockerfile, specifically the start of "Stage 1" for building the React.js application. It indicates the use of multi-stage builds, a best practice for creating smaller, more efficient Docker images by separating build and runtime environments.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/containerize.md#_snippet_5

LANGUAGE: dockerfile
CODE:
```
# =========================================
# Stage 1: Build the React.js Application
```

----------------------------------------

TITLE: Example Output of Running Docker Containers
DESCRIPTION: Illustrative output from the `docker ps` command, showing the details of the Nginx, web (web1, web2), and Redis containers running in the sample application.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/multi-container-applications.md#_snippet_8

LANGUAGE: text
CODE:
```
CONTAINER ID   IMAGE     COMMAND                  CREATED              STATUS              PORTS                NAMES
2cf7c484c144   nginx     "/docker-entrypoint.…"   9 seconds ago        Up 8 seconds        0.0.0.0:80->80/tcp   nginx
7a070c9ffeaa   web       "docker-entrypoint.s…"   19 seconds ago       Up 18 seconds                            web2
6dc6d4e60aaf   web       "docker-entrypoint.s…"   34 seconds ago       Up 33 seconds                            web1
008e0ecf4f36   redis     "docker-entrypoint.s…"   About a minute ago   Up About a minute   6379/tcp             redis
```

----------------------------------------

TITLE: Define MySQL Service with Volume in Docker Compose
DESCRIPTION: Extends the MySQL service definition in `compose.yaml` to include a volume mapping for persistent data, also defining the top-level volume.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_9

LANGUAGE: yaml
CODE:
```
services:
  app:
    # The app service definition
  mysql:
    image: mysql:8.0
    volumes:
      - todo-mysql-data:/var/lib/mysql

volumes:
  todo-mysql-data:
```

----------------------------------------

TITLE: GitHub Actions CI Workflow with Docker Build and GHA Cache
DESCRIPTION: This YAML snippet defines a GitHub Actions CI workflow. It demonstrates logging into Docker Hub, setting up Docker Buildx, and then building and pushing a Docker image. Crucially, it configures cache-from and cache-to to use type=gha for leveraging the GitHub Actions cache service, optimizing build times by reusing layers.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/cache.md#_snippet_2

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: user/app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

----------------------------------------

TITLE: CI/CD Workflow for React.js Application with Docker using GitHub Actions
DESCRIPTION: This GitHub Actions workflow automates the build, test, and push process for a React.js application using Docker. It includes steps for checking out source code, setting up Docker Buildx, caching dependencies, building a development image for running Vitest tests, and finally building and pushing a production-ready Docker image to Docker Hub. The workflow is triggered on `push` and `pull_request` events to the `main` branch, ensuring continuous integration and deployment.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/configure-github-actions.md#_snippet_6

LANGUAGE: YAML
CODE:
```
name: CI/CD – React.js Application with Docker

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

jobs:
  build-test-push:
    name: Build, Test and Push Docker Image
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout source code
      - name: Checkout source code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetches full history for better caching/context

      # 2. Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3. Cache Docker layers
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: ${{ runner.os }}-buildx-

      # 4. Cache npm dependencies
      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: ${{ runner.os }}-npm-

      # 5. Extract metadata
      - name: Extract metadata
        id: meta
        run: |
          echo "REPO_NAME=${GITHUB_REPOSITORY##*/}" >> "$GITHUB_OUTPUT"
          echo "SHORT_SHA=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"

      # 6. Build dev Docker image
      - name: Build Docker image for tests
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.dev
          tags: ${{ steps.meta.outputs.REPO_NAME }}-dev:latest
          load: true # Load to local Docker daemon for testing
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max

      # 7. Run Vitest tests
      - name: Run Vitest tests and generate report
        run: |
          docker run --rm \
            --workdir /app \
            --entrypoint "" \
            ${{ steps.meta.outputs.REPO_NAME }}-dev:latest \
            sh -c "npm ci && npx vitest run --reporter=verbose"
        env:
          CI: true
          NODE_ENV: test
        timeout-minutes: 10

      # 8. Login to Docker Hub
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 9. Build and push prod image
      - name: Build and push production image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKERHUB_PROJECT_NAME }}:latest
            ${{ secrets.DOCKER_USERNAME }}/${{ secrets.DOCKERHUB_PROJECT_NAME }}:${{ steps.meta.outputs.SHORT_SHA }}
          cache-from: type=local,src=/tmp/.buildx-cache
```

----------------------------------------

TITLE: Define Database Service and Volume in Docker Compose
DESCRIPTION: This YAML configuration updates the `compose.yaml` file to define a PostgreSQL database service (`db`) and a `server` service that depends on it. It includes environment variables for database connection, a health check for the database, and a named volume (`db-data`) for data persistence. It also configures a secret (`db-password`) for the database password, referenced by both services.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_8

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
    ports:
      - 8001:8001
    environment:
      - POSTGRES_SERVER=db
      - POSTGRES_USER=postgres
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    depends_on:
      db:
        condition: service_healthy
    secrets:
      - db-password
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: View Docker Container Logs for Todo App
DESCRIPTION: This command displays the real-time logs of the running todo application container, showing its startup messages and confirming the connection to the MySQL database.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/07_multi_container.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker logs -f <container-id>
$ nodemon src/index.js
[nodemon] 2.0.20
[nodemon] to restart at any time, enter `rs`
[nodemon] watching dir(s): *.*
[nodemon] starting `node src/index.js`
Connected to mysql db at host mysql
Listening on port 3000
```

----------------------------------------

TITLE: Verify Docker Container Status After Stopping
DESCRIPTION: After attempting to stop a container, re-running `docker ps` confirms that the container is no longer active. An empty output indicates no containers are currently running on the machine.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/run-containers.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker ps

CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

----------------------------------------

TITLE: Dockerfile CMD Instruction Reference
DESCRIPTION: Documentation for the Dockerfile CMD instruction, which defines the default command or arguments for an executing container. It covers recommended usage for services and interactive shells, and its interaction with ENTRYPOINT.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_17

LANGUAGE: APIDOC
CODE:
```
CMD Instruction:
  - Purpose: Run software contained in image with arguments.
  - Recommended Form (Exec): CMD ["executable", "param1", "param2"]
    - Use for services (e.g., CMD ["apache2","-DFOREGROUND"]).
    - Use for interactive shells (e.g., CMD ["perl", "-de0"], CMD ["python"]).
  - Interaction with ENTRYPOINT: Rarely used together unless familiar.
```

----------------------------------------

TITLE: Create Docker Volume for CockroachDB
DESCRIPTION: Creates a Docker managed volume named 'roach' to persist data for the CockroachDB container, ensuring data is not lost when the container is removed.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/develop.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker volume create roach
roach
```

----------------------------------------

TITLE: Illustrative example of Compose `develop` with `watch`
DESCRIPTION: Demonstrates how to use the `develop` subsection within a Compose service definition to configure file watching. It shows examples for synchronizing static content and rebuilding an image based on source changes.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/develop.md#_snippet_0

LANGUAGE: YAML
CODE:
```
services:
  frontend:
    image: example/webapp
    build: ./webapp
    develop:
      watch: 
        # sync static content
        - path: ./webapp/html
          action: sync
          target: /var/www
          ignore:
            - node_modules/

  backend:
    image: example/backend
    build: ./backend
    develop:
      watch: 
        # rebuild image and recreate service
        - path: ./backend/src
          action: rebuild
```

----------------------------------------

TITLE: GitHub Actions Workflow for Automatic Docker Tag and Label Management
DESCRIPTION: This GitHub Actions workflow automates the management of Docker image tags and labels. It uses the `docker/metadata-action` to generate tags and labels based on various GitHub events (schedule, push, pull request) and Git metadata (branches, tags, SHA). The workflow also handles logging into Docker Hub and GHCR, setting up QEMU and Buildx, and finally building and pushing the Docker image with the generated tags and labels.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/manage-tags-labels.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  schedule:
    - cron: "0 10 * * *"
  push:
    branches:
      - "**"
    tags:
      - "v*.*.*"
  pull_request:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          # list of Docker images to use as base name for tags
          images: |
            name/app
            ghcr.io/username/app
          # generate Docker tags based on the following events/attributes
          tags: |
            type=schedule
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha

      - name: Login to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GHCR
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
```

----------------------------------------

TITLE: Multi-stage Dockerfile Structure Example
DESCRIPTION: This pseudo-code example illustrates a multi-stage Dockerfile, separating the build environment from the final runtime environment. It demonstrates the use of multiple `FROM` statements with `AS <stage-name>` for distinct stages and how to copy artifacts from a previous stage using `COPY --from`.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/multi-stage-builds.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
# Stage 1: Build Environment
FROM builder-image AS build-stage 
# Install build tools (e.g., Maven, Gradle)
# Copy source code
# Build commands (e.g., compile, package)

# Stage 2: Runtime environment
FROM runtime-image AS final-stage  
#  Copy application artifacts from the build stage (e.g., JAR file)
COPY --from=build-stage /path/in/build/stage /path/to/place/in/final/stage
# Define runtime configuration (e.g., CMD, ENTRYPOINT) 
```

----------------------------------------

TITLE: Pull Docker Images via CLI
DESCRIPTION: The `docker pull` command downloads a specified Docker image from Docker Hub to your local machine. It displays the download progress for each image layer, indicating successful acquisition of the image and its components.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-an-image.md#_snippet_1

LANGUAGE: console
CODE:
```
docker pull docker/welcome-to-docker
```

----------------------------------------

TITLE: Substituting Shell Environment Variables in Docker Compose
DESCRIPTION: This snippet demonstrates how Docker Compose can dynamically inject values from the host's shell environment into the docker-compose.yaml configuration. It shows that if a variable like POSTGRES_VERSION is set in the shell, its value will be used in the image name. If the variable is not set, Compose substitutes an empty string.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/environment-variables/variable-interpolation.md#_snippet_12

LANGUAGE: yaml
CODE:
```
db:
  image: "postgres:${POSTGRES_VERSION}"
```

----------------------------------------

TITLE: Azure Pipelines YAML for Docker Image CI/CD
DESCRIPTION: This comprehensive Azure Pipelines YAML configuration automates the Docker image build and push process. It triggers on commits and pull requests to the `main` branch, securely authenticates with Docker Hub, builds images using Docker BuildKit with caching, applies both build ID and 'latest' tags, and conditionally pushes images to Docker Hub. An optional logout step is included for self-hosted agents.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/azure-pipelines.md#_snippet_0

LANGUAGE: YAML
CODE:
```
# Trigger pipeline on commits to the main branch
trigger:
  - main

# Trigger pipeline on pull requests targeting the main branch
pr:
  - main

# Define variables for reuse across the pipeline
variables:
  imageName: 'docker.io/$(dockerUsername)/my-image'
  buildTag: '$(Build.BuildId)'
  latestTag: 'latest'

stages:
  - stage: BuildAndPush
    displayName: Build and Push Docker Image
    jobs:
      - job: DockerJob
        displayName: Build and Push
        pool:
          vmImage: ubuntu-latest
          demands:
            - docker
        steps:
          - checkout: self
            displayName: Checkout Code

          - task: Docker@2
            displayName: Docker Login
            inputs:
              command: login
              containerRegistry: 'my-docker-registry'  # Service connection name

          - task: Docker@2
            displayName: Build Docker Image
            inputs:
              command: build
              repository: $(imageName)
              tags: |
                $(buildTag)
                $(latestTag)
              dockerfile: './Dockerfile'
              arguments: |
                --sbom=true
                --attest type=provenance
                --cache-from $(imageName):latest
            env:
              DOCKER_BUILDKIT: 1

          - task: Docker@2
            displayName: Push Docker Image
            condition: eq(variables['Build.SourceBranch'], 'refs/heads/main')
            inputs:
              command: push
              repository: $(imageName)
              tags: |
                $(buildTag)
                $(latestTag)

          # Optional: logout for self-hosted agents
          - script: docker logout
            displayName: Docker Logout (Self-hosted only)
            condition: ne(variables['Agent.OS'], 'Windows_NT')
```

----------------------------------------

TITLE: Logging In to Docker Hub
DESCRIPTION: This command is used to authenticate with Docker Hub using your Docker ID. It is a prerequisite for pushing images to a Docker Hub repository, ensuring that you have the necessary permissions. Replace 'YOUR-USER-NAME' with your actual Docker ID.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/04_sharing_app.md#_snippet_2

LANGUAGE: console
CODE:
```
docker login YOUR-USER-NAME
```

----------------------------------------

TITLE: Update Docker Compose Configuration for MariaDB and Data Persistence
DESCRIPTION: This YAML configuration updates the `compose.yaml` file to include a MariaDB database service, link it with a PHP server service, manage database credentials using Docker secrets, and persist database data using a named volume. It also defines health checks for the database to ensure proper service startup.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/php/develop.md#_snippet_1

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
    ports:
      - 9000:80
    depends_on:
      db:
        condition: service_healthy
    secrets:
      - db-password
    environment:
      - PASSWORD_FILE_PATH=/run/secrets/db-password
      - DB_HOST=db
      - DB_NAME=example
      - DB_USER=root
  db:
    image: mariadb
    restart: always
    user: root
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/mysql
    environment:
      - MARIADB_ROOT_PASSWORD_FILE=/run/secrets/db-password
      - MARIADB_DATABASE=example
    expose:
      - 3306
    healthcheck:
      test:
        [
          "CMD",
          "/usr/local/bin/healthcheck.sh",
          "--su-mysql",
          "--connect",
          "--innodb_initialized"
        ]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Defining Simple Services with Docker Compose
DESCRIPTION: This example demonstrates how to define two basic services, `web` and `db`, setting their respective Docker images, mapping ports for `web`, and configuring environment variables for `db`.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  web:
    image: nginx:latest
    ports:
      - "8080:80"

  db:
    image: postgres:13
    environment:
      POSTGRES_USER: example
      POSTGRES_DB: exampledb
```

----------------------------------------

TITLE: Pull and Run Nginx Docker Image via CLI
DESCRIPTION: This command pulls the latest Nginx image from Docker Hub and runs it, mapping host port 8080 to container port 80. The `--rm` flag ensures the container is automatically removed when it exits. This command simplifies the process by combining image pulling and container execution, providing a quick way to get a web server running.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/docker-hub/quickstart.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker run -p 8080:80 --rm nginx
```

----------------------------------------

TITLE: Example Dockerfile for Node.js Application
DESCRIPTION: This Dockerfile serves as an example to illustrate how Docker's build cache operates. It defines the steps to build a Docker image for a Node.js application, including setting the base image, defining the working directory, copying application files, installing production dependencies, and specifying the command to run the application.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/using-the-build-cache.md#_snippet_0

LANGUAGE: Dockerfile
CODE:
```
FROM node:20-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "./src/index.js"]
```

----------------------------------------

TITLE: GitHub Actions Workflow for Local Docker Registry
DESCRIPTION: This GitHub Actions workflow defines a CI pipeline that sets up a local OCI registry service, configures Docker Buildx with host networking, builds a Docker image, pushes it to the local registry (localhost:5000), and finally inspects the pushed image. It's ideal for testing image builds and pushes without relying on external registries.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/local-registry.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    services:
      registry:
        image: registry:2
        ports:
          - 5000:5000
    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host
      
      - name: Build and push to local registry
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: localhost:5000/name/app:latest
      
      - name: Inspect
        run: |
          docker buildx imagetools inspect localhost:5000/name/app:latest
```

----------------------------------------

TITLE: Compressing Docker Buildx Cache with Zstd (Shell)
DESCRIPTION: This command illustrates how to build and push a Docker image, exporting the build cache with `zstd` compression. This option is supported by `local` and `registry` cache backends, helping to reduce cache size and potentially speed up transfer times. It also imports cache from a specified registry reference.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/backends/_index.md#_snippet_3

LANGUAGE: Shell
CODE:
```
$ docker buildx build --push -t <registry>/<image> \
  --cache-to type=registry,ref=<registry>/<cache-image>,compression=zstd \
  --cache-from type=registry,ref=<registry>/<cache-image> .
```

----------------------------------------

TITLE: Build and Push Docker Image with Inline Cache in GitHub Actions
DESCRIPTION: This GitHub Actions workflow demonstrates how to build and push a Docker image to Docker Hub while utilizing the inline cache exporter. It logs into Docker Hub, sets up Buildx, and then builds and pushes the image, caching layers inline to optimize subsequent builds.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/cache.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: user/app:latest
          cache-from: type=registry,ref=user/app:latest
          cache-to: type=inline
```

----------------------------------------

TITLE: Python Flask Application with Redis Hit Counter
DESCRIPTION: Implements a basic Flask web application that connects to a Redis instance to increment and display a hit count. The `get_hit_count` function includes a robust retry mechanism, enhancing resilience against temporary Redis connection issues during startup or runtime.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/gettingstarted.md#_snippet_1

LANGUAGE: python
CODE:
```
import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)

def get_hit_count():
    retries = 5
    while True:
        try:
            return cache.incr('hits')
        except redis.exceptions.ConnectionError as exc:
            if retries == 0:
                raise exc
            retries -= 1
            time.sleep(0.5)

@app.route('/')
def hello():
    count = get_hit_count()
    return f'Hello World! I have been seen {count} times.\n'
```

----------------------------------------

TITLE: GitHub Actions Workflow to Build and Copy Multi-Platform Docker Images
DESCRIPTION: This GitHub Actions workflow demonstrates how to log into Docker Hub and GitHub Container Registry, set up QEMU and Docker Buildx, build a multi-platform Docker image, push it to Docker Hub, and then use `docker buildx imagetools create` to copy the image to GitHub Container Registry. It requires Docker Hub username/token and GitHub token secrets.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/copy-image-registries.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            user/app:latest
            user/app:1.0.0

      - name: Push image to GHCR
        run: |
          docker buildx imagetools create \
            --tag ghcr.io/user/app:latest \
            --tag ghcr.io/user/app:1.0.0 \
            user/app:latest
```

----------------------------------------

TITLE: Docker Compose v1 vs v2 Command Syntax
DESCRIPTION: Illustrates the change in the primary command-line syntax for Docker Compose, where v1 uses a hyphen (`docker-compose`) and v2 integrates into the Docker CLI using a space (`docker compose`). This allows shared flags on the root `docker` command.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/releases/migrate.md#_snippet_0

LANGUAGE: Shell
CODE:
```
docker-compose up
```

LANGUAGE: Shell
CODE:
```
docker compose up
```

LANGUAGE: Shell
CODE:
```
docker --log-level=debug --tls compose up
```

----------------------------------------

TITLE: Run Bash in Docker Compose Service
DESCRIPTION: Demonstrates the basic usage of `docker compose run` to execute a one-time command, `bash`, within the `web` service container. This command overrides the default command defined in the service configuration.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_run.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker compose run web bash
```

----------------------------------------

TITLE: Specifying Container Images in Docker Compose
DESCRIPTION: Defines the Docker image to start the container from, adhering to the Open Container Specification addressable image format. Examples include specifying images by name, tag, digest, or with registry paths.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_53

LANGUAGE: yml
CODE:
```
    image: redis
    image: redis:5
    image: redis@sha256:0ed5d5928d4737458944eb604cc8509e245c3e19d02ad83935398bc4b991aac7
    image: library/redis
    image: docker.io/library/redis
    image: my_private.registry:5000/redis
```

----------------------------------------

TITLE: GitHub Actions Workflow: Build and Push Docker Image
DESCRIPTION: This GitHub Actions workflow, defined in a YAML file, automates the process of building a Docker image and pushing it to Docker Hub. It is triggered on pushes to the `main` branch and includes steps for secure login to Docker Hub using repository variables and secrets, setting up Docker Buildx, and then building and pushing the image with a `latest` tag. The workflow leverages `docker/login-action`, `docker/setup-buildx-action`, and `docker/build-push-action` for these operations.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/ruby/configure-github-actions.md#_snippet_0

LANGUAGE: YAML
CODE:
```
name: Build and push Docker image

on:
  push:
    branches:
      - main

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Configure Multi-stage Dockerfile for Dev and Prod Environments
DESCRIPTION: This Dockerfile demonstrates a multi-stage build pattern, separating development and production environments. It installs development dependencies in the 'dev' stage and omits them in the 'prod' stage, optimizing image size and build times.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/develop.md#_snippet_7

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

ARG NODE_VERSION=18.0.0

FROM node:${NODE_VERSION}-alpine as base
WORKDIR /usr/src/app
EXPOSE 3000

FROM base as dev
RUN --mount=type=bind,source=package.json,target=package.json \
    --mount=type=bind,source=package-lock.json,target=package-lock.json \
    --mount=type=cache,target=/root/.npm \
    npm ci --include=dev
USER node
COPY . .
CMD npm run dev

FROM base as prod
RUN --mount=type=bind,source=package.json,target=package.json \
    --mount=type=bind,source=package-lock.json,target=package-lock.json \
    --mount=type=cache,target=/root/.npm \
    npm ci --omit=dev
USER node
COPY . .
CMD node src/index.js
```

----------------------------------------

TITLE: Start the multi-container application with Docker Compose
DESCRIPTION: Executes the `docker compose up` command to build and start all services defined in the `compose.yaml` file. The `-d` flag runs containers in detached mode (in the background), and `--build` ensures images are rebuilt if necessary.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-docker-compose.md#_snippet_2

LANGUAGE: console
CODE:
```
docker compose up -d --build
```

----------------------------------------

TITLE: Build and Run Development Container with Docker Compose
DESCRIPTION: This command executes `docker compose up` with the `--build` flag, which rebuilds the service images according to the updated `compose.yaml` and Dockerfile. This action creates and starts the development container, incorporating all specified development dependencies.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/php/develop.md#_snippet_13

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Start Application with Docker Compose Build Command
DESCRIPTION: This command initiates the Docker Compose services defined in `compose.yaml`. The `--build` flag ensures that the application image is rebuilt from its Dockerfile before starting the containers, which is crucial for incorporating recent code changes during development.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/develop.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Stop Docker Container using CLI
DESCRIPTION: Explains how to stop a running Docker container by providing its ID or name to the `docker stop` command. It also demonstrates stopping a container using a partial unique ID for convenience.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-container.md#_snippet_2

LANGUAGE: console
CODE:
```
docker stop <the-container-id>
```

LANGUAGE: console
CODE:
```
docker stop a1f
```

----------------------------------------

TITLE: GitHub Actions workflow for max-level provenance
DESCRIPTION: This GitHub Actions workflow demonstrates how to build and push a Docker image with max-level provenance attestations. It includes steps to log into Docker Hub, set up Docker Buildx, extract image metadata, and then build and push the image, explicitly setting `provenance: mode=max` to ensure comprehensive build metadata is attached.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/attestations.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

env:
  IMAGE_NAME: user/app

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          push: true
          provenance: mode=max
          tags: ${{ steps.meta.outputs.tags }}
```

----------------------------------------

TITLE: Example: Verify OpenVEX attestation for a Docker image
DESCRIPTION: This example demonstrates how to verify an OpenVEX attestation for a specific Docker Hardened Image (docs/dhi-python:3.13) on a linux/amd64 platform using Docker Scout. It shows a practical application of the 'docker scout attest get' command.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/dhi/core-concepts/signatures.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker scout attest get \
  --predicate-type https://openvex.dev/ns/v0.2.0 \
  --verify \
  docs/dhi-python:3.13 --platform linux/amd64
```

----------------------------------------

TITLE: Connect to Host Service from Docker Container using Curl
DESCRIPTION: This sequence of commands demonstrates how to run an Alpine container, install `curl`, and then use `curl` to connect to a service running on the host machine via `host.docker.internal`. This is a common workaround for host-to-container communication.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/features/networking.md#_snippet_14

LANGUAGE: console
CODE:
```
$ docker run --rm -it alpine sh
# apk add curl
# curl http://host.docker.internal:8000
# exit
```

----------------------------------------

TITLE: Clean up Docker system resources
DESCRIPTION: This command removes all stopped containers, unused networks, dangling images, and build cache. It helps reclaim significant disk space. The time taken to free space depends on the disk image file format.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/troubleshoot-and-support/faqs/linuxfaqs.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker system prune
```

----------------------------------------

TITLE: Run and test a Docker image locally
DESCRIPTION: This command runs the built Docker image, mapping port 8080 on the host to port 80 in the container, and removes the container after it exits. Replace <YOUR-USERNAME> with your Docker ID.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/docker-hub/quickstart.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker run -p 8080:80 --rm <YOUR-USERNAME>/nginx-custom
```

----------------------------------------

TITLE: Monitoring and Stopping Container with `docker exec`, `top`, `stop`
DESCRIPTION: This console output demonstrates how to inspect processes within a container using `docker exec ps aux` and `docker top`, showing the entrypoint script and Apache processes. It also illustrates gracefully stopping the container with `docker stop`, triggering the cleanup logic defined in the entrypoint script.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_130

LANGUAGE: Console
CODE:
```
$ docker exec -it test ps aux

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.0   4448   692 ?        Ss+  00:42   0:00 /bin/sh /run.sh 123 cmd cmd2
root        19  0.0  0.2  71304  4440 ?        Ss   00:42   0:00 /usr/sbin/apache2 -k start
www-data    20  0.2  0.2 360468  6004 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start
www-data    21  0.2  0.2 360468  6000 ?        Sl   00:42   0:00 /usr/sbin/apache2 -k start
root        81  0.0  0.1  15572  2140 ?        R+   00:44   0:00 ps aux

$ docker top test

PID                 USER                COMMAND
10035               root                {run.sh} /bin/sh /run.sh 123 cmd cmd2
10054               root                /usr/sbin/apache2 -k start
10055               33                  /usr/sbin/apache2 -k start
10056               33                  /usr/sbin/apache2 -k start

$ /usr/bin/time docker stop test

test
real	0m 0.27s
user	0m 0.03s
sys	0m 0.03s
```

----------------------------------------

TITLE: GitHub Actions Workflow to Push Docker Images to Multiple Registries
DESCRIPTION: This GitHub Actions workflow demonstrates how to build a Docker image and push it to both Docker Hub and GitHub Container Registry (GHCR) simultaneously. It includes steps for logging into both registries, setting up QEMU and Buildx for multi-platform builds, and then building and pushing the image with specified tags to both destinations.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/push-multi-registries.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            user/app:latest
            user/app:1.0.0
            ghcr.io/user/app:latest
            ghcr.io/user/app:1.0.0
```

----------------------------------------

TITLE: Run Docker Container from Image
DESCRIPTION: Starts a new Docker container in detached mode (-d) from the built image, mapping port 8080 of the host to port 8080 of the container, allowing access to the Node.js application.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-registry.md#_snippet_5

LANGUAGE: console
CODE:
```
docker run -d -p 8080:8080 <YOUR_DOCKER_USERNAME>/docker-quickstart
```

----------------------------------------

TITLE: GitHub Action Workflow for Docker Build and Push with SSH using build-push-action
DESCRIPTION: This GitHub Actions workflow sets up SSH using `MrSquaare/ssh-setup-action` and then builds and pushes a Docker image using `docker/build-push-action`. It configures the SSH mount for the Docker build step, allowing access to private resources during the build process.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/secrets.md#_snippet_6

LANGUAGE: YAML
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Set up SSH
        uses: MrSquaare/ssh-setup-action@2d028b70b5e397cf8314c6eaea229a6c3e34977a # v3.1.0
        with:
          host: github.com
          private-key: ${{ secrets.SSH_GITHUB_PPK }}
          private-key-name: github-ppk

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          ssh: default
          push: true
          tags: user/app:latest
```

----------------------------------------

TITLE: Running Apache in Foreground with Docker ENTRYPOINT
DESCRIPTION: This Dockerfile configures an image to run Apache HTTP Server in the foreground as PID 1. It installs Apache, exposes standard HTTP/HTTPS ports, defines volumes for persistent data, and uses `ENTRYPOINT` to ensure Apache starts with the `-D FOREGROUND` option.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_127

LANGUAGE: Dockerfile
CODE:
```
FROM debian:stable
RUN apt-get update && apt-get install -y --force-yes apache2
EXPOSE 80 443
VOLUME ["/var/www", "/var/log/apache2", "/etc/apache2"]
ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
```

----------------------------------------

TITLE: Attach to Running Docker Container Shell
DESCRIPTION: Command to open an interactive shell session inside a running Docker container. This allows you to execute commands directly within the container's environment to manage certificates or perform other administrative tasks.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/network/ca-certs.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker exec -it <containerid> sh
```

----------------------------------------

TITLE: Listing Local Docker Images
DESCRIPTION: This command displays a list of all Docker images currently available on your local machine. It provides details such as the image repository name, tag, unique ID, creation timestamp, and size, allowing you to verify successful image builds.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/angular/containerize.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker images
```

----------------------------------------

TITLE: Initialize Docker Assets for .NET Application
DESCRIPTION: Runs `docker init` within the .NET application directory to generate essential Docker files (Dockerfile, compose.yaml, .dockerignore, README.Docker.md) with sensible defaults for ASP.NET Core, prompting for project details like main project name, .NET version, and local port.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/dotnet/containerize.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

? What application platform does your project use? ASP.NET Core
? What's the name of your solution's main project? myWebApp
? What version of .NET do you want to use? 8.0
? What local port do you want to use to access your server? 8080
```

----------------------------------------

TITLE: Run MySQL Container with Network and Volume
DESCRIPTION: This command starts a detached MySQL 8.0 container, connecting it to the 'todo-app' network with a network alias 'mysql'. It also mounts a named volume 'todo-mysql-data' for data persistence and sets environment variables for the root password and the 'todos' database, which are used by MySQL for initialization.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/07_multi_container.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker run -d \
    --network todo-app --network-alias mysql \
    -v todo-mysql-data:/var/lib/mysql \
    -e MYSQL_ROOT_PASSWORD=secret \
    -e MYSQL_DATABASE=todos \
    mysql:8.0
```

LANGUAGE: powershell
CODE:
```
$ docker run -d ``
    --network todo-app --network-alias mysql ``
    -v todo-mysql-data:/var/lib/mysql ``
    -e MYSQL_ROOT_PASSWORD=secret ``
    -e MYSQL_DATABASE=todos ``
    mysql:8.0
```

LANGUAGE: console
CODE:
```
$ docker run -d ^
    --network todo-app --network-alias mysql ^
    -v todo-mysql-data:/var/lib/mysql ^
    -e MYSQL_ROOT_PASSWORD=secret ^
    -e MYSQL_DATABASE=todos ^
    mysql:8.0
```

----------------------------------------

TITLE: Create a Dockerfile for Node.js Application
DESCRIPTION: This Dockerfile defines the steps to build a Docker image for the Node.js todo application. It uses a Node.js base image, sets the working directory, copies source code, installs dependencies, and specifies the application's entry point and exposed port.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/02_our_app.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM node:lts-alpine
WORKDIR /app
COPY . .
RUN yarn install --production
CMD ["node", "src/index.js"]
EXPOSE 3000
```

----------------------------------------

TITLE: Specify Dockerfile Base Image
DESCRIPTION: This command sets the foundation for the build. `python:3.8-slim` is a lightweight version of the Python 3.8 image, optimized for size and speed. Using this slim image reduces the overall size of your Docker image, leading to quicker downloads and less surface area for security vulnerabilities. This is particularly useful for a Python-based application where you might not need the full standard Python image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/text-classification.md#_snippet_15

LANGUAGE: dockerfile
CODE:
```
FROM python:3.8-slim
```

----------------------------------------

TITLE: Define Default Command for Docker Container
DESCRIPTION: This `CMD` instruction specifies the default command that will be executed when a container is started from this image. In this case, it tells Docker to run the compiled Go application binary `/docker-gs-ping`.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/build-images.md#_snippet_9

LANGUAGE: dockerfile
CODE:
```
CMD ["/docker-gs-ping"]
```

----------------------------------------

TITLE: Multi-stage Dockerfile for React Application (Partial)
DESCRIPTION: This partial Dockerfile illustrates a multi-stage build for a React application. Typically, it involves a Node.js stage to build static assets (HTML, CSS, JS) and a lightweight web server stage (like Nginx) to serve them. This approach significantly reduces the final image size by omitting the Node.js runtime from the production image.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/09_image_best.md#_snippet_7

LANGUAGE: dockerfile
CODE:
```
```dockerfile
```

----------------------------------------

TITLE: Using ARG for Build-Time Only Environment Variables - Dockerfile
DESCRIPTION: This snippet demonstrates the use of the `ARG` instruction to define variables that are available only during the build process and are not persisted in the final image. This is an alternative to `ENV` for build-specific configurations.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_80

LANGUAGE: Dockerfile
CODE:
```
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -y ...
```

----------------------------------------

TITLE: Define ENTRYPOINT and CMD for s3cmd CLI tool
DESCRIPTION: Illustrates how to set the main command using ENTRYPOINT and default flags using CMD for a command-line tool like s3cmd, allowing the image to be run directly as the command.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_27

LANGUAGE: dockerfile
CODE:
```
ENTRYPOINT ["s3cmd"]
CMD ["--help"]
```

----------------------------------------

TITLE: Stop a Running Docker Container
DESCRIPTION: This command stops a running Docker container. The container's status changes to 'stopped', and the process inside it terminates, but the container itself is not removed from the system.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/run-containers.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker stop wonderful_kalam
wonderful_kalam
```

----------------------------------------

TITLE: Docker Compose Configuration for Multi-Service Application
DESCRIPTION: This YAML configuration defines two services: 'docker-gs-ping-roach' (a REST server) and 'roach' (CockroachDB). It specifies their dependencies, build context, container names, network settings, port mappings, environment variables, and restart policies. It also defines a named volume for CockroachDB data persistence and a custom bridge network.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/develop.md#_snippet_28

LANGUAGE: yaml
CODE:
```
version: "3.8"

services:
  docker-gs-ping-roach:
    depends_on:
      - roach
    build:
      context: .
    container_name: rest-server
    hostname: rest-server
    networks:
      - mynet
    ports:
      - 80:8080
    environment:
      - PGUSER=${PGUSER:-totoro}
      - PGPASSWORD=${PGPASSWORD:?database password not set}
      - PGHOST=${PGHOST:-db}
      - PGPORT=${PGPORT:-26257}
      - PGDATABASE=${PGDATABASE:-mydb}
    deploy:
      restart_policy:
        condition: on-failure
  roach:
    image: cockroachdb/cockroach:latest-v20.1
    container_name: roach
    hostname: db
    networks:
      - mynet
    ports:
      - 26257:26257
      - 8080:8080
    volumes:
      - roach:/cockroach/cockroach-data
    command: start-single-node --insecure

volumes:
  roach:

networks:
  mynet:
    driver: bridge
```

----------------------------------------

TITLE: Define Spring Boot Service with Docker Compose
DESCRIPTION: This `docker-compose.yaml` file defines a `server` service for the Spring Boot application. It specifies building the image from the current context and mapping port 8080. The file also includes a commented-out example demonstrating how to integrate a PostgreSQL database with health checks and secrets.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/containerize.md#_snippet_4

LANGUAGE: YAML
CODE:
```
# Comments are provided throughout this file to help you get started.
# If you need more help, visit the Docker Compose reference guide at
# https://docs.docker.com/go/compose-spec-reference/

# Here the instructions define your application as a service called "server".
# This service is built from the Dockerfile in the current directory.
# You can add other services your application may depend on here, such as a
# database or a cache. For examples, see the Awesome Compose repository:
# https://github.com/docker/awesome-compose
services:
  server:
    build:
      context: .
    ports:
      - 8080:8080
# The commented out section below is an example of how to define a PostgreSQL
# database that your application can use. `depends_on` tells Docker Compose to
# start the database before your application. The `db-data` volume persists the
# database data between container restarts. The `db-password` secret is used
# to set the database password. You must create `db/password.txt` and add
# a password of your choosing to it before running `docker compose up`.
#     depends_on:
#       db:
#         condition: service_healthy
#   db:
#     image: postgres
#     restart: always
#     user: postgres
#     secrets:
#       - db-password
#     volumes:
#       - db-data:/var/lib/postgresql/data
#     environment:
#       - POSTGRES_DB=example
#       - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
#     expose:
#       - 5432
#     healthcheck:
#       test: [ "CMD", "pg_isready" ]
#       interval: 10s
#       timeout: 5s
#       retries: 5
# volumes:
#   db-data:
# secrets:
#   db-password:
#     file: db/password.txt

```

----------------------------------------

TITLE: Stop and Remove Docker Compose Services
DESCRIPTION: This command stops and removes all containers, networks, and volumes created by `docker compose up`. It's used to clean up the environment after the application has been stopped.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/containerize.md#_snippet_10

LANGUAGE: console
CODE:
```
$ docker compose down
```

----------------------------------------

TITLE: Docker Exit Code: Application Specific
DESCRIPTION: Explains that any exit code other than 125, 126, or 127 represents the exit code of the command executed inside the container. This demonstrates how an application's own exit status is propagated to the host.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_14

LANGUAGE: console
CODE:
```
$ docker run busybox /bin/sh -c 'exit 3'
$ echo $?
3
```

----------------------------------------

TITLE: Start application service with Docker Run
DESCRIPTION: Original `docker run` command used to start the application service, demonstrating manual configuration of ports, working directory, volumes, network, and environment variables before migrating to Docker Compose.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 \
  -w /app -v "$(pwd):/app" \
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:18-alpine \
  sh -c "yarn install && yarn run dev"
```

----------------------------------------

TITLE: Run a Docker container using SDKs or HTTP API
DESCRIPTION: This example demonstrates how to run a Docker container, equivalent to `docker run alpine echo hello world`, using the Go SDK, Python SDK, and direct HTTP API calls with curl. It covers creating, starting, waiting for, and retrieving logs from a container.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/api/engine/sdk/examples.md#_snippet_0

LANGUAGE: Go
CODE:
```
package main

import (
	"context"
	"io"
	"os"

	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/image"
	"github.com/docker/docker/client"
	"github.com/docker/docker/pkg/stdcopy"
)

func main() {
	ctx := context.Background()
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		panic(err)
	}
	defer cli.Close()

	reader, err := cli.ImagePull(ctx, "docker.io/library/alpine", image.PullOptions{})
	if err != nil {
		panic(err)
	}

	defer reader.Close()
	// cli.ImagePull is asynchronous.
	// The reader needs to be read completely for the pull operation to complete.
	// If stdout is not required, consider using io.Discard instead of os.Stdout.
	io.Copy(os.Stdout, reader)

	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: "alpine",
		Cmd:   []string{"echo", "hello world"},
		Tty:   false,
	}, nil, nil, nil, "")
	if err != nil {
		panic(err)
	}

	if err := cli.ContainerStart(ctx, resp.ID, container.StartOptions{}); err != nil {
		panic(err)
	}

	statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
	select {
	case err := <-errCh:
		if err != nil {
			panic(err)
		}
	case <-statusCh:
	}

	out, err := cli.ContainerLogs(ctx, resp.ID, container.LogsOptions{ShowStdout: true})
	if err != nil {
		panic(err)
	}

	stdcopy.StdCopy(os.Stdout, os.Stderr, out)
}
```

LANGUAGE: Python
CODE:
```
import docker
client = docker.from_env()
print(client.containers.run("alpine", ["echo", "hello", "world"]))
```

LANGUAGE: HTTP
CODE:
```
$ curl --unix-socket /var/run/docker.sock -H "Content-Type: application/json" \
  -d '{\"Image\": \"alpine\", \"Cmd\": [\"echo\", \"hello world\"]}' \
  -X POST http://localhost/v{{% param "latest_engine_api_version" %}}/containers/create
{"Id":"1c6594faf5","Warnings":null}

$ curl --unix-socket /var/run/docker.sock -X POST http://localhost/v{{% param "latest_engine_api_version" %}}/containers/1c6594faf5/start

$ curl --unix-socket /var/run/docker.sock -X POST http://localhost/v{{% param "latest_engine_api_version" %}}/containers/1c6594faf5/wait
{"StatusCode":0}

$ curl --unix-socket /var/run/docker.sock "http://localhost/v{{% param "latest_engine_api_version" %}}/containers/1c6594faf5/logs?stdout=1"
hello world
```

----------------------------------------

TITLE: List Docker Images
DESCRIPTION: Lists all Docker images currently available on the local system, including the newly built image, showing their repository, tag, ID, creation time, and size.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-registry.md#_snippet_4

LANGUAGE: console
CODE:
```
docker images
```

----------------------------------------

TITLE: Building a PHP CLI Workspace Container with Node.js and Xdebug (Dockerfile)
DESCRIPTION: This Dockerfile defines a comprehensive workspace container based on 'php:8.4-cli'. It installs core system dependencies, various PHP extensions (e.g., pdo_mysql, opcache, intl, zip), Composer, Redis, and Xdebug. The configuration of Xdebug is dynamic, controlled by build arguments (XDEBUG_ENABLED, XDEBUG_MODE, etc.). Furthermore, it sets up a non-root 'www' user, installs NVM (Node Version Manager), and a specified Node.js version, ensuring a robust environment for both PHP and Node.js CLI development tasks.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/development-setup.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
# docker/development/workspace/Dockerfile
# Use the official PHP CLI image as the base
FROM php:8.4-cli

# Set environment variables for user and group ID
ARG UID=1000
ARG GID=1000
ARG NODE_VERSION=22.0.0

# Install system dependencies and build libraries
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    unzip \
    libpq-dev \
    libonig-dev \
    libssl-dev \
    libxml2-dev \
    libcurl4-openssl-dev \
    libicu-dev \
    libzip-dev \
    && docker-php-ext-install -j$(nproc) \
    pdo_mysql \
    pdo_pgsql \
    pgsql \
    opcache \
    intl \
    zip \
    bcmath \
    soap \
    && pecl install redis xdebug \
    && docker-php-ext-enable redis xdebug\
    && curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer \
    && apt-get autoremove -y && apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*

# Use ARG to define environment variables passed from the Docker build command or Docker Compose.
ARG XDEBUG_ENABLED
ARG XDEBUG_MODE
ARG XDEBUG_HOST
ARG XDEBUG_IDE_KEY
ARG XDEBUG_LOG
ARG XDEBUG_LOG_LEVEL

# Configure Xdebug if enabled
RUN if [ "${XDEBUG_ENABLED}" = "true" ]; then \
    docker-php-ext-enable xdebug && \
    echo "xdebug.mode=${XDEBUG_MODE}" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini && \
    echo "xdebug.idekey=${XDEBUG_IDE_KEY}" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini && \
    echo "xdebug.log=${XDEBUG_LOG}" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini && \
    echo "xdebug.log_level=${XDEBUG_LOG_LEVEL}" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini && \
    echo "xdebug.client_host=${XDEBUG_HOST}" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini ; \
    echo "xdebug.start_with_request=yes" >> /usr/local/etc/php/conf.d/docker-php-ext-xdebug.ini ; \
fi

# If the group already exists, use it; otherwise, create the 'www' group
RUN if getent group ${GID}; then \
      useradd -m -u ${UID} -g ${GID} -s /bin/bash www; \
    else \
      groupadd -g ${GID} www && \
      useradd -m -u ${UID} -g www -s /bin/bash www; \
    fi && \
    usermod -aG sudo www && \
    echo 'www ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers

# Switch to the non-root user to install NVM and Node.js
USER www

# Install NVM (Node Version Manager) as the www user
RUN export NVM_DIR="$HOME/.nvm" && \
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash && \
    [ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh" && \
    nvm install ${NODE_VERSION} && \
    nvm alias default ${NODE_VERSION} && \
    nvm use default

# Ensure NVM is available for all future shells
RUN echo 'export NVM_DIR="$HOME/.nvm"' >> /home/www/.bashrc && \
    echo '[ -s "$NVM_DIR/nvm.sh" ] && \\. "$NVM_DIR/nvm.sh"' >> /home/www/.bashrc && \
    echo '[ -s "$NVM_DIR/bash_completion" ] && \\. "$NVM_DIR/bash_completion"' >> /home/www/.bashrc

# Set the working directory
WORKDIR /var/www

# Override the entrypoint to avoid the default php entrypoint
ENTRYPOINT []

# Default command to keep the container running
CMD ["bash"]
```

----------------------------------------

TITLE: GitLab CI/CD: Docker Build Cloud Setup and Login
DESCRIPTION: Configures GitLab CI/CD to use Docker Build Cloud. This includes setting up Docker-in-Docker services, logging into Docker registry using a personal access token, and installing the Docker Buildx plugin with cloud driver support for multi-platform builds.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build-cloud/ci.md#_snippet_1

LANGUAGE: yaml
CODE:
```
default:
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - docker info
    - echo "$DOCKER_PAT" | docker login --username "$DOCKER_USER" --password-stdin
    - |
      apk add curl jq
      ARCH=${CI_RUNNER_EXECUTABLE_ARCH#/}
      BUILDX_URL=$(curl -s https://raw.githubusercontent.com/docker/actions-toolkit/main/.github/buildx-lab-releases.json | jq -r ".latest.assets[] | select(endswith(\"linux-$ARCH\"))")
      mkdir -vp ~/.docker/cli-plugins/
      curl --silent -L --output ~/.docker/cli-plugins/docker-buildx $BUILDX_URL
      chmod a+x ~/.docker/cli-plugins/docker-buildx
    - docker buildx create --use --driver cloud ${DOCKER_ORG}/default

variables:
  IMAGE_NAME: <IMAGE>
  DOCKER_ORG: <ORG>
```

----------------------------------------

TITLE: Install Python dependencies in the Docker image
DESCRIPTION: This line uses 'pip', Python's package installer, to install the packages listed in 'requirements.txt'. The '--no-cache-dir' option is included to disable the pip cache, which helps reduce the final size of the Docker image by not storing unnecessary cached data.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/text-summarization.md#_snippet_11

LANGUAGE: dockerfile
CODE:
```
RUN pip install --no-cache-dir -r requirements.txt
```

----------------------------------------

TITLE: ARG and ENV Variable Interaction in Dockerfile
DESCRIPTION: This example illustrates how `ENV` variables always override `ARG` variables of the same name. Even if `CONT_IMG_VER` is passed as a build argument, the `ENV` instruction's value (`v1.0.0`) will be used inside the container.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_150

LANGUAGE: dockerfile
CODE:
```
FROM ubuntu
ARG CONT_IMG_VER
ENV CONT_IMG_VER=v1.0.0
RUN echo $CONT_IMG_VER
```

----------------------------------------

TITLE: Create Docker User-Defined Bridge Network
DESCRIPTION: Use the `docker network create` command to establish a new user-defined bridge network. This command allows for custom network configurations, including subnets and IP ranges, for better isolation and organization of containers.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/network/drivers/bridge.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker network create my-net
```

----------------------------------------

TITLE: Specify Dockerfile Base Image
DESCRIPTION: This command sets the foundation for the build. `python:3.8-slim` is a lightweight version of the Python 3.8 image, optimized for size and speed. Using this slim image reduces the overall size of your Docker image, leading to quicker downloads and less surface area for security vulnerabilities. This is particularly useful for a Python-based application where you might not need the full standard Python image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/language-translation.md#_snippet_9

LANGUAGE: dockerfile
CODE:
```
FROM python:3.8-slim
```

----------------------------------------

TITLE: Declaring Dockerfile Syntax Version with `syntax` Directive
DESCRIPTION: This snippet shows the `syntax` parser directive, which declares the Dockerfile syntax version to be used for the build. Setting it to `docker/dockerfile:1` ensures BuildKit pulls the latest stable Dockerfile syntax, allowing access to new features without upgrading Docker Engine.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_13

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
```

----------------------------------------

TITLE: Define MySQL Service in Docker Compose (Initial)
DESCRIPTION: Initial definition of the MySQL service in a `compose.yaml` file, specifying the image to use.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_8

LANGUAGE: yaml
CODE:
```
services:
  app:
    # The app service definition
  mysql:
    image: mysql:8.0
```

----------------------------------------

TITLE: Using ARG with FROM in Dockerfile
DESCRIPTION: Demonstrates how an ARG declared before the first FROM instruction can be used across multiple build stages. The variable `CODE_VERSION` is defined once and applied to different base images.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_41

LANGUAGE: Dockerfile
CODE:
```
ARG  CODE_VERSION=latest
FROM base:${CODE_VERSION}
CMD  /code/run-app

FROM extras:${CODE_VERSION}
CMD  /code/run-extras
```

----------------------------------------

TITLE: Start Docker Compose services
DESCRIPTION: This command starts all services defined in the `compose.yaml` file. It creates and starts the MySQL database and phpMyAdmin containers, making them accessible via the configured ports. Users can access phpMyAdmin at `http://localhost:8080` and connect to the database using `root` as the username and `my-secret-pw` as the password. Press `ctrl`+`c` to stop the containers.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_25

LANGUAGE: console
CODE:
```
$ docker compose up
```

----------------------------------------

TITLE: Create a Docker network
DESCRIPTION: Command to create a new Docker network named 'my-network' for container communication.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker network create my-network
```

----------------------------------------

TITLE: Start GenAI Application Services with Docker Compose
DESCRIPTION: This command builds and starts all services defined in your Docker Compose file, including the GenAI server, Neo4j database, and optional Ollama services. The `ollama-pull` service may take time to download the model, continuously updating the console with its status until completion.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/genai-pdf-bot/develop.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Advanced Docker Volume Mounting with --mount Flag Syntax
DESCRIPTION: Illustrates the general syntax for the `--mount` flag when mounting volumes, showing how to include optional source, destination, and additional key-value pairs for advanced configurations.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/volumes.md#_snippet_1

LANGUAGE: Console
CODE:
```
$ docker run --mount type=volume[,src=<volume-name>],dst=<mount-path>[,<key>=<value>...]
```

----------------------------------------

TITLE: Copy requirements file into Docker image
DESCRIPTION: The `COPY` command transfers the `requirements.txt` file from your local machine into the Docker image. This file lists all Python dependencies required by the application. Copying it into the container lets the next command (`RUN pip install`) install these dependencies inside the image environment.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/sentiment-analysis.md#_snippet_10

LANGUAGE: dockerfile
CODE:
```
COPY requirements.txt /app
```

----------------------------------------

TITLE: Run MySQL container on Docker network
DESCRIPTION: Command to run a MySQL database container, named 'my-mysql', on the 'my-network' network with specified root password and database name. The '-d' flag runs the container in detached mode.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=mydb --network my-network -d mysql:latest
```

----------------------------------------

TITLE: Jenkins Pipeline for multi-architecture Docker image build and push
DESCRIPTION: This Jenkins pipeline defines stages to set up Docker Buildx, log in to Docker Hub using credentials, and then build and push a multi-platform Docker image. It includes steps for downloading Buildx and creating a cloud builder.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build-cloud/ci.md#_snippet_11

LANGUAGE: groovy
CODE:
```
pipeline {
  agent any

  environment {
    ARCH = 'amd64'
    DOCKER_PAT = credentials('docker-personal-access-token')
    DOCKER_USER = credentials('docker-username')
    DOCKER_ORG = '<ORG>'
    IMAGE_NAME = '<IMAGE>'
  }

  stages {
    stage('Build') {
      environment {
        BUILDX_URL = sh (returnStdout: true, script: 'curl -s https://raw.githubusercontent.com/docker/actions-toolkit/main/.github/buildx-lab-releases.json | jq -r ".latest.assets[] | select(endswith(\"linux-$ARCH\"))"').trim()
      }
      steps {
        sh 'mkdir -vp ~/.docker/cli-plugins/'
        sh 'curl --silent -L --output ~/.docker/cli-plugins/docker-buildx $BUILDX_URL'
        sh 'chmod a+x ~/.docker/cli-plugins/docker-buildx'
        sh 'echo "$DOCKER_PAT" | docker login --username $DOCKER_USER --password-stdin'
        sh 'docker buildx create --use --driver cloud "$DOCKER_ORG/default"'
        // Cache-only build
        sh 'docker buildx build --platform linux/amd64,linux/arm64 --tag "$IMAGE_NAME" --output type=cacheonly .'
        // Build and push a multi-platform image
        sh 'docker buildx build --platform linux/amd64,linux/arm64 --push --tag "$IMAGE_NAME" .'
      }
    }
  }
}
```

----------------------------------------

TITLE: Monitor Docker Compose Application Logs
DESCRIPTION: This command allows users to view the real-time logs of all services defined in the `docker-compose.yml` file. It's used to monitor the download and initialization progress of the AI RAG stack, ensuring all components start successfully.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/genai-leveraging-rag/index.md#_snippet_3

LANGUAGE: bash
CODE:
```
docker compose logs
```

----------------------------------------

TITLE: Configuring .dockerignore for Docker Builds
DESCRIPTION: This `.dockerignore` file specifies patterns for files and directories that Docker should exclude when building an image. Its purpose is to reduce the final image size, speed up the build process, and prevent sensitive or unnecessary development files (like `node_modules`, build outputs, and environment files) from being copied into the container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/containerize.md#_snippet_7

LANGUAGE: Dockerignore
CODE:
```
# Ignore dependencies and build output
node_modules/
dist/
out/
.tmp/
.cache/

# Ignore Vite, Webpack, and React-specific build artifacts
.vite/
.vitepress/
.eslintcache
.npm/
coverage/
jest/
cypress/
cypress/screenshots/
cypress/videos/
reports/

# Ignore environment and config files (sensitive data)
*.env*
*.log

# Ignore TypeScript build artifacts (if using TypeScript)
*.tsbuildinfo

# Ignore lockfiles (optional if using Docker for package installation)
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Ignore local development files
.git/
.gitignore
.vscode/
.idea/
*.swp
.DS_Store
Thumbs.db

# Ignore Docker-related files (to avoid copying unnecessary configs)
Dockerfile
.dockerignore
docker-compose.yml
docker-compose.override.yml

# Ignore build-specific cache files
*.lock

```

----------------------------------------

TITLE: Validate Docker Build Configuration with GitHub Actions using build-push-action
DESCRIPTION: This GitHub Actions workflow demonstrates how to validate your Docker build configuration using the `docker/build-push-action`. By setting the `call` input parameter to `check`, the workflow will perform build checks and fail if any warnings are detected, ensuring best practices are followed before the actual build and push.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/checks.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Validate build configuration
        uses: docker/build-push-action@v6
        with:
          call: check

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: user/app:latest
```

----------------------------------------

TITLE: Run an interactive Bash session in an Ubuntu Docker container
DESCRIPTION: This command demonstrates how to run a new Docker container from the `ubuntu` image. The `-i` flag keeps `STDIN` open even if not attached, and `-t` allocates a pseudo-TTY, allowing interactive input and output. The container executes `/bin/bash`, providing a command-line session inside the container. This snippet illustrates the basic workflow of pulling an image, creating a container, and executing a command within it.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-overview.md#_snippet_0

LANGUAGE: bash
CODE:
```
$ docker run -i -t ubuntu /bin/bash
```

----------------------------------------

TITLE: Overriding List Variables with Comma-Separated Values (Shell)
DESCRIPTION: This console command illustrates how to override a `list(string)` variable in a Bake file by providing a comma-separated string via an environment variable. The `TAGS` variable will be parsed into a list `["dev", "latest", "2"]`, allowing dynamic generation of multiple image tags.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/buildx/docs/bake-reference.md#_snippet_56

LANGUAGE: Shell
CODE:
```
$ TAGS=dev,latest,2 docker buildx bake webapp-dev
```

----------------------------------------

TITLE: Build Multi-Platform Docker Image with Emulation
DESCRIPTION: Console command to build a Docker image for both `linux/amd64` and `linux/arm64` platforms using local emulation, tagging it as 'multi-platform'.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-platform.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker build --platform linux/amd64,linux/arm64 -t multi-platform .
```

----------------------------------------

TITLE: Configure Compose Watch in compose.yaml
DESCRIPTION: This `compose.yaml` configuration demonstrates how to integrate Compose Watch into a Docker Compose setup. It defines a `server` service with a `develop.watch` section set to `rebuild` for the current directory, ensuring automatic service updates upon code changes. It also includes a `db` service with health checks and volume persistence.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/python/develop.md#_snippet_16

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
    ports:
      - 8001:8001
    environment:
      - POSTGRES_SERVER=db
      - POSTGRES_USER=postgres
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    depends_on:
      db:
        condition: service_healthy
    secrets:
      - db-password
    develop:
      watch:
        - action: rebuild
          path: .
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Secure private keys by setting read-only permissions
DESCRIPTION: This command changes the file permissions of the private keys (`ca-key.pem`, `key.pem`, `server-key.pem`) to `0400`. This makes them readable only by the owner, protecting them from accidental modification or unauthorized access.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/security/protect-access.md#_snippet_14

LANGUAGE: console
CODE:
```
$ chmod -v 0400 ca-key.pem key.pem server-key.pem
```

----------------------------------------

TITLE: Building Docker Image for Golang Application
DESCRIPTION: This command builds a Docker image from the Dockerfile located in the current directory. The `-t go-api:latest` flag tags the resulting image with the name `go-api` and the version `latest`, making it easily identifiable for subsequent operations like running a container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/go-prometheus-monitoring/containerize.md#_snippet_1

LANGUAGE: Shell
CODE:
```
$ docker build -t go-api:latest .
```

----------------------------------------

TITLE: Multi-stage Dockerfile for Node.js Application
DESCRIPTION: This Dockerfile demonstrates a multi-stage build process for a Node.js application. It uses a `node:lts` image for the build stage to compile the application and then copies the resulting build artifacts into a lightweight `nginx:alpine` image for serving, optimizing for final image size and leveraging Docker's layer caching.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/09_image_best.md#_snippet_8

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM node:lts AS build
WORKDIR /app
COPY package* yarn.lock ./
RUN yarn install
COPY public ./public
COPY src ./src
RUN yarn run build

FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
```

----------------------------------------

TITLE: Docker Run with Memory Limit and Unlimited Swap
DESCRIPTION: This command limits the container's RAM usage to 300MB (`-m 300M`) while allowing unlimited swap memory (`--memory-swap -1`). This configuration is useful when an application requires a fixed amount of RAM but can offload excess data to swap without a hard limit.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_18

LANGUAGE: console
CODE:
```
$ docker run -it -m 300M --memory-swap -1 ubuntu:24.04 /bin/bash
```

----------------------------------------

TITLE: GitHub Actions workflow for SBOM attestation
DESCRIPTION: This GitHub Actions workflow illustrates how to build and push a Docker image with SBOM (Software Bill of Materials) attestations. The workflow covers logging into Docker Hub, configuring Docker Buildx, extracting image metadata, and finally building and pushing the image with the `sbom: true` option enabled to include SBOM data.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/attestations.md#_snippet_1

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

env:
  IMAGE_NAME: user/app

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          sbom: true
          push: true
          tags: ${{ steps.meta.outputs.tags }}
```

----------------------------------------

TITLE: Perform Docker Volume Backup to Local Host
DESCRIPTION: Launches a temporary container, mounts the volume from `dbstore`, mounts the current local directory as `/backup`, and tars the contents of `/dbdata` into `backup.tar` within the local `/backup` directory. The `--rm` flag ensures the temporary container is removed after execution.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/volumes.md#_snippet_28

LANGUAGE: console
CODE:
```
$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
```

----------------------------------------

TITLE: Verify Local HTTPD Service with Curl
DESCRIPTION: Use this `curl` command to verify that the HTTPD service running on `localhost:8080` is accessible and responding. This helps confirm the container is running correctly and its port is properly exposed.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/sharing-local-files.md#_snippet_4

LANGUAGE: console
CODE:
```
$ curl localhost:8080
```

----------------------------------------

TITLE: Examples of COPY with --chown and --chmod in Dockerfile
DESCRIPTION: These examples demonstrate various ways to use the `--chown` flag to set file ownership (using numeric IDs, usernames, or combinations) and the `--chmod` flag to set permissions (e.g., `644`) during a `COPY` operation in a Dockerfile. It highlights flexibility in specifying ownership and permissions.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_110

LANGUAGE: dockerfile
CODE:
```
COPY --chown=55:mygroup files* /somedir/
COPY --chown=bin files* /somedir/
COPY --chown=1 files* /somedir/
COPY --chown=10:11 files* /somedir/
COPY --chown=myuser:mygroup --chmod=644 files* /somedir/
```

----------------------------------------

TITLE: Map a specific host port to a container port
DESCRIPTION: This command runs a Docker container and explicitly maps host port 80 to container port 5000 using the `-p` flag. This allows direct access to the container's service via a well-known host port, but limits the host to running only one container on that specific port.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/network/links.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker run -d -p 80:5000 training/webapp python app.py
```

----------------------------------------

TITLE: Temporarily connect to remote Docker host via SSH using DOCKER_HOST
DESCRIPTION: Alternatively, set the DOCKER_HOST environment variable to temporarily direct the Docker CLI to connect to a remote host via SSH without creating a persistent context. This is useful for ad-hoc connections.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/security/protect-access.md#_snippet_3

LANGUAGE: console
CODE:
```
$ export DOCKER_HOST=ssh://docker-user@host1.example.com
$ docker info
<prints output of the remote engine>
```

----------------------------------------

TITLE: Starting Docker Compose Watch for React.js Development
DESCRIPTION: This command initiates the `react-dev` service in Docker Compose's watch mode. It enables automatic synchronization of source file changes from the host machine into the running container, facilitating a live-reloading development workflow without manual restarts or rebuilds.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/develop.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker compose watch react-dev
```

----------------------------------------

TITLE: Optimized .dockerignore Configuration for Angular Projects
DESCRIPTION: This .dockerignore file specifies patterns for files and directories that should be excluded from the Docker build context. By ignoring unnecessary files like node_modules, build artifacts, environment files, and version control data, it significantly reduces the Docker image size, speeds up the build process, and prevents sensitive information from being included.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/angular/containerize.md#_snippet_5

LANGUAGE: dockerignore
CODE:
```
# ================================
# Node and build output
# ================================
node_modules
dist
out-tsc
.angular
.cache
.tmp

# ================================
# Testing & Coverage
# ================================
coverage
jest
cypress
cypress/screenshots
cypress/videos
reports
playwright-report
.vite
.vitepress

# ================================
# Environment & log files
# ================================
*.env*
!*.env.production
*.log
*.tsbuildinfo

# ================================
# IDE & OS-specific files
# ================================
.vscode
.idea
.DS_Store
Thumbs.db
*.swp

# ================================
# Version control & CI files
# ================================
.git
.gitignore

# ================================
# Docker & local orchestration
# ================================
Dockerfile
Dockerfile.*
.dockerignore
docker-compose.yml
docker-compose*.yml

# ================================
# Miscellaneous
# ================================
*.bak
*.old
*.tmp
```

----------------------------------------

TITLE: Build and Run Docker Compose Application
DESCRIPTION: Execute this command to start your Docker Compose application. The `--build` flag forces Docker to recompile images, which is crucial for reflecting source code changes. Be aware that this can create new volumes, potentially leading to database connection errors if the database is not re-initialized.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/develop.md#_snippet_31

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Create Multi-Node Docker Buildx Builder
DESCRIPTION: Shows how to create a multi-node builder by appending additional Docker contexts (e.g., `node-amd64`, `node-arm64`) to an existing builder, then building a multi-platform image using this builder. This approach offers better performance than emulation.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-platform.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker buildx create --use --name mybuild node-amd64
mybuild
$ docker buildx create --append --name mybuild node-arm64
$ docker buildx build --platform linux/amd64,linux/arm64 .
```

----------------------------------------

TITLE: Dockerfile for Go Module Download and Build with SSH Mount
DESCRIPTION: This Dockerfile demonstrates how to use SSH mounts to download Go modules and build a Go application. It leverages build-time SSH access for private repositories or dependencies, along with bind and cache mounts for efficient builds.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/secrets.md#_snippet_5

LANGUAGE: Dockerfile
CODE:
```
# this one download go modules
RUN --mount=type=bind,target=. \
    --mount=type=cache,target=/go/pkg/mod \
    --mount=type=ssh \
    go mod download -x

FROM vendor AS build
RUN --mount=type=bind,target=. \
    --mount=type=cache,target=/go/pkg/mod \
    --mount=type=cache,target=/root/.cache \
    go build ...
```

----------------------------------------

TITLE: Run Docker Compose Service with Ports Mapped
DESCRIPTION: Shows how to run a command in a Docker Compose service while also publishing the service's defined ports to the host, preventing port collisions.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_run.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker compose run --service-ports web python manage.py shell
```

----------------------------------------

TITLE: Build and Run .NET Application with Docker Compose
DESCRIPTION: Executes `docker compose up --build` to build the Docker images and start the .NET application containers in the foreground, making the application accessible via a web browser.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/dotnet/containerize.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Creating Provenance Attestations with Docker Buildx
DESCRIPTION: This command demonstrates how to generate provenance attestations for a Docker image using `docker buildx build`. It utilizes the `--attest type=provenance` option to enable attestation generation and allows specifying the level of detail using the `mode` parameter (e.g., `min` or `max`). An alternative shorthand `--provenance=true` is also mentioned.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/metadata/attestations/slsa-provenance.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker buildx build --tag <namespace>/<image>:<version> \
    --attest type=provenance,mode=[min,max] .
```

----------------------------------------

TITLE: Build from Private Git Repository using Token Authentication
DESCRIPTION: Shows how to authenticate with a private Git repository using a token. The token is passed securely via the `--secret` flag with `docker buildx build`, preventing it from being exposed in the build logs.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/context.md#_snippet_15

LANGUAGE: console
CODE:
```
$ GIT_AUTH_TOKEN=<token> docker buildx build \
  --secret id=GIT_AUTH_TOKEN \
  https://github.com/user/private.git
```

----------------------------------------

TITLE: Inefficient Dockerfile for JavaScript build
DESCRIPTION: This Dockerfile copies all project files before installing dependencies. Any change to a source file will invalidate the cache for the 'npm install' step, leading to unnecessary reinstallation of all dependencies on every build.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/optimize.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM node
WORKDIR /app
COPY . .          # Copy over all files in the current directory
RUN npm install   # Install dependencies
RUN npm build     # Run build
```

----------------------------------------

TITLE: Run Docker Todo App with MySQL Connection
DESCRIPTION: This command starts the todo application container, mapping port 3000, mounting the current directory as /app, connecting to the 'todo-app' network, and configuring MySQL connection details via environment variables (host, user, password, database). It then executes yarn install and yarn run dev inside the container.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/07_multi_container.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 \
  -w /app -v "$(pwd):/app" \
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:18-alpine \
  sh -c "yarn install && yarn run dev"
```

LANGUAGE: powershell
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 `
  -w /app -v "$(pwd):/app" `
  --network todo-app `
  -e MYSQL_HOST=mysql `
  -e MYSQL_USER=root `
  -e MYSQL_PASSWORD=secret `
  -e MYSQL_DB=todos `
  node:18-alpine `
  sh -c "yarn install && yarn run dev"
```

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 ^
  -w /app -v "%cd%:/app" ^
  --network todo-app ^
  -e MYSQL_HOST=mysql ^
  -e MYSQL_USER=root ^
  -e MYSQL_PASSWORD=secret ^
  -e MYSQL_DB=todos ^
  node:18-alpine ^
  sh -c "yarn install && yarn run dev"
```

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 \
  -w //app -v "/$(pwd):/app" \
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:18-alpine \
  sh -c "yarn install && yarn run dev"
```

----------------------------------------

TITLE: Defining Docker Compose Service Profiles (YAML)
DESCRIPTION: This snippet shows how to use `profiles` to conditionally enable Docker Compose services. Services with assigned profiles only start when their respective profile is activated, allowing for different deployment scenarios or development environments.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_75

LANGUAGE: yaml
CODE:
```
services:
  frontend:
    image: frontend
    profiles: ["frontend"]

  phpmyadmin:
    image: phpmyadmin
    depends_on:
      - db
    profiles:
      - debug
```

----------------------------------------

TITLE: Illustrative Example of Compose Build Configurations (YAML)
DESCRIPTION: This snippet demonstrates various ways to configure the `build` attribute within a Docker Compose file. It shows building from a simple context path, specifying a custom Dockerfile, and using an absolute path for the build context. It also illustrates how `image` attributes are used for pushing built images.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/build.md#_snippet_0

LANGUAGE: YAML
CODE:
```
services:
  frontend:
    image: example/webapp
    build: ./webapp

  backend:
    image: example/database
    build:
      context: backend
      dockerfile: ../backend.Dockerfile

  custom:
    build: ~/custom
```

----------------------------------------

TITLE: Initialize Docker Swarm
DESCRIPTION: This command initializes a new Docker Swarm on the current machine, making it the manager node. The `--advertise-addr` flag specifies the IP address that other nodes in the swarm will use to communicate with this manager. The output provides the join tokens for adding worker and manager nodes.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/swarm/swarm-tutorial/create-swarm.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker swarm init --advertise-addr <MANAGER-IP>
```

LANGUAGE: console
CODE:
```
$ docker swarm init --advertise-addr 192.168.99.100
Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \
    192.168.99.100:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
```

----------------------------------------

TITLE: Copying Files from a Build Stage
DESCRIPTION: This example shows how to use the `COPY --from` flag to copy a file (`/myapp`) from a previously defined build stage named `build` to the `/usr/bin/` directory in the current image. This is a crucial feature for multi-stage builds, allowing efficient transfer of artifacts between stages.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_101

LANGUAGE: dockerfile
CODE:
```
FROM golang AS build
WORKDIR /app
RUN --mount=type=bind,target=. go build -o /myapp ./cmd

COPY --from=build /myapp /usr/bin/
```

----------------------------------------

TITLE: Initialize Docker Assets with Docker Init
DESCRIPTION: Run `docker init` inside the application directory to automatically generate Docker assets like `Dockerfile`, `.dockerignore`, and `compose.yaml`. This interactive command prompts for application details such as platform, source directory, Java version, and server port, and can overwrite existing Docker files if confirmed.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/containerize.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

WARNING: The following Docker files already exist in this directory:
  - docker-compose.yml
? Do you want to overwrite them? Yes
? What application platform does your project use? Java
? What's the relative directory (with a leading .) for your app? ./src
? What version of Java do you want to use? 21
? What port does your server listen on? 8080
```

----------------------------------------

TITLE: Set and Propagate Environment Variables in Linux Container
DESCRIPTION: This snippet demonstrates how to set explicit environment variables (e.g., 'deep=purple') and propagate host environment variables (e.g., 'today') into a Linux Docker container using the `-e` flag. It then runs the `env` command inside an `alpine` container to display the resulting environment variables, showing both explicitly set and propagated values.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_54

LANGUAGE: console
CODE:
```
$ export today=Wednesday
$ docker run -e "deep=purple" -e today --rm alpine env

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=d2219b854598
deep=purple
today=Wednesday
HOME=/root
```

----------------------------------------

TITLE: Implementing Multi-Axis Matrix Strategy in HCL
DESCRIPTION: This HCL snippet illustrates a `matrix` strategy with multiple axes (`tgt` and `version`) to generate a Cartesian product of targets. It creates four distinct targets (e.g., `app-foo-1-0`, `app-bar-2-0`), dynamically naming them and passing matrix values as build arguments, enabling comprehensive variant generation.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/buildx/docs/bake-reference.md#_snippet_34

LANGUAGE: hcl
CODE:
```
target "app" {
  name = "app-${tgt}-${replace(version, ".", "-")}"
  matrix = {
    tgt = ["foo", "bar"]
    version = ["1.0", "2.0"]
  }
  target = tgt
  args = {
    VERSION = version
  }
}
```

----------------------------------------

TITLE: Dockerfile with Build Argument for Configurable Environment Variable
DESCRIPTION: This Dockerfile shows how to combine `ARG` and `ENV` instructions to allow an environment variable (`NODE_ENV`) to be configured at build-time using `--build-arg`. The `ARG` defines a default, which is then assigned to `ENV`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/variables.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM node:20
ARG NODE_ENV=production
ENV NODE_ENV=$NODE_ENV
WORKDIR /app
COPY package*.json ./
RUN npm ci && npm cache clean --force
COPY . .
CMD ["node", "app.js"]
```

----------------------------------------

TITLE: Define Application Services with Docker Compose
DESCRIPTION: This Docker Compose file defines four services: 'backend', 'frontend', 'mongodb', and 'localstack'. It configures dependencies, port mappings, environment variables, and persistent volumes, allowing local development and testing with AWS-like services.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/localstack.md#_snippet_13

LANGUAGE: yaml
CODE:
```
services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - 5000:5000
    depends_on:
      - localstack
      - mongodb
    env_file:
      - backend/.env

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - 5173:5173
    depends_on:
      - backend
    environment:
      - REACT_APP_API_URL=http://backend:5000/api

  mongodb:
    image: mongo
    container_name: mongodb
    volumes:
      - mongodbdata:/data/db
    ports:
      - 27017:27017

  localstack:
    image: localstack/localstack
    container_name: localstack
    ports:
      - 4566:4566
    environment:
      - SERVICES=s3
      - GATEWAY_LISTEN=0.0.0.0:4566
    volumes:
      - ./localstack:/docker-entrypoint-initaws.d"

volumes:
  mongodbdata:
```

----------------------------------------

TITLE: Check Docker Swarm Service Status and Output
DESCRIPTION: This command lists the tasks (containers) associated with the 'demo' Docker Swarm service. The output shows the ID, name, image, node, and current state of the service's running container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/orchestration.md#_snippet_14

LANGUAGE: console
CODE:
```
$ docker service ps demo
```

LANGUAGE: shell
CODE:
```
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE           ERROR               PORTS
463j2s3y4b5o        demo.1              alpine:latest       docker-desktop      Running             Running 8 seconds ago
```

----------------------------------------

TITLE: Defining ENTRYPOINT with Exec Form in Dockerfile
DESCRIPTION: This snippet demonstrates the exec form for the `ENTRYPOINT` instruction. It uses a JSON array format, requiring double-quotes for arguments. This form is ideal for specifying a fixed command that can be combined with `CMD` for default arguments, and it does not automatically invoke a command shell, meaning variable substitution must be handled explicitly by executing a shell.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_31

LANGUAGE: Dockerfile
CODE:
```
ENTRYPOINT ["/bin/bash", "-c", "echo hello"]
```

----------------------------------------

TITLE: Configuring Build Context with Relative Path (YAML)
DESCRIPTION: This snippet shows how to specify a build context using a relative path to the Compose file's parent folder. The specified directory must contain a `Dockerfile` for the build to succeed.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/build.md#_snippet_1

LANGUAGE: YAML
CODE:
```
services:
    webapp:
      build: ./dir
```

----------------------------------------

TITLE: Run Docker Development Container with Bind Mount
DESCRIPTION: This command initiates a Docker container for development, mapping port 3000 and mounting the current host directory to /app inside the container. It uses the node:18-alpine image to install Node.js dependencies and start the application with nodemon for live reloading, ensuring changes on the host are reflected in the container.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/06_bind_mounts.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 \
    -w /app --mount type=bind,src="$(pwd)",target=/app \
    node:18-alpine \
    sh -c "yarn install && yarn run dev"
```

LANGUAGE: powershell
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 `
    -w /app --mount "type=bind,src=$pwd,target=/app" `
    node:18-alpine `
    sh -c "yarn install && yarn run dev"
```

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 ^
    -w /app --mount "type=bind,src=%cd%,target=/app" ^
    node:18-alpine ^
    sh -c "yarn install && yarn run dev"
```

----------------------------------------

TITLE: Defining Services with Docker Compose for Golang Monitoring
DESCRIPTION: This Docker Compose YAML snippet defines the services required to monitor a Golang application using Prometheus and Grafana. It configures the Golang API service with a build context, port mapping, and a health check. It also sets up Prometheus with a custom configuration volume and Grafana with data persistence and datasource provisioning, all connected via a shared network.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/go-prometheus-monitoring/compose.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  api:
    container_name: go-api
    build:
      context: .
      dockerfile: Dockerfile
    image: go-api:latest
    ports:
      - 8000:8000
    networks:
      - go-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 5
    develop:
      watch:
        - path: .
          action: rebuild
      
  prometheus:
    container_name: prometheus
    image: prom/prometheus:v2.55.0
    volumes:
      - ./Docker/prometheus.yml:/etc/prometheus/prometheus.yml
    ports:
      - 9090:9090
    networks:
      - go-network
  
  grafana:
    container_name: grafana
    image: grafana/grafana:11.3.0
    volumes:
      - ./Docker/grafana.yml:/etc/grafana/provisioning/datasources/datasource.yaml
      - grafana-data:/var/lib/grafana
    ports:
      - 3000:3000
    networks:
      - go-network
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=password

volumes:
  grafana-data:

networks:
  go-network:
    driver: bridge
```

----------------------------------------

TITLE: Run Docker Container with Docker Compose
DESCRIPTION: This snippet shows how to use the `docker compose up` command to build and run the services defined in a `compose.yaml` file. The `--build` option ensures that your image is rebuilt from the Dockerfile before starting the containers, which is useful after making changes.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/jupyter.md#_snippet_10

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Start Docker Compose Application Stack
DESCRIPTION: Execute this command at the root of your project directory to start the entire application stack defined in the compose.yml file. The '-d' flag runs services in detached mode, and '--build' ensures images are built if necessary.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/localstack.md#_snippet_15

LANGUAGE: console
CODE:
```
docker compose -f compose.yml up -d --build
```

----------------------------------------

TITLE: Docker Compose Configuration for Spring Boot Development and Debugging
DESCRIPTION: This `docker-compose.yaml` file orchestrates the local development environment. It configures a 'server' service to build from the 'development' stage of the Dockerfile, exposing both the application port (8080) and the JVM debug port (8000). It also defines a 'db' service using PostgreSQL, complete with volume mapping, environment variables, and a health check.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/develop.md#_snippet_4

LANGUAGE: YAML
CODE:
```
services:
  server:
    build:
      context: .
      target: development
    ports:
      - 8080:8080
      - 8000:8000
    depends_on:
      db:
        condition: service_healthy
    environment:
      - POSTGRES_URL=jdbc:postgresql://db:5432/petclinic
  db:
    image: postgres
    restart: always
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=petclinic
      - POSTGRES_USER=petclinic
      - POSTGRES_PASSWORD=petclinic
    ports:
      - 5432:5432
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "petclinic"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
```

----------------------------------------

TITLE: Create SBOM Attestations for Docker Images
DESCRIPTION: Demonstrates how to generate an SBOM attestation for a Docker image during the build process using `docker buildx build` with the `--attest type=sbom` or `--sbom=true` option. The image is then pushed to a registry, attaching the SBOM as a JSON-encoded SPDX document.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/metadata/attestations/sbom.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker buildx build --tag <namespace>/<image>:<version> \
    --attest type=sbom --push .
```

----------------------------------------

TITLE: Build Docker Image with Provenance and SBOM Attestations
DESCRIPTION: This command rebuilds a Docker image, adding `--provenance=true` and `--sbom=true` flags. These flags attach Software Bill of Materials (SBOM) and provenance attestations, enabling a more complete and accurate policy evaluation by Docker Scout.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/quickstart.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker build --provenance=true --sbom=true --push -t <ORG_NAME>/scout-demo:v3 .
```

----------------------------------------

TITLE: Build Docker Image for Node.js Application
DESCRIPTION: Builds a Docker image from the Dockerfile in the current directory, tagging it with the specified Docker username and repository name. The dot (.) indicates the build context is the current directory.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-registry.md#_snippet_3

LANGUAGE: console
CODE:
```
docker build -t <YOUR_DOCKER_USERNAME>/docker-quickstart .
```

----------------------------------------

TITLE: Specify the base image for the Docker build
DESCRIPTION: This command sets the foundation for the Docker image. `python:3.8-slim` is a lightweight version of the Python 3.8 image, optimized for size and speed, which reduces the overall size of your Docker image, leading to quicker downloads and less surface area for security vulnerabilities. This is particularly useful for Python-based applications that don't require the full standard Python image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/named-entity-recognition.md#_snippet_10

LANGUAGE: dockerfile
CODE:
```
FROM python:3.8-slim
```

----------------------------------------

TITLE: Setting Working Directory in Dockerfile
DESCRIPTION: This snippet shows the basic syntax for the `WORKDIR` instruction, which defines the working directory for all subsequent `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions. If the specified directory does not exist, it will be created.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_142

LANGUAGE: Dockerfile
CODE:
```
WORKDIR /path/to/workdir
```

----------------------------------------

TITLE: Dockerfile for Python Flask Application
DESCRIPTION: A Dockerfile to create a container image for the Python Flask 'Hello World' application, installing necessary dependencies and copying the application code.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/concepts/dockerfile.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM ubuntu:22.04

# install app dependencies
RUN apt-get update && apt-get install -y python3 python3-pip
RUN pip install flask==3.0.*

# install app
COPY hello.py /
```

----------------------------------------

TITLE: Run MySQL Container with Docker CLI
DESCRIPTION: This command runs a MySQL container named 'my-mysql' in detached mode. It sets the root password to 'my-secret-pw' and optionally creates a database named 'mydb'. The `mysql:latest` image is used. After running, you can verify the container is active using `docker ps`.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=mydb -d mysql:latest
```

----------------------------------------

TITLE: Push Docker Image to Remote Registry
DESCRIPTION: Use this command to push your locally built Docker image to a remote registry, such as Docker Hub. Ensure you are logged in and your image tag matches your Docker Hub username to avoid access denied errors.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/build-tag-and-publish-an-image.md#_snippet_11

LANGUAGE: console
CODE:
```
$ docker push <YOUR_DOCKER_USERNAME>/concepts-build-image-demo
```

----------------------------------------

TITLE: Run PostgreSQL in a Docker container with volume and network
DESCRIPTION: Run the PostgreSQL Official Image in a Docker container, attaching it to the previously created volume for data persistence and the network for inter-container communication. This command pulls the image from Docker Hub and configures environment variables for the database.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/develop.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker run --rm -d --mount \
  "type=volume,src=db-data,target=/var/lib/postgresql/data" \
  -p 5432:5432 \
  --network postgresnet \
  --name db \
  -e POSTGRES_PASSWORD=mysecretpassword \
  -e POSTGRES_DB=example \
  postgres
```

----------------------------------------

TITLE: Build and Start Docker Compose Services for Local Development
DESCRIPTION: This command builds the Docker images for all services defined in `docker-compose.yaml` and starts them. The `--build` flag ensures that any changes to the Dockerfile are incorporated, making it suitable for iterative development.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/develop.md#_snippet_5

LANGUAGE: Console
CODE:
```
docker compose up --build
```

----------------------------------------

TITLE: Run Docker Compose application in detached mode
DESCRIPTION: This command starts the Docker Compose application in detached mode, allowing it to run in the background without occupying the terminal. It also builds necessary images if they are not present.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/containerize.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker compose up --build -d
```

----------------------------------------

TITLE: Run Docker Container for Sentiment Analysis
DESCRIPTION: This command runs a new container from the `basic-nlp` Docker image. The `-it` flags enable interactive mode and allocate a pseudo-TTY, allowing interaction with the `01_sentiment_analysis.py` script inside the container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/sentiment-analysis.md#_snippet_17

LANGUAGE: console
CODE:
```
$ docker run -it basic-nlp 01_sentiment_analysis.py
```

----------------------------------------

TITLE: Defining Production Volumes in Docker Compose YAML
DESCRIPTION: This YAML snippet defines named volumes for a Laravel production environment. `postgres-data-production` is intended for PostgreSQL data persistence, and `laravel-storage-production` is for Laravel application storage, ensuring data integrity and separation from service containers.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/production-setup.md#_snippet_15

LANGUAGE: YAML
CODE:
```
laravel-production:

volumes:
  postgres-data-production:
  laravel-storage-production:
```

----------------------------------------

TITLE: Docker Compose Watch Configuration: Sync and Rebuild Actions
DESCRIPTION: This YAML configuration demonstrates the Docker Compose `watch` feature for a Node.js application. It sets up two watch actions: one to `sync` changes from the local `./web` directory (excluding `node_modules/`) to `/src/web` in the container, and another to `rebuild` the service when `package.json` is modified, ensuring dependencies are updated. The `path` and `target` fields control how local paths are mapped into the container.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/file-watch.md#_snippet_3

LANGUAGE: yaml
CODE:
```
services:
  web:
    build: .
    command: npm start
    develop:
      watch:
        - action: sync
          path: ./web
          target: /src/web
          ignore:
            - node_modules/
        - action: rebuild
          path: package.json
```

----------------------------------------

TITLE: Configuring Docker Compose for Angular Production and Development
DESCRIPTION: This `compose.yaml` file defines two services: `angular-prod` for serving a static production build and `angular-dev` for running the Angular development server with live reload. The `develop.watch` section enables automatic file synchronization using Compose Watch, mapping the local project root to `/app` in the container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/angular/develop.md#_snippet_1

LANGUAGE: yaml
CODE:
```
services:
  angular-prod:
    build:
      context: .
      dockerfile: Dockerfile
    image: docker-angular-sample
    ports:
      - "8080:8080"

  angular-dev:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "4200:4200"
    develop:
      watch:
        - action: sync
          path: .
          target: /app
```

----------------------------------------

TITLE: Dockerfile with Cross-Compilation Support for Go
DESCRIPTION: An updated Dockerfile demonstrating how to enable cross-compilation for Go applications. It utilizes Docker's pre-defined build arguments (BUILDPLATFORM, TARGETOS, TARGETARCH) and sets Go's GOOS and GOARCH environment variables to build for specific target platforms natively.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-platform.md#_snippet_16

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM --platform=$BUILDPLATFORM golang:alpine AS build
ARG TARGETOS
ARG TARGETARCH
WORKDIR /app
ADD https://github.com/dvdksn/buildme.git#eb6279e0ad8a10003718656c6867539bd9426ad8 .
RUN GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o server .

FROM alpine
COPY --from=build /app/server /server
ENTRYPOINT ["/server"]
```

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM golang:alpine AS build
WORKDIR /app
ADD https://github.com/dvdksn/buildme.git#eb6279e0ad8a10003718656c6867539bd9426ad8 .
RUN go build -o server .

FROM alpine
COPY --from=build /app/server /server
ENTRYPOINT ["/server"]
```

LANGUAGE: diff
CODE:
```
# syntax=docker/dockerfile:1
-FROM golang:alpine AS build
+FROM --platform=$BUILDPLATFORM golang:alpine AS build
+ARG TARGETOS
+ARG TARGETARCH
WORKDIR /app
ADD https://github.com/dvdksn/buildme.git#eb6279e0ad8a10003718656c6867539bd9426ad8 .
-RUN go build -o server .
+RUN GOOS=${TARGETOS} GOARCH=${TARGETARCH} go build -o server .

FROM alpine
COPY --from=build /app/server /server
ENTRYPOINT ["/server"]
```

----------------------------------------

TITLE: Creating a Multi-Stage Dockerfile for Java Applications
DESCRIPTION: This Dockerfile demonstrates a multi-stage build for a Java application. The 'builder' stage compiles the application using a JDK, while the 'final' stage uses a JRE to run the compiled JAR, significantly reducing the final image size by excluding build-time dependencies.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/multi-stage-builds.md#_snippet_17

LANGUAGE: dockerfile
CODE:
```
FROM eclipse-temurin:21.0.2_13-jdk-jammy AS builder
WORKDIR /opt/app
COPY .mvn/ .mvn
COPY mvnw pom.xml ./
RUN ./mvnw dependency:go-offline
COPY ./src ./src
RUN ./mvnw clean install

FROM eclipse-temurin:21.0.2_13-jre-jammy AS final
WORKDIR /opt/app
EXPOSE 8080
COPY --from=builder /opt/app/target/*.jar /opt/app/*.jar
ENTRYPOINT ["java", "-jar", "/opt/app/*.jar"]
```

----------------------------------------

TITLE: Push a Docker image to Docker Hub
DESCRIPTION: This command pushes the locally built Docker image to Docker Hub. It automatically creates the repository if it doesn't exist. You must be signed in to Docker Hub through Docker Desktop or the command line, and name your images correctly. Replace <YOUR-USERNAME> with your Docker ID.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/docker-hub/quickstart.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker push <YOUR-USERNAME>/nginx-custom
```

----------------------------------------

TITLE: Creating a Development Dockerfile for React.js
DESCRIPTION: This Dockerfile sets up a lightweight Node.js environment for developing a React.js application. It copies package-related files first to leverage Docker's caching, installs dependencies, then copies the rest of the source code. It exposes port 5173 for the Vite development server and sets 'npm run dev' as the default command.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/develop.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# =========================================
# Stage 1: Develop the React.js Application
# =========================================
ARG NODE_VERSION=22.14.0-alpine

# Use a lightweight Node.js image for development
FROM node:${NODE_VERSION} AS dev

# Set the working directory inside the container
WORKDIR /app

# Copy package-related files first to leverage Docker's caching mechanism
COPY package.json package-lock.json ./

# Install project dependencies
RUN --mount=type=cache,target=/root/.npm npm install

# Copy the rest of the application source code into the container
COPY . .

# Expose the port used by the Vite development server
EXPOSE 5173

# Use a default command, can be overridden in Docker compose.yml file
CMD ["npm", "run", "dev"]
```

----------------------------------------

TITLE: GitHub Actions Workflow for Docker CI/CD
DESCRIPTION: This YAML configuration defines a GitHub Actions workflow named 'ci'. It triggers on pushes to the `main` branch and includes jobs to log in to Docker Hub, set up Docker Buildx, build and test the Docker image, and finally build and push the production image to Docker Hub with specific platforms and tags.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/configure-ci-cd.md#_snippet_2

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and test
        uses: docker/build-push-action@v6
        with:
          target: test
          load: true

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          platforms: linux/amd64,linux/arm64
          push: true
          target: prod
          tags: ${{ vars.DOCKER_USERNAME }}/${{ github.event.repository.name }}:latest
```

----------------------------------------

TITLE: Initialize Docker Assets with docker init
DESCRIPTION: Run `docker init` within the `docker-php-sample` directory to generate essential Docker configuration files like `Dockerfile` and `compose.yaml`. The example shows the interactive prompts and recommended answers for a PHP 8.2 application with Apache, using `./src` as the app directory and port `9000`.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/php/containerize.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker init
Welcome to the Docker Init CLI!

This utility will walk you through creating the following files with sensible defaults for your project:
  - .dockerignore
  - Dockerfile
  - compose.yaml
  - README.Docker.md

Let's get started!

? What application platform does your project use? PHP with Apache
? What version of PHP do you want to use? 8.2
? What's the relative directory (with a leading .) for your app? ./src
? What local port do you want to use to access your server? 9000
```

----------------------------------------

TITLE: Run Docker Compose Command and Remove Container
DESCRIPTION: Illustrates how to run a one-time command, such as a database upgrade script, and automatically remove the container upon completion, overriding any defined restart policy using the `--rm` flag.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_run.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker compose run --rm web python manage.py db upgrade
```

----------------------------------------

TITLE: Run Docker container with a specific GPU exposed by ID
DESCRIPTION: Expose a single NVIDIA GPU to a Docker container by specifying its unique device ID using `--gpus device=<ID>`. This allows precise control over which GPU resources are accessible to the container.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/containers/resource_constraints.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker run -it --rm --gpus device=GPU-3a23c669-1f69-c64e-cf85-44e9b07e7a2a ubuntu nvidia-smi
```

----------------------------------------

TITLE: Attach Docker Scout SBOM as build attestation
DESCRIPTION: Configure BuildKit to use the Docker Scout SBOM generator by using the `--attest` flag with `docker build`. This attaches the SBOM as an attestation to the image at build-time, providing richer results and better compatibility with Docker Scout image analysis. This requires using the containerd image store or pushing the image directly to a registry.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/how-tos/view-create-sboms.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker build --tag <org>/<image> \
  --attest type=sbom,generator=docker/scout-sbom-indexer:latest \
  --push .
```

----------------------------------------

TITLE: Define Dockerfile Base Image
DESCRIPTION: Specifies the base image for the Docker container. Using `node:20-alpine` provides a lightweight Node.js 20 environment.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/writing-a-dockerfile.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
FROM node:20-alpine
```

----------------------------------------

TITLE: Listing Local Docker Images
DESCRIPTION: This command lists all Docker images currently available on the local machine. It is used to verify the names and tags of existing images, helping to confirm why a push operation might fail due to incorrect tagging or missing images.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/04_sharing_app.md#_snippet_1

LANGUAGE: console
CODE:
```
docker image ls
```

----------------------------------------

TITLE: Running Golang Application in Docker Container
DESCRIPTION: This command runs a new Docker container from the `go-api:latest` image. The `-p 8000:8000` flag maps port 8000 of the host machine to port 8000 inside the container, allowing external access to the application. The container will start the application defined by the Dockerfile's `CMD` instruction.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/go-prometheus-monitoring/containerize.md#_snippet_2

LANGUAGE: Shell
CODE:
```
$ docker run -p 8000:8000 go-api:latest
```

----------------------------------------

TITLE: Create New File in Bind-Mounted Directory
DESCRIPTION: This sequence shows how to create a new file (myfile.txt) within the /src directory inside the container. The subsequent ls command confirms its creation, illustrating that changes made in the container are immediately reflected in the host's bind-mounted directory.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/06_bind_mounts.md#_snippet_4

LANGUAGE: console
CODE:
```
root@ac1237fad8db:/src# touch myfile.txt
root@ac1237fad8db:/src# ls
Dockerfile  myfile.txt  node_modules  package.json  spec  src  yarn.lock
```

----------------------------------------

TITLE: Docker Run Command with --volume Flag Syntax
DESCRIPTION: Shows the general syntax for using the `--volume` or `-v` flag with `docker run`, specifying the host path, container path, and an optional colon-separated list of options.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/bind-mounts.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker run -v <host-path>:<container-path>[:opts]
```

----------------------------------------

TITLE: CMD Instruction Exec Form as Default Parameters in Dockerfile
DESCRIPTION: This `CMD` instruction in exec form provides default arguments that will be appended to the `ENTRYPOINT` instruction. If the user provides arguments to `docker run`, these `CMD` arguments will be overridden, but the `ENTRYPOINT` will still execute.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_62

LANGUAGE: Dockerfile
CODE:
```
CMD ["param1","param2"]
```

----------------------------------------

TITLE: Specifying BuildKit Frontend in Dockerfile
DESCRIPTION: To mitigate CVE-2024-23650, CVE-2024-23651, CVE-2024-23652, and CVE-2024-23653, avoid using BuildKit frontends from untrusted sources. The frontend image is typically specified using the #syntax line at the beginning of your Dockerfile, which should point to a trusted source.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/security/security-announcements.md#_snippet_4

LANGUAGE: Dockerfile
CODE:
```
#syntax
```

----------------------------------------

TITLE: Add Kafka UI to Docker Compose for Cluster Visualization
DESCRIPTION: This YAML configuration adds the Kafbat UI web application as a service to the Docker Compose stack. It exposes port 8080 for accessing the UI, configures it to connect to the Kafka service (using its internal network alias `kafka:9093`), and sets a dependency on the Kafka service to ensure correct startup order. This allows for easy visualization and management of the Kafka cluster.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/kafka.md#_snippet_14

LANGUAGE: yaml
CODE:
```
services:
  kafka-ui:
    image: kafbat/kafka-ui:main
    ports:
      - 8080:8080
    environment:
      DYNAMIC_CONFIG_ENABLED: "true"
      KAFKA_CLUSTERS_0_NAME: local
      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9093
    depends_on:
      - kafka
```

----------------------------------------

TITLE: Automated Testing Environment Setup and Teardown with Docker Compose
DESCRIPTION: This snippet demonstrates how to set up and tear down an isolated testing environment using Docker Compose. It starts the services in detached mode, runs the test suite, and then stops and removes the containers, ensuring a clean state for each test run.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/intro/features-uses.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker compose up -d
$ ./run_tests
$ docker compose down
```

----------------------------------------

TITLE: Set the working directory inside the Docker image
DESCRIPTION: `WORKDIR` sets the current working directory within the Docker image. By setting it to `/app`, all subsequent commands in the Dockerfile (like `COPY` and `RUN`) are executed in this directory, helping organize application-related files within a specific location in the image.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/named-entity-recognition.md#_snippet_11

LANGUAGE: dockerfile
CODE:
```
WORKDIR /app
```

----------------------------------------

TITLE: Define working directory and volumes in Docker Compose
DESCRIPTION: Configures the `app` service in `compose.yaml` with a `working_dir` of `/app` and mounts the current directory (`.`) from the host into `/app` inside the container, enabling live code changes.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_5

LANGUAGE: yaml
CODE:
```
services:
  app:
    image: node:18-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 127.0.0.1:3000:3000
    working_dir: /app
    volumes:
      - ./:/app
```

----------------------------------------

TITLE: Configuring Nginx and Copying Laravel Assets in Docker
DESCRIPTION: This Dockerfile snippet replaces the default Nginx configuration with a custom one optimized for Laravel, copies public assets from a previous 'builder' stage, sets the working directory to the public folder, exposes port 80, and starts the Nginx server. It is designed for the final stage of a multi-stage Docker build.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/production-setup.md#_snippet_13

LANGUAGE: Dockerfile
CODE:
```
COPY ./docker/nginx/nginx.conf /etc/nginx/nginx.conf

COPY --from=builder /var/www/public /var/www/public

WORKDIR /var/www/public

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

----------------------------------------

TITLE: Docker Compose File for Stack Deployment (`compose.yaml`)
DESCRIPTION: Defines the services for the application stack: a 'web' service built from the current directory and tagged for the local registry, exposing port 8000; and a 'redis' service using the `redis:alpine` image. This file describes how the application components are orchestrated.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/swarm/stack-deploy.md#_snippet_7

LANGUAGE: yaml
CODE:
```
services:
  web:
    image: 127.0.0.1:5000/stackdemo
    build: .
    ports:
      - "8000:8000"
  redis:
    image: redis:alpine
```

----------------------------------------

TITLE: Configure Docker Compose for Ruby on Rails with PostgreSQL
DESCRIPTION: This YAML configuration defines two services: `web` for the Ruby on Rails application and `db` for a PostgreSQL database. It sets up port mapping, dependencies, environment variables, and uses a Docker secret for the database password. A named volume, `postgres_data`, is defined to ensure database persistence across container restarts.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/ruby/develop.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  web:
    build: .
    command: bundle exec rails s -b '0.0.0.0'
    ports:
      - "3000:3000"
    depends_on:
      - db
    environment:
      - RAILS_ENV=test
    env_file: "webapp.env"
  db:
    image: postgres:latest
    secrets:
      - db-password
    environment:
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Updating Vite Configuration for Docker Compatibility
DESCRIPTION: This TypeScript configuration for Vite ensures the development server functions correctly within a Docker container. Setting `host: true` makes the server accessible externally, `port: 5173` ensures a consistent port, and `strictPort: true` prevents silent port switching, which is crucial for containerized environments.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/develop.md#_snippet_2

LANGUAGE: typescript
CODE:
```
/// <reference types="vitest" />

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  base: "/",
  plugins: [react()],
  server: {
    host: true,
    port: 5173,
    strictPort: true,
  },
});
```

----------------------------------------

TITLE: GitHub Actions Workflow for Docker Buildx External Cache
DESCRIPTION: This GitHub Actions workflow demonstrates how to configure docker/build-push-action to utilize an external OCI registry for build cache. It uses --cache-from to pull existing cache and --cache-to to push new cache layers, optimizing CI/CD build times by reusing cache across ephemeral builders.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/optimize.md#_snippet_9

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: user/app:latest
          cache-from: type=registry,ref=user/app:buildcache
          cache-to: type=registry,ref=user/app:buildcache,mode=max
```

----------------------------------------

TITLE: Configure Docker Compose for automatic service updates
DESCRIPTION: This `compose.yaml` file defines two services: `shiny-app` and `db`. The `shiny-app` service includes a `develop.watch` section that triggers an image rebuild when files in the current directory (`.`) are changed. The `db` service uses a PostgreSQL image with data persistence and health checks. Both services utilize shared secrets for database passwords.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/r/develop.md#_snippet_7

LANGUAGE: yaml
CODE:
```
services:
  shiny-app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 3838:3838
    environment:
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    depends_on:
      db:
        condition: service_healthy
    secrets:
      - db-password
    develop:
      watch:
        - action: rebuild
          path: .
  db:
    image: postgres
    restart: always
    user: postgres
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      - POSTGRES_DB=example
      - POSTGRES_PASSWORD_FILE=/run/secrets/db-password
    expose:
      - 5432
    healthcheck:
      test: ["CMD", "pg_isready"]
      interval: 10s
      timeout: 5s
      retries: 5
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Build Docker Image with Tag
DESCRIPTION: Builds the Docker image for the application from the current directory, tagging it with your Docker username. Replace <DOCKER_USERNAME> with your actual Docker ID. An example is provided for 'mobydock'.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/introduction/build-and-push-first-image.md#_snippet_2

LANGUAGE: Shell
CODE:
```
docker build -t <DOCKER_USERNAME>/getting-started-todo-app .

# Example:
docker build -t mobydock/getting-started-todo-app .
```

----------------------------------------

TITLE: Copying from a Named Build Stage
DESCRIPTION: This multi-stage Dockerfile demonstrates using `COPY --from=<stage_name>` to copy files from a previously defined build stage. The `build` stage compiles `hello.c` into an executable `/hello`, which is then copied to the final `scratch` image, reducing the final image size.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_107

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine AS build
COPY . .
RUN apk add clang
RUN clang -o /hello hello.c

FROM scratch
COPY --from=build /hello /
```

----------------------------------------

TITLE: Run Docker Compose application in foreground
DESCRIPTION: This command starts the Docker Compose application, building necessary images if they don't exist. The application runs in the foreground, and logs are displayed directly in the terminal. Press `Ctrl+C` to stop the application.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/containerize.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker compose up --build
```

----------------------------------------

TITLE: Using Local Cache with Docker Buildx
DESCRIPTION: This `docker buildx build` command demonstrates how to utilize the `local` cache backend for Docker image builds. It configures both cache export (`--cache-to`) and import (`--cache-from`) to and from a specified local directory. The `dest` parameter points to the local directory for exporting cache, while `src` indicates the directory for importing cache, enabling efficient reuse of build layers.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/backends/local.md#_snippet_0

LANGUAGE: Shell
CODE:
```
$ docker buildx build --push -t <registry>/<image> \
  --cache-to type=local,dest=path/to/local/dir[,parameters...] \
  --cache-from type=local,src=path/to/local/dir .
```

----------------------------------------

TITLE: Prune Docker system: containers, networks, images
DESCRIPTION: This command removes all stopped containers, networks not used by any container, and dangling images, along with unused build cache. It prompts for user confirmation before proceeding with the removal.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/manage-resources/pruning.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker system prune

WARNING! This will remove:
        - all stopped containers
        - all networks not used by at least one container
        - all dangling images
        - unused build cache

Are you sure you want to continue? [y/N] y
```

----------------------------------------

TITLE: Set Dockerfile Working Directory
DESCRIPTION: Defines the working directory inside the container. All subsequent commands and file operations will be relative to this path.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/writing-a-dockerfile.md#_snippet_3

LANGUAGE: dockerfile
CODE:
```
WORKDIR /app
```

----------------------------------------

TITLE: Start updated Docker application container successfully
DESCRIPTION: Starts a new Docker container from the `getting-started` image, mapping host port 3000 to container port 3000 in detached mode. This command should succeed after the old container has been stopped and removed, resolving the port conflict.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/03_updating_app.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker run -dp 127.0.0.1:3000:3000 getting-started
```

----------------------------------------

TITLE: Run Docker Compose Application with Build
DESCRIPTION: Execute this command to build the Docker images and start the services defined in the `compose.yaml` file. The `--build` flag ensures that images are rebuilt if changes have been made to the Dockerfile.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/nodejs/develop.md#_snippet_9

LANGUAGE: console
CODE:
```
docker compose up --build
```

----------------------------------------

TITLE: Docker Compose: Override Default CMD and ENTRYPOINT
DESCRIPTION: This snippet shows how to override the default CMD and ENTRYPOINT of a Docker image within a compose.yml file. It configures a Postgres service with custom startup commands, demonstrates bringing up the service, and connecting to the database inside the container.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/overriding-container-defaults.md#_snippet_8

LANGUAGE: yaml
CODE:
```
services:
  postgres:
    image: postgres
    entrypoint: ["docker-entrypoint.sh", "postgres"]
    command: ["-h", "localhost", "-p", "5432"]
    environment:
      POSTGRES_PASSWORD: secret
```

LANGUAGE: console
CODE:
```
$ docker compose up -d
```

LANGUAGE: console
CODE:
```
# psql -U postgres
```

----------------------------------------

TITLE: Create a new Docker Buildx builder
DESCRIPTION: Use the `docker buildx create` command to provision a new builder instance. By default, it uses the `docker-container` driver, which runs the BuildKit daemon in a container. Specify a name for the new builder.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/builders/manage.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker buildx create --name=<builder-name>
```

----------------------------------------

TITLE: General Syntax for RUN --mount in Dockerfile
DESCRIPTION: This snippet illustrates the general syntax for the `RUN --mount` command in a Dockerfile. It allows creating filesystem mounts during the build process, enabling features like bind mounts, accessing secrets, or utilizing persistent caches. The command supports various mount types, each with specific options.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_47

LANGUAGE: Dockerfile
CODE:
```
RUN --mount=[type=<TYPE>][,option=<value>[,option=<value>]...]
```

----------------------------------------

TITLE: Dockerfile for Rust 'Hello World' binary
DESCRIPTION: A multi-stage Dockerfile that compiles a simple Rust 'Hello World' program and copies the resulting binary to a minimal scratch image. It demonstrates the use of here-documents for inline code.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/export.md#_snippet_1

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM rust:alpine AS build
WORKDIR /src
COPY <<EOT hello.rs
fn main() {
    println!("Hello World!");
}
EOT
RUN rustc -o /bin/hello hello.rs

FROM scratch
COPY --from=build /bin/hello /
ENTRYPOINT ["/hello"]
```

----------------------------------------

TITLE: COPY Instruction Syntax
DESCRIPTION: This shows the two forms of the `COPY` instruction syntax. The second form, using double quotes, is required when source paths contain whitespace, ensuring proper parsing of the paths. It copies files or directories from a source to a destination within the image.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_99

LANGUAGE: dockerfile
CODE:
```
COPY [OPTIONS] <src> ... <dest>
COPY [OPTIONS] ["<src>", ... "<dest>"]
```

----------------------------------------

TITLE: Docker Compose: Using Multiple --env-file Options
DESCRIPTION: This command demonstrates the use of multiple --env-file options to specify several environment files. Docker Compose reads these files in the order provided, allowing later files to override variables defined in earlier ones, enabling layered environment configurations.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/environment-variables/variable-interpolation.md#_snippet_9

LANGUAGE: console
CODE:
```
$ docker compose --env-file .env --env-file .env.override up
```

----------------------------------------

TITLE: Define Docker Image for Nginx Static Content
DESCRIPTION: This Dockerfile defines the build instructions for a Docker image. It uses a slim Nginx Alpine base image, sets the working directory, and copies the application's static content into the Nginx serving directory.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/tensorflowjs.md#_snippet_6

LANGUAGE: dockerfile
CODE:
```
FROM nginx:stable-alpine3.17-slim
WORKDIR /usr/share/nginx/html
COPY . .
```

----------------------------------------

TITLE: Adding Attestations with Docker Buildx Build Command
DESCRIPTION: Demonstrates how to use the new `--attest` flag, along with shorthands `--sbom` and `--provenance`, to add SBOM and SLSA provenance attestations to your Docker builds. These flags enable embedding metadata about the build process and its dependencies directly into the image.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/release-notes.md#_snippet_0

LANGUAGE: shell
CODE:
```
docker buildx build --attest type=sbom .
docker buildx build --sbom=true .
docker buildx build --attest type=provenance .
docker buildx build --provenance=true .
```

----------------------------------------

TITLE: Enable Background SBOM Indexing with Docker Scout
DESCRIPTION: This setting allows Docker Scout to automatically analyze images built or pulled in the background, generating Software Bill of Materials (SBOM).
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/settings-and-maintenance/settings.md#_snippet_3

LANGUAGE: APIDOC
CODE:
```
Setting: Enable background SBOM indexing
  Description: Docker Scout automatically analyzes images built or pulled.
```

----------------------------------------

TITLE: Configure Docker Compose Watch for Automatic Updates
DESCRIPTION: This YAML configuration modifies the `compose.yaml` file to enable Compose Watch for the `server` service. The `develop.watch` section specifies that changes in the local `./src` directory should be synchronized to `/var/www/html` inside the container, allowing for automatic updates during development.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/php/develop.md#_snippet_8

LANGUAGE: yaml
CODE:
```
services:
  server:
    build:
      context: .
    ports:
      - 9000:80
    depends_on:
      db:
        condition: service_healthy
    secrets:
      - db-password
    environment:
      - PASSWORD_FILE_PATH=/run/secrets/db-password
      - DB_HOST=db
      - DB_NAME=example
      - DB_USER=root
    develop:
      watch:
        - action: sync
          path: ./src
          target: /var/www/html
  db:
    image: mariadb
    restart: always
    user: root
    secrets:
      - db-password
    volumes:
      - db-data:/var/lib/mysql
    environment:
      - MARIADB_ROOT_PASSWORD_FILE=/run/secrets/db-password
      - MARIADB_DATABASE=example
    expose:
      - 3306
    healthcheck:
      test:
        [
          "CMD",
          "/usr/local/bin/healthcheck.sh",
          "--su-mysql",
          "--connect",
          "--innodb_initialized"
        ]
      interval: 10s
      timeout: 5s
      retries: 5
  phpmyadmin:
    image: phpmyadmin
    ports:
      - 8080:80
    depends_on:
      - db
    environment:
      - PMA_HOST=db
volumes:
  db-data:
secrets:
  db-password:
    file: db/password.txt
```

----------------------------------------

TITLE: Dockerfile: Unset ENV Variable in a Single Layer
DESCRIPTION: Illustrates the correct method to set and unset an environment variable within a single `RUN` instruction. This ensures the variable does not persist in the final image layer, improving image cleanliness and security.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_23

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine
RUN export ADMIN_USER="mark" \
    && echo $ADMIN_USER > ./mark \
    && unset ADMIN_USER
CMD sh
```

----------------------------------------

TITLE: Executing Artisan Command via Docker Compose (Console)
DESCRIPTION: This command uses docker compose to execute a PHP Artisan command (route:list) inside the php-fpm service container defined in compose.prod.yaml. It's a common way to run CLI tasks in a production environment without a separate CLI container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/frameworks/laravel/production-setup.md#_snippet_10

LANGUAGE: Console
CODE:
```
$ docker compose -f compose.prod.yaml exec php-fpm php artisan route:list
```

----------------------------------------

TITLE: Pull Docker Image by Digest
DESCRIPTION: Command to pull a Docker image using its immutable SHA-256 digest, ensuring the exact image version is retrieved. Replace `<image-name>` and `<digest>` with the appropriate values.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/dhi/core-concepts/digests.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker pull <image-name>@sha256:<digest>
```

----------------------------------------

TITLE: Deploy WordPress Docker Service with MySQL Connection
DESCRIPTION: This command creates a Docker service for WordPress, configured to connect to the previously deployed MySQL service. It exposes WordPress on port 30000 of the host, mounts a volume for persistent storage of themes and plugins, and securely accesses the MySQL password via a Docker secret. Environment variables are set to configure WordPress's database connection details.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/swarm/secrets.md#_snippet_40

LANGUAGE: console
CODE:
```
$ docker service create \
     --name wordpress \
     --replicas 1 \
     --network mysql_private \
     --publish published=30000,target=80 \
     --mount type=volume,source=wpdata,destination=/var/www/html \
     --secret source=mysql_password,target=wp_db_password \
     -e WORDPRESS_DB_USER="wordpress" \
     -e WORDPRESS_DB_PASSWORD_FILE="/run/secrets/wp_db_password" \
     -e WORDPRESS_DB_HOST="mysql:3306" \
     -e WORDPRESS_DB_NAME="wordpress" \
     wordpress:latest
```

----------------------------------------

TITLE: Basic Dockerfile with Production Environment Variable
DESCRIPTION: A standard Dockerfile demonstrating the use of the `ENV` instruction to set a production environment variable for a Node.js application. It copies package files, installs dependencies, and sets the command to run the application.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/variables.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM node:20
WORKDIR /app
COPY package*.json ./
ENV NODE_ENV=production
RUN npm ci && npm cache clean --force
COPY . .
CMD ["node", "app.js"]
```

----------------------------------------

TITLE: Run CockroachDB Container with Volume and Network
DESCRIPTION: Starts a CockroachDB container in detached mode. It attaches the container to the 'roach' volume for data persistence and the 'mynet' network for inter-container communication, mapping necessary ports for access.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/develop.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker run -d \
  --name roach \
  --hostname db \
  --network mynet \
  -p 26257:26257 \
  -p 8080:8080 \
  -v roach:/cockroach/cockroach-data \
  cockroachdb/cockroach:latest-v20.1 start-single-node \
  --insecure
```

----------------------------------------

TITLE: Dockerfile Examples for Non-Root User Policy Compliance
DESCRIPTION: These Dockerfile snippets illustrate the difference between a non-compliant image (running as root by default) and a compliant image (explicitly setting a non-root user) for the Default Non-Root User policy. The compliant example uses the `USER` instruction.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/policy/_index.md#_snippet_3

LANGUAGE: Dockerfile
CODE:
```
FROM alpine AS builder
COPY Makefile ./src /
RUN make build

FROM alpine AS runtime
COPY --from=builder bin/production /app
ENTRYPOINT ["/app/production"]
```

LANGUAGE: Dockerfile
CODE:
```
FROM alpine AS builder
COPY Makefile ./src /
RUN make build

FROM alpine AS runtime
COPY --from=builder bin/production /app
USER nonroot
ENTRYPOINT ["/app/production"]
```

----------------------------------------

TITLE: Verifying Manual Docker Engine Installation with Hello-World Image
DESCRIPTION: This sequence of commands verifies a manually installed Docker Engine. It first ensures the Docker daemon is started using `sudo service docker start`, then runs the `hello-world` image to confirm Docker's functionality by downloading, running, and printing a confirmation message.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/ubuntu.md#_snippet_7

LANGUAGE: console
CODE:
```
$ sudo service docker start
$ sudo docker run hello-world
```

----------------------------------------

TITLE: Configure Docker Service Update Strategy with YAML
DESCRIPTION: The `update_config` block within a Docker Compose `deploy` section allows you to define how a service should be updated, which is crucial for implementing rolling updates. Key parameters include:
- `parallelism`: Number of containers to update concurrently.
- `delay`: Time to wait between updating groups of containers.
- `failure_action`: Action to take if an update fails (e.g., `continue`, `rollback`, `pause`).
- `monitor`: Duration to monitor for failure after each task update.
- `max_failure_ratio`: Tolerable failure rate during an update.
- `order`: Order of operations (`stop-first` or `start-first`).
This example demonstrates setting parallelism, delay, and update order.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/deploy.md#_snippet_18

LANGUAGE: yaml
CODE:
```
deploy:
  update_config:
    parallelism: 2
    delay: 10s
    order: stop-first
```

----------------------------------------

TITLE: View Running Docker Containers using CLI
DESCRIPTION: Shows how to list all currently running Docker containers using the `docker ps` command. A tip is included to view all containers (running and stopped) by adding the `-a` flag to the command.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/the-basics/what-is-a-container.md#_snippet_1

LANGUAGE: console
CODE:
```
docker ps
```

LANGUAGE: console
CODE:
```
docker ps -a
```

----------------------------------------

TITLE: Run Docker Container with Bind Mount
DESCRIPTION: This command starts an interactive Bash session in an Ubuntu container, creating a bind mount that maps the host's current working directory to /src inside the container. It demonstrates how to use the --mount type=bind option for file sharing across different operating system shells.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/06_bind_mounts.md#_snippet_1

LANGUAGE: Mac / Linux
CODE:
```
$ docker run -it --mount type=bind,src="$(pwd)",target=/src ubuntu bash
```

LANGUAGE: Command Prompt
CODE:
```
$ docker run -it --mount "type=bind,src=%cd%,target=/src" ubuntu bash
```

LANGUAGE: Git Bash
CODE:
```
$ docker run -it --mount type=bind,src="/$(pwd)",target=/src ubuntu bash
```

LANGUAGE: PowerShell
CODE:
```
$ docker run -it --mount "type=bind,src=$($pwd),target=/src" ubuntu bash
```

----------------------------------------

TITLE: Run Docker MySQL container with volume
DESCRIPTION: Runs a MySQL container named `my-mysql` with a root password, a database `mydb`, and mounts `my-db-volume` to `/var/lib/mysql`. Docker automatically creates the volume if it doesn't exist.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_9

LANGUAGE: console
CODE:
```
$ docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -e MYSQL_DATABASE=mydb -v my-db-volume:/var/lib/mysql -d mysql:latest
```

----------------------------------------

TITLE: Copying from a Docker Image
DESCRIPTION: This snippet shows how to use `COPY --from=<image_name_or_digest>` to copy files directly from an existing Docker image. Here, the `nginx.conf` file is copied from the `/etc/nginx/` directory of the `nginx:latest` image to `/nginx.conf` in the current build stage.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_108

LANGUAGE: Dockerfile
CODE:
```
COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
```

----------------------------------------

TITLE: Defining Default Command with ENTRYPOINT and CMD in Dockerfile
DESCRIPTION: This Dockerfile demonstrates the exec form of `ENTRYPOINT` to set a stable default command (`top -b`) and `CMD` to provide additional, easily changeable arguments (`-c`). This pattern ensures `top` is always executed, with `-c` being an optional default argument.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_124

LANGUAGE: Dockerfile
CODE:
```
FROM ubuntu
ENTRYPOINT ["top", "-b"]
CMD ["-c"]
```

----------------------------------------

TITLE: Defining Docker ENTRYPOINT with exec for Signal Handling - Dockerfile
DESCRIPTION: This Dockerfile snippet defines an `ENTRYPOINT` using the 'shell form' and includes `exec`. The `exec` command ensures that the `top -b` process becomes `PID 1` inside the container, allowing `docker stop` to send signals directly to the application for graceful shutdown.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_131

LANGUAGE: Dockerfile
CODE:
```
FROM ubuntu
ENTRYPOINT exec top -b
```

----------------------------------------

TITLE: Configuring Web Server Healthcheck with HEALTHCHECK in Dockerfile
DESCRIPTION: This example demonstrates configuring a `HEALTHCHECK` instruction to monitor a web server's health. It sets an interval of 5 minutes and a timeout of 3 seconds, using `curl` to check if the main page is accessible. An exit code of 1 from the command indicates an unhealthy state, while 0 indicates success. Output from the health check command is stored and can be queried with `docker inspect` for debugging.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_168

LANGUAGE: Dockerfile
CODE:
```
HEALTHCHECK --interval=5m --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
```

----------------------------------------

TITLE: GitHub Actions Workflow: Compare Docker Images with Docker Scout
DESCRIPTION: This YAML snippet extends a GitHub Actions workflow to perform Docker image comparison using Docker Scout. It includes an optional Docker Hub authentication step and utilizes the `docker/scout-action` to compare the current image against a 'production' environment. The comparison filters for critical/high severities and ignores unchanged vulnerabilities, outputting results as a pull request comment.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/integrations/ci/gha.md#_snippet_1

LANGUAGE: yaml
CODE:
```
      # You can skip this step if Docker Hub is your registry
      # and you already authenticated before
      - name: Authenticate to Docker
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PAT }}

      # Compare the image built in the pull request with the one in production
      - name: Docker Scout
        id: docker-scout
        if: ${{ github.event_name == 'pull_request' }}
        uses: docker/scout-action@v1
        with:
          command: compare
          image: ${{ steps.meta.outputs.tags }}
          to-env: production
          ignore-unchanged: true
          only-severities: critical,high
          github-token: ${{ secrets.GITHUB_TOKEN }}
```

----------------------------------------

TITLE: Multi-Stage Dockerfile for C++ Application
DESCRIPTION: Defines a two-stage Docker build process for a C++ application. The first stage compiles the C++ code into a static binary using `ubuntu:latest`, and the second stage copies the binary into a `scratch` image for a minimal runtime environment.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/cpp/multistage.md#_snippet_2

LANGUAGE: Dockerfile
CODE:
```
# Stage 1: Build stage
FROM ubuntu:latest AS build

# Install build-essential for compiling C++ code
RUN apt-get update && apt-get install -y build-essential

# Set the working directory
WORKDIR /app

# Copy the source code into the container
COPY hello.cpp .

# Compile the C++ code statically to ensure it doesn't depend on runtime libraries
RUN g++ -o hello hello.cpp -static

# Stage 2: Runtime stage
FROM scratch

# Copy the static binary from the build stage
COPY --from=build /app/hello /hello

# Command to run the binary
CMD ["/hello"]
```

----------------------------------------

TITLE: Filter Docker Containers by Image
DESCRIPTION: Demonstrates how to use the `docker ps` command with the `--filter ancestor` flag to list containers that were created from a specific Docker image, such as `nginx:alpine`.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker ps -q --filter ancestor=nginx:alpine
```

----------------------------------------

TITLE: Compose Include Basic Usage
DESCRIPTION: Demonstrates how to use the `include` top-level section to declare a dependency on another Compose application, allowing cross-service references.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/include.md#_snippet_0

LANGUAGE: yaml
CODE:
```
include:
  - my-compose-include.yaml  #with serviceB declared
services:
  serviceA:
    build: .
    depends_on:
      - serviceB #use serviceB directly as if it was declared in this Compose file
```

----------------------------------------

TITLE: Multi-stage Dockerfile for Maven/Tomcat Application
DESCRIPTION: This Dockerfile demonstrates a multi-stage build for a Java application. The first stage (`build`) compiles the application using Maven. The second stage (`tomcat`) then copies only the compiled WAR file from the build stage, resulting in a much smaller final image that does not include the JDK or Maven build tools.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/09_image_best.md#_snippet_6

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM maven AS build
WORKDIR /app
COPY . .
RUN mvn package

FROM tomcat
COPY --from=build /app/target/file.war /usr/local/tomcat/webapps
```

----------------------------------------

TITLE: Docker Compose Development Override Configuration (compose.override.yaml)
DESCRIPTION: This 'compose.override.yaml' file extends the base configuration for a development environment. It adds specific settings like building the web image from source, mounting local code as a volume, exposing additional ports, and setting a debug environment variable. This file is automatically read by Docker Compose.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/multiple-compose-files/merge.md#_snippet_11

LANGUAGE: yaml
CODE:
```
services:
  web:
    build: .
    volumes:
      - '.:/code'
    ports:
      - 8883:80
    environment:
      DEBUG: 'true'

  db:
    command: '-d'
    ports:
     - 5432:5432

  cache:
    ports:
      - 6379:6379
```

----------------------------------------

TITLE: Integrate Docker Scout CLI for Environment Tracking in CI/CD
DESCRIPTION: This collection of code examples illustrates how to configure different CI/CD platforms (CircleCI, GitLab, Azure DevOps, Jenkins) to use the Docker Scout CLI client. The process involves setting Docker Hub username and password as environment variables, then executing the `docker scout environment` command to associate Docker images with a specified Docker organization and environment, facilitating image analysis and tracking.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/integrations/environment/cli.md#_snippet_0

LANGUAGE: yaml
CODE:
```
version: 2.1

jobs:
  record_environment:
    machine:
      image: ubuntu-2204:current
    image: namespace/repo
    steps:
      - run: |
          if [[ -z "$CIRCLE_TAG" ]]; then
            tag="$CIRCLE_TAG"
            echo "Running tag '$CIRCLE_TAG'"
          else
            tag="$CIRCLE_BRANCH"
            echo "Running on branch '$CI_COMMIT_BRANCH'"
          fi    
          echo "tag = $tag"
      - run: docker run -it \
          -e DOCKER_SCOUT_HUB_USER=$DOCKER_SCOUT_HUB_USER \
          -e DOCKER_SCOUT_HUB_PASSWORD=$DOCKER_SCOUT_HUB_PASSWORD \
          docker/scout-cli:1.0.2 environment \
          --org "<MY_DOCKER_ORG>" \
          "<ENVIRONMENT>" ${image}:${tag}
```

LANGUAGE: yaml
CODE:
```
variables:
  image: namespace/repo

record_environment:
  image: docker/scout-cli:1.0.2
  script:
    - |
      if [[ -z "$CI_COMMIT_TAG" ]]; then
        tag="latest"
        echo "Running tag '$CI_COMMIT_TAG'"
      else
        tag="$CI_COMMIT_REF_SLUG"
        echo "Running on branch '$CI_COMMIT_BRANCH'"
      fi    
      echo "tag = $tag"
    - environment --org <MY_DOCKER_ORG> "PRODUCTION" ${image}:${tag}
```

LANGUAGE: yaml
CODE:
```
trigger:
  - main

resources:
  - repo: self

variables:
  tag: "$(Build.BuildId)"
  image: "namespace/repo"

stages:
  - stage: Docker Scout
    displayName: Docker Scout environment integration
    jobs:
      - job: Record
        displayName: Record environment
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: Docker@2
          - script: docker run -it \
              -e DOCKER_SCOUT_HUB_USER=$DOCKER_SCOUT_HUB_USER \
              -e DOCKER_SCOUT_HUB_PASSWORD=$DOCKER_SCOUT_HUB_PASSWORD \
              docker/scout-cli:1.0.2 environment \
              --org "<MY_DOCKER_ORG>" \
              "<ENVIRONMENT>" $(image):$(tag)
```

LANGUAGE: groovy
CODE:
```
stage('Analyze image') {
    steps: {
        // Install Docker Scout
        sh 'curl -sSfL https://raw.githubusercontent.com/docker/scout-cli/main/install.sh | sh -s -- -b /usr/local/bin'
        
        // Log into Docker Hub
        sh 'echo $DOCKER_SCOUT_HUB_PASSWORD | docker login -u $DOCKER_SCOUT_HUB_USER --password-stdin'

        // Analyze and fail on critical or high vulnerabilities
        sh 'docker-scout environment --org "<MY_DOCKER_ORG>" "<ENVIRONMENT>" $IMAGE_TAG'
    }
}
```

----------------------------------------

TITLE: Configuring Docker Compose Ports with Short Syntax (YAML)
DESCRIPTION: This snippet demonstrates the short syntax for defining port mappings in Docker Compose. It shows various formats including single port, port ranges, host-to-container mappings, IP-specific bindings (IPv4 and IPv6), and protocol specification (TCP/UDP). The HOST:CONTAINER format should be quoted to avoid YAML parsing issues.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_72

LANGUAGE: yaml
CODE:
```
ports:
  - "3000"
  - "3000-3005"
  - "8000:8000"
  - "9090-9091:8080-8081"
  - "49100:22"
  - "8000-9000:80"
  - "127.0.0.1:8001:8001"
  - "127.0.0.1:5000-5010:5000-5010"  
  - "::1:6000:6000"   
  - "[::1]:6001:6001" 
  - "6060:6060/udp"
```

----------------------------------------

TITLE: Define a Docker Compose Service with Bind Mount
DESCRIPTION: This YAML snippet illustrates how to define a single Docker Compose service named 'frontend' that utilizes a bind mount. It maps the local './static' directory from the host to '/opt/app/static' within the container, enabling persistent data sharing and development workflows.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/bind-mounts.md#_snippet_18

LANGUAGE: yaml
CODE:
```
services:
  frontend:
    image: node:lts
    volumes:
      - type: bind
        source: ./static
        target: /opt/app/static
volumes:
  myapp:
```

----------------------------------------

TITLE: List All Docker Images
DESCRIPTION: The `docker image ls` command displays a list of all Docker images present on your system. This helps identify images that might be old or unused and can be removed to free up disk space.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/troubleshoot-and-support/faqs/macfaqs.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker image ls
```

----------------------------------------

TITLE: Test Docker Container Service Discovery via Ping
DESCRIPTION: Demonstrates automatic service discovery on a user-defined network by attaching to `alpine1` and pinging other containers (`alpine2`, `alpine4`, `alpine1` itself) by their names. This confirms that containers on the same user-defined network can resolve each other's names to IP addresses.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/network/tutorials/standalone.md#_snippet_18

LANGUAGE: console
CODE:
```
$ docker container attach alpine1

# ping -c 2 alpine2

PING alpine2 (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.085 ms
64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.090 ms

--- alpine2 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.085/0.087/0.090 ms

# ping -c 2 alpine4

PING alpine4 (172.18.0.4): 56 data bytes
64 bytes from 172.18.0.4: seq=0 ttl=64 time=0.076 ms
64 bytes from 172.18.0.4: seq=1 ttl=64 time=0.091 ms

--- alpine4 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.076/0.083/0.091 ms

# ping -c 2 alpine1

PING alpine1 (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.026 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.054 ms

--- alpine1 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.026/0.040/0.054 ms
```

----------------------------------------

TITLE: Basic Docker Compose Network Configuration
DESCRIPTION: Demonstrates how to connect services to explicitly defined networks (`front-tier`, `back-tier`) within a Compose file, ensuring services can communicate across specified networks.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/networks.md#_snippet_0

LANGUAGE: yml
CODE:
```
services:
  frontend:
    image: example/webapp
    networks:
      - front-tier
      - back-tier

networks:
  front-tier:
  back-tier:
```

----------------------------------------

TITLE: Build and Run Docker Compose Application
DESCRIPTION: This command initiates the build and startup of all services defined in the `compose.yaml` file. The console output shows the network creation, service instantiation, and logs from both the web and Redis containers, indicating successful application startup.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/gettingstarted.md#_snippet_5

LANGUAGE: Console
CODE:
```
$ docker compose up

Creating network "composetest_default" with the default driver
Creating composetest_web_1 ...
Creating composetest_redis_1 ...
Creating composetest_web_1
Creating composetest_redis_1 ... done
Attaching to composetest_web_1, composetest_redis_1
web_1    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
redis_1  | 1:C 17 Aug 22:11:10.480 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
redis_1  | 1:C 17 Aug 22:11:10.480 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=1, just started
redis_1  | 1:C 17 Aug 22:11:10.480 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
web_1    |  * Restarting with stat
redis_1  | 1:M 17 Aug 22:11:10.483 * Running mode=standalone, port=6379.
redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
web_1    |  * Debugger is active!
redis_1  | 1:M 17 Aug 22:11:10.483 # Server initialized
redis_1  | 1:M 17 Aug 22:11:10.483 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
web_1    |  * Debugger PIN: 330-787-903
redis_1  | 1:M 17 Aug 22:11:10.483 * Ready to accept connections
```

----------------------------------------

TITLE: Create a Multi-stage Dockerfile for Java Testing
DESCRIPTION: This Dockerfile defines a multi-stage build process for a Java application, incorporating a dedicated 'test' stage to run unit tests during the image build. It uses Maven Wrapper (mvnw) to execute tests and manage dependencies, ensuring that the build fails if tests do not pass. Subsequent stages handle dependency caching, packaging, and extracting application layers for optimized final images.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/run-tests.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM eclipse-temurin:21-jdk-jammy as base
WORKDIR /build
COPY --chmod=0755 mvnw mvnw
COPY .mvn/ .mvn/

FROM base as test
WORKDIR /build
COPY ./src src/
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 \
    ./mvnw test

FROM base as deps
WORKDIR /build
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 \
    ./mvnw dependency:go-offline -DskipTests

FROM deps as package
WORKDIR /build
COPY ./src src/
RUN --mount=type=bind,source=pom.xml,target=pom.xml \
    --mount=type=cache,target=/root/.m2 \
    ./mvnw package -DskipTests && \
    mv target/$(./mvnw help:evaluate -Dexpression=project.artifactId -q -DforceStdout)-$(./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout).jar target/app.jar

FROM package as extract
WORKDIR /build
RUN java -Djarmode=layertools -jar target/app.jar extract --destination target/extracted

FROM extract as development
WORKDIR /build
RUN cp -r /build/target/extracted/dependencies/. ./
RUN cp -r /build/target/extracted/spring-boot-loader/. ./
RUN cp -r /build/target/extracted/snapshot-dependencies/. ./
RUN cp -r /build/target/extracted/application/. ./
ENV JAVA_TOOL_OPTIONS="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000"
CMD [ "java", "-Dspring.profiles.active=postgres", "org.springframework.boot.loader.launch.JarLauncher" ]

FROM eclipse-temurin:21-jre-jammy AS final
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser
USER appuser
COPY --from=extract build/target/extracted/dependencies/ ./
COPY --from=extract build/target/extracted/spring-boot-loader/ ./
COPY --from=extract build/target/extracted/snapshot-dependencies/ ./
COPY --from=extract build/target/extracted/application/ ./
EXPOSE 8080
ENTRYPOINT [ "java", "-Dspring.profiles.active=postgres", "org.springframework.boot.loader.launch.JarLauncher" ]
```

----------------------------------------

TITLE: Defining Target Platform for Docker Compose Services
DESCRIPTION: This example illustrates how 'platform' defines the target operating system, architecture, and variant for service containers using the 'os[/arch[/variant]]' syntax, adhering to OCI Image Spec conventions. Compose utilizes this attribute to determine the correct image version to pull or the platform on which to perform a service's build.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_71

LANGUAGE: YAML
CODE:
```
platform: darwin
platform: windows/amd64
platform: linux/arm64/v8
```

----------------------------------------

TITLE: Reusing common service configurations with extensions and anchors
DESCRIPTION: This YAML snippet shows how to define a reusable `x-function` extension containing common configurations like labels, dependencies, networks, and deployment constraints. Services like `nodeinfo` and `echoit` can then inherit these shared attributes using a YAML anchor (`&function`), while still defining their unique image and environment variables.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/extension.md#_snippet_3

LANGUAGE: yml
CODE:
```
x-function: &function
 labels:
   function: "true"
 depends_on:
   - gateway
 networks:
   - functions
 deploy:
   placement:
     constraints:
       - 'node.platform.os == linux'
services:
 # Node.js gives OS info about the node (Host)
 nodeinfo:
   <<: *function
   image: functions/nodeinfo:latest
   environment:
     no_proxy: "gateway"
     https_proxy: $https_proxy
 # Uses `cat` to echo back response, fastest function to execute.
 echoit:
   <<: *function
   image: functions/alpine:health
   environment:
     fprocess: "cat"
     no_proxy: "gateway"
     https_proxy: $https_proxy
```

----------------------------------------

TITLE: Sharing environment variables using extensions and YAML anchors
DESCRIPTION: This YAML example demonstrates how to define a common set of environment variables within an `x-env` extension field. By using a YAML anchor (`&env`), multiple services (`first`, `second`) can reference and include these shared environment variables using the merge key (`<<: *env`), promoting reusability and reducing duplication.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/extension.md#_snippet_2

LANGUAGE: yml
CODE:
```
x-env: &env
  environment:
    - CONFIG_KEY
    - EXAMPLE_KEY
 
services:
  first:
    <<: *env
    image: my-image:latest
  second:
    <<: *env
    image: another-image:latest
```

----------------------------------------

TITLE: Configuring Service Dependencies with `depends_on` (Long Syntax) in Docker Compose YAML
DESCRIPTION: This YAML snippet demonstrates the long syntax for `depends_on` in Docker Compose, specifying advanced dependency conditions. It shows how the `web` service depends on `db` being healthy and `redis` having started, ensuring services are created and removed in the correct order and healthchecks pass before dependent services start.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_19

LANGUAGE: YAML
CODE:
```
services:
  web:
    build: .
    depends_on:
      db:
        condition: service_healthy
        restart: true
      redis:
        condition: service_started
  redis:
    image: redis
  db:
    image: postgres
```

----------------------------------------

TITLE: Example Docker Run Command with --volume Flag
DESCRIPTION: Provides a concrete example of using the `--volume` flag to bind mount the current directory ('.') to '/project' inside the container, setting it as read-only and configuring `rshared` bind propagation.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/bind-mounts.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker run -v .:/project:ro,rshared
```

----------------------------------------

TITLE: Verify Docker Installation on Linux
DESCRIPTION: This command runs the `hello-world` Docker image to verify that Docker Engine is correctly installed and operational. It downloads the image, runs it in a container, and prints a confirmation message.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/binaries.md#_snippet_3

LANGUAGE: console
CODE:
```
sudo docker run hello-world
```

----------------------------------------

TITLE: Cleaning Up Docker Compose Services and Volumes
DESCRIPTION: This command stops and removes all services defined in the Docker Compose file, along with any anonymous volumes created by those services. It is used to completely clean up the Docker Content Trust sandbox environment after testing.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/security/trust/trust_sandbox.md#_snippet_19

LANGUAGE: console
CODE:
```
$ docker compose down -v
```

----------------------------------------

TITLE: Running a Docker container and publishing port 8080 for a web app
DESCRIPTION: This practical example demonstrates how to start a new container using the `docker/welcome-to-docker` image and publish its internal port 80 to host port 8080. This allows the web application running inside the container to be accessed from the host machine's browser at `http://localhost:8080`.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/publishing-ports.md#_snippet_5

LANGUAGE: bash
CODE:
```
$ docker run -d -p 8080:80 docker/welcome-to-docker
```

----------------------------------------

TITLE: Override Docker Compose file example
DESCRIPTION: Defines an override for the `webapp` service in `compose.admin.yaml`, adding an environment variable `DEBUG=1`. This demonstrates how subsequent files can modify or extend existing service configurations.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/multiple-compose-files/merge.md#_snippet_2

LANGUAGE: yaml
CODE:
```
webapp:
  environment:
    - DEBUG=1
```

----------------------------------------

TITLE: Verify Detached Container Connectivity
DESCRIPTION: Verifies connectivity to the application running in the detached Docker container via the published host port 3001 using `curl`. This confirms the container is running correctly in the background and is accessible.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/run-containers.md#_snippet_5

LANGUAGE: console
CODE:
```
$ curl http://localhost:3001
```

----------------------------------------

TITLE: Copy Source Code to Docker Container
DESCRIPTION: This `COPY` instruction transfers the application's source code (`src` directory) from the host machine to the `/app` directory within the container. This prepares the application for compilation and execution.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/building-images/multi-stage-builds.md#_snippet_7

LANGUAGE: dockerfile
CODE:
```
COPY src ./src
```

----------------------------------------

TITLE: Remove a Docker volume
DESCRIPTION: Removes a specified Docker volume by its name or ID. This command only works if the volume is not currently attached to any running containers.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/persisting-container-data.md#_snippet_3

LANGUAGE: console
CODE:
```
docker volume rm <volume-name-or-id>
```

----------------------------------------

TITLE: Copying Multiple Files to a Directory
DESCRIPTION: This example demonstrates copying multiple source files (`file1.txt`, `file2.txt`) from the build context into a specified directory (`/usr/src/things/`) within the Docker image. When multiple sources are specified, either directly or using a wildcard, the destination must be a directory.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_100

LANGUAGE: dockerfile
CODE:
```
COPY file1.txt file2.txt /usr/src/things/
```

----------------------------------------

TITLE: Define Docker Volume in Compose (Internal)
DESCRIPTION: Example of defining a Docker volume directly within a `docker-compose.yaml` file, where the volume is managed by Compose and created upon `docker compose up`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/volumes.md#_snippet_13

LANGUAGE: yaml
CODE:
```
services:
  frontend:
    image: node:lts
    volumes:
      - myapp:/home/node/app
volumes:
  myapp:
```

----------------------------------------

TITLE: Dockerfile using a custom ENTRYPOINT helper script
DESCRIPTION: Demonstrates how to copy a custom helper script into the container and set it as the ENTRYPOINT, with a default CMD for the main application (Postgres).
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/best-practices.md#_snippet_31

LANGUAGE: dockerfile
CODE:
```
COPY ./docker-entrypoint.sh /
ENTRYPOINT ["/docker-entrypoint.sh"]
CMD ["postgres"]
```

----------------------------------------

TITLE: Run MySQL Docker Container Directly
DESCRIPTION: Demonstrates how to run a MySQL 8.0 container directly using `docker run`, setting up network, volume, and environment variables for root password and database name.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/workshop/08_using_compose.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker run -d \
  --network todo-app --network-alias mysql \
  -v todo-mysql-data:/var/lib/mysql \
  -e MYSQL_ROOT_PASSWORD=secret \
  -e MYSQL_DATABASE=todos \
  mysql:8.0
```

----------------------------------------

TITLE: Uninstalling Conflicting Docker Packages on Debian
DESCRIPTION: This command uninstalls various unofficial or conflicting Docker-related packages, including `docker.io`, `docker-doc`, `docker-compose`, `podman-docker`, `containerd`, and `runc`. It uses a `for` loop with `sudo apt-get remove` to ensure a clean environment before installing the official Docker Engine, preventing potential conflicts.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/install/debian.md#_snippet_0

LANGUAGE: console
CODE:
```
$ for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg; done
```

----------------------------------------

TITLE: Build Multi-Platform Image with Docker Buildx
DESCRIPTION: Demonstrates how to use `docker buildx build` with the `--platform` flag to specify target architectures for the build output, such as `linux/amd64` and `linux/arm64`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/multi-platform.md#_snippet_1

LANGUAGE: console
CODE:
```
$ docker buildx build --platform linux/amd64,linux/arm64 .
```

----------------------------------------

TITLE: Run Rails Application in Detached Mode
DESCRIPTION: This command runs the Ruby on Rails application in the background (detached mode) using Docker Compose, allowing the terminal to be used for other tasks.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/ruby/containerize.md#_snippet_7

LANGUAGE: console
CODE:
```
$ docker compose up --build -d
```

----------------------------------------

TITLE: Run Nginx and publish host port 80 to container port 80
DESCRIPTION: Demonstrates running an Nginx webserver in detached mode, mapping host port 80 to container port 80 using the `-p` flag. This allows access to the webserver from the host's localhost:80.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/features/networking.md#_snippet_15

LANGUAGE: console
CODE:
```
docker run -d -p 80:80 --name webserver nginx
```

----------------------------------------

TITLE: Share Docker Image between GitHub Actions Jobs using Artifacts
DESCRIPTION: This GitHub Actions workflow demonstrates how to build a Docker image in one job and then make it available to another job by exporting it as a tar archive and using `actions/upload-artifact` and `actions/download-artifact`. This avoids the need to push the image to a registry for inter-job communication. The 'build' job creates the image and uploads it, while the 'use' job downloads and loads it.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/ci/github-actions/share-image-jobs.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: ci

on:
  push:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and export
        uses: docker/build-push-action@v6
        with:
          tags: myimage:latest
          outputs: type=docker,dest=${{ runner.temp }}/myimage.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: myimage
          path: ${{ runner.temp }}/myimage.tar

  use:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: myimage
          path: ${{ runner.temp }}

      - name: Load image
        run: |
          docker load --input ${{ runner.temp }}/myimage.tar
          docker image ls -a
```

----------------------------------------

TITLE: Defining Environment Variables with ENV (Key-Value Syntax) - Dockerfile
DESCRIPTION: This snippet illustrates the fundamental syntax of the `ENV` instruction, which sets environment variables within the Docker image. These variables persist for all subsequent build instructions and when the container runs, with values being interpreted for other environment variables.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_76

LANGUAGE: Dockerfile
CODE:
```
ENV <key>=<value> [<key>=<value>...]
```

----------------------------------------

TITLE: Example Dockerfile for C program
DESCRIPTION: This Dockerfile demonstrates how each instruction creates a layer and how changes to a file (like main.c) can invalidate the cache for subsequent layers, requiring them to be rebuilt. It compiles a simple C program.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/_index.md#_snippet_0

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM ubuntu:latest

RUN apt-get update && apt-get install -y build-essentials
COPY main.c Makefile /src/
WORKDIR /src/
RUN make build
```

----------------------------------------

TITLE: Stop, Remove Container and Volume
DESCRIPTION: Sequence of commands to stop a running container, remove the container, and then remove the associated Docker volume.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/volumes.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker container stop devtest

$ docker container rm devtest

$ docker volume rm myvol2
```

----------------------------------------

TITLE: Build Multi-Platform Image with Docker Buildx Kubernetes Driver using QEMU
DESCRIPTION: This command builds a multi-platform Docker image (for `amd64` and `arm64`) using the Docker Buildx Kubernetes driver. It leverages QEMU user mode emulation for non-native platforms, allowing a single build command to produce images for multiple architectures. The `--push` flag pushes the resulting images to a registry.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/builders/drivers/kubernetes.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker buildx build \
  --builder=kube \
  --platform=linux/amd64,linux/arm64 \
  -t <user>/<image> \
  --push .
```

----------------------------------------

TITLE: Extending Service Configurations in Docker Compose (YAML)
DESCRIPTION: This snippet illustrates the `extends` key in Docker Compose, which allows sharing and reusing common service configurations across different files or projects. It shows how to reference a specific service, `webapp`, from an external `common.yml` file, enabling the current service to inherit its base configuration.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/services.md#_snippet_39

LANGUAGE: yaml
CODE:
```
extends:
  file: common.yml
  service: webapp
```

----------------------------------------

TITLE: Define Docker Compose Services with Profiles
DESCRIPTION: This YAML snippet illustrates how to define services in a Docker Compose file using the `profiles` attribute. Services without a `profiles` attribute are always active. Services with profiles are only included in the application model if one of their listed profiles is active, demonstrating how to tailor the application for different environments or testing scenarios.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/profiles.md#_snippet_0

LANGUAGE: yaml
CODE:
```
services:
  web:
    image: web_image

  test_lib:
    image: test_lib_image
    profiles:
      - test

  coverage_lib:
    image: coverage_lib_image
    depends_on:
      - test_lib
    profiles:
      - test

  debug_lib:
    image: debug_lib_image
    depends_on:
      - test_lib
    profiles:
      - debug
```

----------------------------------------

TITLE: Logout from Docker on Self-Hosted Linux Agents
DESCRIPTION: This YAML snippet executes a 'docker logout' command as a script step in the pipeline. It is conditionally run only on Linux-based self-hosted agents to proactively clean up Docker credentials at the end of the pipeline, enhancing security posture.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/azure-pipelines.md#_snippet_9

LANGUAGE: yaml
CODE:
```
- script: docker logout
  displayName: Docker Logout (Self-hosted only)
  condition: ne(variables['Agent.OS'], 'Windows_NT')
```

----------------------------------------

TITLE: Invoke Docker Compose v2 CLI
DESCRIPTION: This snippet shows the command-line invocation for Docker Compose version 2. This version, announced in 2020, is written in Go and is the currently supported CLI.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/intro/history.md#_snippet_1

LANGUAGE: Shell
CODE:
```
docker compose
```

----------------------------------------

TITLE: Troubleshooting Port Allocation Errors in Docker Containers
DESCRIPTION: This section addresses 'port already allocated' errors that occur when starting a Docker container, indicating that the specified port is already in use by another application or a previously running container. It provides methods using `netstat` in PowerShell to identify the process occupying the port, allowing users to decide whether to terminate the conflicting process or use an alternative port.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/desktop/troubleshoot-and-support/troubleshoot/topics.md#_snippet_2

LANGUAGE: text
CODE:
```
Bind for 0.0.0.0:8080 failed: port is already allocated
```

LANGUAGE: text
CODE:
```
listen tcp:0.0.0.0:8080: bind: address is already in use
```

LANGUAGE: PowerShell
CODE:
```
netstat -aon | find /i "listening "
```

----------------------------------------

TITLE: View Running Docker Service Containers
DESCRIPTION: This console output demonstrates the `docker ps` command showing multiple active containers for a 'simpleweb' service. It includes details like container ID, image, command, creation time, status, and assigned names, indicating a healthy running service.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/extend/plugins_services.md#_snippet_10

LANGUAGE: console
CODE:
```
cf4b0ec2415e        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 36 seconds                           myservice.3.r7p5o208jmlzpcbm2ytl3q6n1
57c64a6a2b88        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 36 seconds                           myservice.4.dwoezsbb02ccstkhlqjy2xe7h
3ac68cc4e7b8        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 35 seconds                           myservice.5.zx4ezdrm2nwxzkrwnxthv0284
006c3cb318fc        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 36 seconds                           myservice.8.q0e3umt19y3h3gzo1ty336k5r
dd2ffebde435        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 36 seconds                           myservice.7.a77y3u22prjipnrjg7vzpv3ba
a86c74d8b84b        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 36 seconds                           myservice.6.z9nbn14bagitwol1biveeygl7
2846a7850ba0        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 37 seconds                           myservice.2.ypufz2eh9fyhppgb89g8wtj76
e2ec01efcd8a        mrjana/simpleweb@sha256:317d7f221d68c86d503119b0ea12c29de42af0a22ca087d522646ad1069a47a4   "simpleweb"         39 seconds ago      Up 38 seconds                           myservice.1.8w7c4ttzr6zcb9sjsqyhwp3yl
```

----------------------------------------

TITLE: Start Docker Compose Services
DESCRIPTION: This command starts the services defined in the `compose.yaml` file, including the OpenTelemetry collector and Prometheus, bringing up the local observability stack.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/cli/otel.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker compose up
```

----------------------------------------

TITLE: Docker Compose Command-Line Options Reference
DESCRIPTION: A comprehensive list of command-line options for Docker Compose, detailing their names, data types, default values, and descriptions. These options can be used to modify the behavior of various Docker Compose commands.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_up.md#_snippet_0

LANGUAGE: APIDOC
CODE:
```
Docker Compose Command Options:
  --abort-on-container-exit (Type: bool, Default: None)
    Description: Stops all containers if any container was stopped. Incompatible with -d
  --abort-on-container-failure (Type: bool, Default: None)
    Description: Stops all containers if any container exited with failure. Incompatible with -d
  --always-recreate-deps (Type: bool, Default: None)
    Description: Recreate dependent containers. Incompatible with --no-recreate.
  --attach (Type: stringArray, Default: None)
    Description: Restrict attaching to the specified services. Incompatible with --attach-dependencies.
  --attach-dependencies (Type: bool, Default: None)
    Description: Automatically attach to log output of dependent services
  --build (Type: bool, Default: None)
    Description: Build images before starting containers
  -d, --detach (Type: bool, Default: None)
    Description: Detached mode: Run containers in the background
  --dry-run (Type: bool, Default: None)
    Description: Execute command in dry run mode
  --exit-code-from (Type: string, Default: None)
    Description: Return the exit code of the selected service container. Implies --abort-on-container-exit
  --force-recreate (Type: bool, Default: None)
    Description: Recreate containers even if their configuration and image haven't changed
  --menu (Type: bool, Default: None)
    Description: Enable interactive shortcuts when running attached. Incompatible with --detach. Can also be enable/disable by setting COMPOSE_MENU environment var.
  --no-attach (Type: stringArray, Default: None)
    Description: Do not attach (stream logs) to the specified services
  --no-build (Type: bool, Default: None)
    Description: Don't build an image, even if it's policy
  --no-color (Type: bool, Default: None)
    Description: Produce monochrome output
  --no-deps (Type: bool, Default: None)
    Description: Don't start linked services
  --no-log-prefix (Type: bool, Default: None)
    Description: Don't print prefix in logs
  --no-recreate (Type: bool, Default: None)
    Description: If containers already exist, don't recreate them. Incompatible with --force-recreate.
  --no-start (Type: bool, Default: None)
    Description: Don't start the services after creating them
  --pull (Type: string, Default: policy)
    Description: Pull image before running ("always"|"missing"|"never")
  --quiet-pull (Type: bool, Default: None)
    Description: Pull without printing progress information
  --remove-orphans (Type: bool, Default: None)
    Description: Remove containers for services not defined in the Compose file
```

----------------------------------------

TITLE: Run Docker Compose Application with Watch Mode
DESCRIPTION: This console command executes the Docker Compose application in watch mode. This allows for automatic updates to the running container whenever local source code files are changed, facilitating rapid development.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/tensorflowjs.md#_snippet_8

LANGUAGE: console
CODE:
```
$ docker compose watch
```

----------------------------------------

TITLE: Create and Run Container on User-Defined Bridge Network
DESCRIPTION: This example demonstrates how to create a custom user-defined bridge network using the `docker network create` command and then run a Docker container, connecting it to the newly created network using the `--network` flag. Containers connected to the same user-defined network can communicate with each other using their container names or IP addresses.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/network/_index.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker network create -d bridge my-net
$ docker run --network=my-net -itd --name=container3 busybox
```

----------------------------------------

TITLE: GitHub Actions Workflow: Build and Push Docker Image
DESCRIPTION: This YAML snippet defines a GitHub Actions job to build and push a Docker image. It includes steps for registry authentication, Docker Buildx setup, metadata extraction, and conditional build/push logic for pull requests versus main branch pushes. The workflow ensures images are built with proper tags and labels.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/integrations/ci/gha.md#_snippet_0

LANGUAGE: yaml
CODE:
```
name: Docker

on:
  push:
    tags: ["*"]
    branches:
      - "main"
  pull_request:
    branches: ["**"]

env:
  # Hostname of your registry
  REGISTRY: docker.io
  # Image repository, without hostname and tag
  IMAGE_NAME: ${{ github.repository }}
  SHA: ${{ github.event.pull_request.head.sha || github.event.after }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write

    steps:
      # Authenticate to the container registry
      - name: Authenticate to registry ${{ env.REGISTRY }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USER }}
          password: ${{ secrets.REGISTRY_TOKEN }}
      
      - name: Setup Docker buildx
        uses: docker/setup-buildx-action@v3

      # Extract metadata (tags, labels) for Docker
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          labels: |
            org.opencontainers.image.revision=${{ env.SHA }}
          tags: |
            type=edge,branch=$repo.default_branch
            type=semver,pattern=v{{version}}
            type=sha,prefix=,suffix=,format=short

      # Build and push Docker image with Buildx
      # (don't push on PR, load instead)
      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@v6
        with:
          sbom: ${{ github.event_name != 'pull_request' }}
          provenance: ${{ github.event_name != 'pull_request' }}
          push: ${{ github.event_name != 'pull_request' }}
          load: ${{ github.event_name == 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
```

----------------------------------------

TITLE: Multi-line Command with Shell Form and Backslash Escaping
DESCRIPTION: This snippet illustrates how to split a long command across multiple lines in Dockerfile's shell form using a backslash (`\\`) as the escape character. This enhances readability for complex commands, as the entire instruction is treated as a single logical line by the shell.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_34

LANGUAGE: Dockerfile
CODE:
```
RUN source $HOME/.bashrc && \\
echo $HOME
```

----------------------------------------

TITLE: Start Nginx Docker Container with Port Mapping
DESCRIPTION: Command to start the Nginx container in detached mode, connecting it to the 'sample-app' network and mapping host port 80 to container port 80, allowing external access to the reverse proxy.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/multi-container-applications.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker run -d --name nginx --network sample-app  -p 80:80 nginx
```

----------------------------------------

TITLE: Remove all unused Docker volumes
DESCRIPTION: Removes all Docker volumes that are not currently attached to any containers, helping to free up disk space.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/persisting-container-data.md#_snippet_4

LANGUAGE: console
CODE:
```
docker volume prune
```

----------------------------------------

TITLE: Verify persisted data in new Postgres container
DESCRIPTION: Executes a SQL query directly within the new PostgreSQL container to verify that the previously inserted data is still present, confirming successful data persistence via volumes.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/docker-concepts/running-containers/persisting-container-data.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker exec -ti new-db psql -U postgres -c "SELECT * FROM tasks"
```

----------------------------------------

TITLE: Build Docker Image and Scan for CVEs with Docker Scout in Azure DevOps
DESCRIPTION: This Azure DevOps pipeline stage builds a Docker image using the specified Dockerfile and tags it. Subsequently, it installs the Docker Scout CLI, logs into Docker Hub, and then scans the newly built image for critical and high-severity CVEs, configured to fail the pipeline if such vulnerabilities are detected.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/integrations/ci/azure.md#_snippet_1

LANGUAGE: yaml
CODE:
```
stages:
  - stage: Build
    displayName: Build image
    jobs:
      - job: Build
        displayName: Build
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: Docker@2
            displayName: Build an image
            inputs:
              command: build
              dockerfile: "$(Build.SourcesDirectory)/Dockerfile"
              repository: $(image)
              tags: |
                $(tag)
          - task: CmdLine@2
            displayName: Find CVEs on image
            inputs:
              script: |
                # Install the Docker Scout CLI
                curl -sSfL https://raw.githubusercontent.com/docker/scout-cli/main/install.sh | sh -s --
                # Login to Docker Hub required for Docker Scout CLI
                echo $(DOCKER_HUB_PAT) | docker login -u $(DOCKER_HUB_USER) --password-stdin
                # Get a CVE report for the built image and fail the pipeline when critical or high CVEs are detected
                docker scout cves $(image):$(tag) --exit-code --only-severity critical,high
```

----------------------------------------

TITLE: Manage Docker Socket Access with Enhanced Container Isolation Exceptions
DESCRIPTION: This setting allows specific images or commands to access the Docker socket even when Enhanced Container Isolation (ECI) is enabled. It supports tools like Testcontainers or LocalStack that require Docker socket access, while still maintaining the overall secure defaults provided by ECI. The configuration involves defining image and command lists.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/security/for-admins/hardened-desktop/settings-management/settings-reference.md#_snippet_66

LANGUAGE: json
CODE:
```
"enhancedContainerIsolation": {
  "locked": true,
  "value": true,
  "dockerSocketMount": {
    "imageList": {
      "images": [
        "docker.io/localstack/localstack:*",
        "docker.io/testcontainers/ryuk:*"
      ]
    },
    "commandList": {
      "type": "deny",
      "commands": ["push"]
    }
  }
}
```

----------------------------------------

TITLE: Switch Active Docker Context
DESCRIPTION: Changes the currently active Docker context, directing all subsequent Docker commands to the daemon defined by the specified context. The command confirms the switch and can be verified by listing contexts.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/manage-resources/contexts.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker context use docker-test
docker-test
Current context is now "docker-test"
```

----------------------------------------

TITLE: Run Docker Container with Custom Entrypoint
DESCRIPTION: This example demonstrates how to run a Docker container with a custom entrypoint, specifically `/bin/bash`, instead of the image's default. This is useful for debugging or executing specific commands within a container.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/cli/docs/reference/run.md#_snippet_51

LANGUAGE: Shell
CODE:
```
$ docker run -it --entrypoint /bin/bash example/redis
```

----------------------------------------

TITLE: Get interactive shell in Docker Compose service
DESCRIPTION: Use `docker compose exec` to obtain an interactive shell within a specified service container. By default, this command allocates a TTY, enabling interactive sessions.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_exec.md#_snippet_0

LANGUAGE: Shell
CODE:
```
docker compose exec web sh
```

----------------------------------------

TITLE: Check Kubernetes Pod Status and Output
DESCRIPTION: This command lists all pods in the current Kubernetes context, allowing verification of their status, readiness, and age. The output shows the 'demo' pod is running and ready.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/orchestration.md#_snippet_9

LANGUAGE: console
CODE:
```
$ kubectl get pods
```

LANGUAGE: shell
CODE:
```
NAME      READY     STATUS    RESTARTS   AGE
demo      1/1       Running   0          4s
```

----------------------------------------

TITLE: Check Kubernetes Deployments Status
DESCRIPTION: Verify the status of your Kubernetes deployments using `kubectl get deployments`. This command shows if your `docker-java-demo` deployment is ready and available, indicating the pods are running.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/deploy.md#_snippet_2

LANGUAGE: Shell
CODE:
```
$ kubectl get deployments
```

----------------------------------------

TITLE: Define Docker Compose Services with Buildx Bake Extensions
DESCRIPTION: This `compose.yaml` configuration defines two services, `addon` and `aws`, demonstrating the use of Docker Buildx's `x-bake` extension for advanced image building. It includes features like multi-platform builds, build arguments, cache management, and secret mounting for the `aws` service.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/bake/compose-file.md#_snippet_2

LANGUAGE: yaml
CODE:
```
services:
  addon:
    image: ct-addon:bar
    build:
      context: .
      dockerfile: ./Dockerfile
      args:
        CT_ECR: foo
        CT_TAG: bar
      x-bake:
        tags:
          - ct-addon:foo
          - ct-addon:alp
        platforms:
          - linux/amd64
          - linux/arm64
        cache-from:
          - user/app:cache
          - type=local,src=path/to/cache
        cache-to:
          - type=local,dest=path/to/cache
        pull: true

  aws:
    image: ct-fake-aws:bar
    build:
      dockerfile: ./aws.Dockerfile
      args:
        CT_ECR: foo
        CT_TAG: bar
      x-bake:
        secret:
          - id=mysecret,src=./secret
          - id=mysecret2,src=./secret2
        platforms: linux/arm64
        output: type=docker
        no-cache: true
```

----------------------------------------

TITLE: Verify Running Docker Containers
DESCRIPTION: This command lists all currently running Docker containers. It's used to confirm that the `my-mysql` container started successfully and is in an 'Up' status.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/databases.md#_snippet_20

LANGUAGE: console
CODE:
```
$ docker ps
```

----------------------------------------

TITLE: Running Containerized Application in Background with Compose
DESCRIPTION: Starts the React.js application in detached mode (background) using Docker Compose. The `-d` option allows the terminal to remain free for other commands, while `--build` ensures images are rebuilt if needed.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/reactjs/containerize.md#_snippet_14

LANGUAGE: console
CODE:
```
$ docker compose up --build -d
```

----------------------------------------

TITLE: Start Docker Compose Stack in Detached Mode
DESCRIPTION: This command starts the services defined in the Docker Compose file in detached mode, allowing them to run in the background without tying up the terminal. The `--build` flag ensures that service images are built or rebuilt before starting the containers.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/develop.md#_snippet_36

LANGUAGE: console
CODE:
```
docker compose up --build -d
```

----------------------------------------

TITLE: Defining Docker ENTRYPOINT Without exec for Signal Handling Issues - Dockerfile
DESCRIPTION: This Dockerfile snippet defines an `ENTRYPOINT` in 'shell form' but omits `exec`. This configuration results in `/bin/sh -c` becoming `PID 1`, preventing `docker stop` from directly signaling the intended application process, leading to delayed shutdowns or `SIGKILL`.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_134

LANGUAGE: Dockerfile
CODE:
```
FROM ubuntu
ENTRYPOINT top -b
CMD -- --ignored-param1
```

----------------------------------------

TITLE: Define and Use Multiple Docker Compose Secrets in Advanced Setup
DESCRIPTION: This advanced example illustrates how to manage multiple secrets for different services. The 'db' service uses 'db_root_password' and 'db_password', while 'wordpress' uses 'db_password'. Secrets are defined globally and referenced per service, with their values sourced from respective files. It also highlights the '_FILE' environment variable convention used by some official Docker images for secret injection.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/use-secrets.md#_snippet_1

LANGUAGE: yaml
CODE:
```
services:
   db:
     image: mysql:latest
     volumes:
       - db_data:/var/lib/mysql
     environment:
       MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD_FILE: /run/secrets/db_password
     secrets:
       - db_root_password
       - db_password

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - "8000:80"
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD_FILE: /run/secrets/db_password
     secrets:
       - db_password


secrets:
   db_password:
     file: db_password.txt
   db_root_password:
     file: db_root_password.txt

volumes:
    db_data:
```

----------------------------------------

TITLE: Display full SBOM in JSON format with Docker Scout
DESCRIPTION: This command generates and displays the complete Software Bill Of Materials (SBOM) for the `alpine` image. By default, if no format is specified, the output is in JSON format.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/scout-cli/docs/scout_sbom.md#_snippet_3

LANGUAGE: console
CODE:
```
$ docker scout sbom alpine
```

----------------------------------------

TITLE: Update Dockerfile to run .NET tests during build
DESCRIPTION: This Dockerfile includes a `dotnet test` command in the `build` stage, ensuring that unit tests are executed as part of the image build process. It also defines development and final stages for a multi-stage build.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/dotnet/run-tests.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1

FROM --platform=$BUILDPLATFORM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build
ARG TARGETARCH
COPY . /source
WORKDIR /source/src
RUN --mount=type=cache,id=nuget,target=/root/.nuget/packages \
    dotnet publish -a ${TARGETARCH/amd64/x64} --use-current-runtime --self-contained false -o /app
RUN dotnet test /source/tests

FROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS development
COPY . /source
WORKDIR /source/src
CMD dotnet run --no-launch-profile

FROM mcr.microsoft.com/dotnet/aspnet:8.0-alpine AS final
WORKDIR /app
COPY --from=build /app .
ARG UID=10001
RUN adduser \
    --disabled-password \
    --gecos "" \
    --home "/nonexistent" \
    --shell "/sbin/nologin" \
    --no-create-home \
    --uid "${UID}" \
    appuser
USER appuser
ENTRYPOINT ["dotnet", "myWebApp.dll"]
```

----------------------------------------

TITLE: Resulting merged Docker Compose service configuration
DESCRIPTION: Shows the final `webapp` service configuration after merging `compose.yaml` and `compose.admin.yaml`. The `environment` field from the override file is added to the base configuration, demonstrating the additive merging behavior.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/multiple-compose-files/merge.md#_snippet_3

LANGUAGE: yaml
CODE:
```
webapp:
  image: examples/web
  ports:
    - "8000:8000"
  volumes:
    - "/data"
  environment:
    - DEBUG=1
```

----------------------------------------

TITLE: Configure Docker Daemon User Namespace Remapping via daemon.json
DESCRIPTION: Shows how to configure Docker's user namespace remapping by editing the `/etc/docker/daemon.json` file. This is the recommended method, allowing specification of a user/group for remapping. The example uses 'testuser'.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/security/userns-remap.md#_snippet_4

LANGUAGE: json
CODE:
```
{
  "userns-remap": "testuser"
}
```

----------------------------------------

TITLE: Pass Shell Environment Variables to Container with Compose `environment`
DESCRIPTION: Shows how to pass an environment variable from the shell directly to the container by listing its name without a value in the `environment` attribute. This behaves like `docker run -e VARIABLE ...`.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/how-tos/environment-variables/set-environment-variables.md#_snippet_1

LANGUAGE: yaml
CODE:
```
web:
  environment:
    - DEBUG
```

----------------------------------------

TITLE: Copy application code and entrypoint script into Docker image
DESCRIPTION: These commands copy all Python scripts (*.py) and the 'entrypoint.sh' script from the local machine into the '/app' directory inside the Docker image. This is a crucial step as the container needs these files to execute the application. The 'entrypoint.sh' script is particularly important as it defines how the application starts within the container.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/text-summarization.md#_snippet_13

LANGUAGE: dockerfile
CODE:
```
COPY *.py /app
COPY entrypoint.sh /app
```

----------------------------------------

TITLE: Running Docker Container Without exec ENTRYPOINT and PID 1 Verification - Shell
DESCRIPTION: This shell command runs a Docker container where the `ENTRYPOINT` was defined without `exec`. The `top` output clearly shows that `/bin/sh` is `PID 1`, and the `top` process is a child, illustrating the incorrect process hierarchy for signal handling.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_135

LANGUAGE: Shell
CODE:
```
$ docker run -it --name test top --ignored-param2

top - 13:58:24 up 17 min,  0 users,  load average: 0.00, 0.00, 0.00
Tasks:   2 total,   1 running,   1 sleeping,   0 stopped,   0 zombie
%Cpu(s): 16.7 us, 33.3 sy,  0.0 ni, 50.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   1990.8 total,   1354.6 free,    231.4 used,    404.7 buff/cache
MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   1639.8 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0    2612    604    536 S   0.0   0.0   0:00.02 sh
    6 root      20   0    5956   3188   2768 R   0.0   0.2   0:00.00 top
```

----------------------------------------

TITLE: Example .dockerignore file to reduce build context
DESCRIPTION: This example .dockerignore file demonstrates how to exclude specific files and directories, such as 'node_modules' and temporary files ('tmp*'), from the Docker build context. This reduces the amount of data sent to the builder and minimizes cache invalidation.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/cache/optimize.md#_snippet_2

LANGUAGE: plaintext
CODE:
```
node_modules
tmp*
```

----------------------------------------

TITLE: Recommended OCI label for Dockerfile author
DESCRIPTION: This Dockerfile snippet shows the correct and recommended way to specify the image author using the org.opencontainers.image.authors OCI label. This replaces the deprecated MAINTAINER instruction.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/rules/maintainer-deprecated.md#_snippet_2

LANGUAGE: dockerfile
CODE:
```
LABEL org.opencontainers.image.authors="moby@example.com"
```

----------------------------------------

TITLE: Block Docker Image Loading via `docker load`
DESCRIPTION: This setting prevents users from loading local Docker images using the `docker load` command. It is crucial for enforcing image provenance by ensuring all images originate from a secure, scanned registry, especially in hardened environments where this setting should be enabled and locked.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/security/for-admins/hardened-desktop/settings-management/settings-reference.md#_snippet_63

LANGUAGE: APIDOC
CODE:
```
Setting: blockDockerLoad
  Description: Prevent users from loading local Docker images using the `docker load` command.
  Default Value: false
  Accepted Values: true, false
  Format: Boolean
  OS: All
  Use Case: Enforce image provenance by restricting local image imports.
  Configuration Path: admin-settings.json -> blockDockerLoad
```

----------------------------------------

TITLE: Granting Build Access to Secrets (Short Syntax) (YAML)
DESCRIPTION: The `secrets` option grants access to sensitive data defined in the `secrets` section of the Compose file on a per-service build basis. The short syntax specifies only the secret name, mounting it as read-only to `/run/secrets/<secret_name>`.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/build.md#_snippet_30

LANGUAGE: yml
CODE:
```
services:
  frontend:
    build:
      context: .
      secrets:
        - server-certificate
secrets:
  server-certificate:
    file: ./server.cert
```

----------------------------------------

TITLE: List Docker Compose Services Status
DESCRIPTION: Provides a snapshot of the current state of all services defined in the `compose.yaml` file. It shows which containers are running, their status, and any exposed ports, offering a quick overview of the application's health.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/compose/intro/compose-application-model.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker compose ps
```

----------------------------------------

TITLE: Clone private Git repository using Dockerfile SSH mount
DESCRIPTION: Demonstrates how to use an SSH mount in a Dockerfile to clone a private Git repository. This method is suitable for SSH agent sockets or keys.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build/building/secrets.md#_snippet_4

LANGUAGE: dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine
ADD git@github.com:me/myprivaterepo.git /src/
```

----------------------------------------

TITLE: Run Docker Rust Image in Detached Mode
DESCRIPTION: Runs the Docker Rust image in detached mode (background) using the `--detach` (or `-d`) flag, while also publishing container port 8000 to host port 3001. Docker returns the container ID and frees the terminal.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/rust/run-containers.md#_snippet_4

LANGUAGE: console
CODE:
```
$ docker run -d -p 3001:8000 docker-rust-image
```

----------------------------------------

TITLE: Define and Reuse Volume Configuration
DESCRIPTION: This example demonstrates how to define a reusable volume configuration using a YAML anchor (`&default-volume`) and then reference it with an alias (`*default-volume`) to apply the same configuration to multiple volumes, such as `db-data` and `metrics`. This reduces repetition and ensures consistency across similar volume definitions.
SOURCE: https://github.com/docker/docs/blob/main/content/reference/compose-file/fragments.md#_snippet_0

LANGUAGE: yaml
CODE:
```
volumes:
  db-data: &default-volume
    driver: default
  metrics: *default-volume
```

----------------------------------------

TITLE: Set Docker Proxy via CLI for Build and Run Commands
DESCRIPTION: This example demonstrates how to specify proxy configurations directly on the command line. It shows using the `--build-arg` flag for `docker build` to pass `HTTP_PROXY` and the `--env` flag for `docker run` to set `HTTP_PROXY` for a container, providing flexible proxy control without modifying client configuration files.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/cli/proxy.md#_snippet_5

LANGUAGE: console
CODE:
```
$ docker build --build-arg HTTP_PROXY="http://proxy.example.com:3128" .
$ docker run --env HTTP_PROXY="http://proxy.example.com:3128" redis
```

----------------------------------------

TITLE: Run Command and Remove Container in Docker Compose
DESCRIPTION: Shows the `--rm` flag, which automatically removes the container after the command finishes execution. This is useful for one-off tasks like database migrations, ensuring no lingering containers are left behind, even if a restart policy is defined.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/docker/compose/v2/docs/reference/compose_run.md#_snippet_12

LANGUAGE: console
CODE:
```
$ docker compose run --rm web python manage.py db upgrade
```

----------------------------------------

TITLE: Start the development environment with Docker Compose
DESCRIPTION: Initiate the application's development environment using Docker Compose. This command pulls necessary container images, starts all defined services (frontend, backend, database, etc.), and sets up the network, making the application accessible.
SOURCE: https://github.com/docker/docs/blob/main/content/get-started/introduction/develop-with-containers.md#_snippet_2

LANGUAGE: console
CODE:
```
$ docker compose watch
```

----------------------------------------

TITLE: Example Docker Compose Database Authentication Error
DESCRIPTION: This snippet shows a common `pq: password authentication failed` error encountered when a Docker Compose application attempts to connect to a database (e.g., CockroachDB) after new volumes have been created. This typically happens when the database is not initialized in the new volume.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/golang/develop.md#_snippet_32

LANGUAGE: text
CODE:
```
# ... omitted output ...
rest-server             | 2021/05/10 00:54:25 failed to initialise the store: pq: password authentication failed for user totoro
roach                   | *
roach                   | * INFO: Replication was disabled for this cluster.
roach                   | * When/if adding nodes in the future, update zone configurations to increase the replication factor.
roach                   | *
roach                   | CockroachDB node starting at 2021-05/10 00:54:26.398177 +0000 UTC (took 3.0s)
roach                   | build:               CCL v20.1.15 @ 2021/04/26 16:11:58 (go1.13.9)
roach                   | webui:               http://db:8080
roach                   | sql:                 postgresql://root@db:26257?sslmode=disable
roach                   | RPC client flags:    /cockroach/cockroach <client cmd> --host=db:26257 --insecure
roach                   | logs:                /cockroach/cockroach-data/logs
roach                   | temp dir:            /cockroach/cockroach-data/cockroach-temp349434348
roach                   | external I/O path:   /cockroach/cockroach-data/extern
roach                   | store[0]:            path=/cockroach/cockroach-data
roach                   | storage engine:      rocksdb
roach                   | status:              initialized new cluster
roach                   | clusterID:           b7b1cb93-558f-4058-b77e-8a4ddb329a88
roach                   | nodeID:              1
rest-server exited with code 0
rest-server             | 2021/05/10 00:54:25 failed to initialise the store: pq: password authentication failed for user totoro
rest-server             | 2021/05/10 00:54:26 failed to initialise the store: pq: password authentication failed for user totoro
rest-server             | 2021/05/10 00:54:29 failed to initialise the store: pq: password authentication failed for user totoro
rest-server             | 2021/05/10 00:54:25 failed to initialise the store: pq: password authentication failed for user totoro
rest-server             | 2021/05/10 00:54:26 failed to initialise the store: pq: password authentication failed for user totoro
rest-server             | 2021/05/10 00:54:29 failed to initialise the store: pq: password authentication failed for user totoro
rest-server exited with code 1
```

----------------------------------------

TITLE: Build Docker Image with SBOM and Provenance Attestations
DESCRIPTION: To ensure compliance with Supply Chain Attestations policy, update your build command to attach SBOM and provenance attestations at build-time. This example uses `docker buildx build` to include these attestations.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/scout/policy/_index.md#_snippet_0

LANGUAGE: console
CODE:
```
$ docker buildx build --provenance=true --sbom=true -t <IMAGE> --push .
```

----------------------------------------

TITLE: Listing Running Docker Containers
DESCRIPTION: This command displays a list of all currently running Docker containers. It provides information such as container ID, image name, command, creation time, status, ports, and names, which is useful for verifying that the application container is active.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/go-prometheus-monitoring/containerize.md#_snippet_3

LANGUAGE: Shell
CODE:
```
$ docker ps
```

----------------------------------------

TITLE: Restart Docker daemon after configuration changes
DESCRIPTION: After modifying `daemon.json`, restart the Docker daemon for the changes to take effect. This command uses `systemctl` on Linux systems.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/storage/containerd.md#_snippet_1

LANGUAGE: console
CODE:
```
$ sudo systemctl restart docker
```

----------------------------------------

TITLE: Accessing GitLab with Dockerfile RUN --mount=type=ssh
DESCRIPTION: This Dockerfile snippet shows how to use `RUN --mount=type=ssh` to access a private GitLab repository during a build. It installs `openssh-client`, adds `gitlab.com` to known hosts, and then uses the SSH mount to authenticate with GitLab via an SSH agent, allowing commands like `ssh -q -T git@gitlab.com` to succeed.
SOURCE: https://github.com/docker/docs/blob/main/_vendor/github.com/moby/buildkit/frontend/dockerfile/docs/reference.md#_snippet_54

LANGUAGE: Dockerfile
CODE:
```
# syntax=docker/dockerfile:1
FROM alpine
RUN apk add --no-cache openssh-client
RUN mkdir -p -m 0700 ~/.ssh && ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
RUN --mount=type=ssh \
  ssh -q -T git@gitlab.com 2>&1 | tee /hello
```

----------------------------------------

TITLE: Define Kubernetes Deployment and Service for Java App
DESCRIPTION: This Kubernetes YAML file defines two objects: a Deployment for a Java application, specifying a single replica using a Docker image, and a NodePort Service to expose the application. The service routes traffic from host port 30001 to container port 8080, making the application accessible locally.
SOURCE: https://github.com/docker/docs/blob/main/content/guides/java/deploy.md#_snippet_0

LANGUAGE: YAML
CODE:
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: docker-java-demo
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      service: server
  template:
    metadata:
      labels:
        service: server
    spec:
      containers:
        - name: server-service
          image: DOCKER_USERNAME/REPO_NAME
          imagePullPolicy: Always
---
apiVersion: v1
kind: Service
metadata:
  name: service-entrypoint
  namespace: default
spec:
  type: NodePort
  selector:
    service: server
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30001
```

----------------------------------------

TITLE: Authenticate and Build with Private Registries
DESCRIPTION: This snippet shows the sequence of commands to authenticate with Docker Hub and a private OCI registry using `docker login` with standard input for passwords, then building and pushing a Docker image to the private registry using a specified cloud builder.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/build-cloud/builder-settings.md#_snippet_0

LANGUAGE: console
CODE:
```
$ echo $DOCKER_PAT | docker login docker.io -u <username> --password-stdin
$ echo $REGISTRY_PASSWORD | docker login registry.example.com -u <username> --password-stdin
$ docker build --builder <cloud-builder> --tag registry.example.com/<image> --push .
```

----------------------------------------

TITLE: Create Docker Nginx Service on Overlay Network
DESCRIPTION: This command creates a Docker service named `my-nginx` with 5 replicas. It publishes port 80 of the service containers to port 80 on the host and connects the service to the `nginx-net` overlay network. This setup allows the service tasks to communicate with each other and be accessible across the swarm, leveraging the ingress mode for load balancing.
SOURCE: https://github.com/docker/docs/blob/main/content/manuals/engine/network/tutorials/overlay.md#_snippet_6

LANGUAGE: console
CODE:
```
$ docker service create \
  --name my-nginx \
  --publish target=80,published=80 \
  --replicas=5 \
  --network nginx-net \
  nginx
```
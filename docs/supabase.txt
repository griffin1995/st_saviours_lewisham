TITLE: Create PostgreSQL RLS Policy for User-Specific Rows
DESCRIPTION: This SQL snippet defines a Row Level Security (RLS) policy named `todo_select_policy` on the `todos` table. It allows users to select only their own rows by checking if the authenticated user's ID (`auth.uid()`) matches the `user_id` column in the `todos` table. This ensures data privacy and security by restricting access to individual rows based on user identity.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-12-01-realtime-row-level-security-in-postgresql.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create policy todo_select_policy
    on todos for select
    using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Create SELECT policy for individual user data
DESCRIPTION: Example of a Postgres RLS policy that allows users to view only their own records in a 'todos' table. It uses `auth.uid()` to match the current user's ID with the `user_id` column.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
create policy "Individuals can view their own todos."
on todos for select
using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Enable Row Level Security for a table
DESCRIPTION: SQL command to enable Row Level Security on a specified table. Once enabled, no data will be accessible via the API using the public `anon` key until policies are created.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
alter table "table_name" enable row level security;
```

----------------------------------------

TITLE: Create PostgreSQL Function for Vector Similarity Search
DESCRIPTION: This SQL function, `match_documents`, enables similarity search on a `documents` table by comparing a `query_embedding` to existing document embeddings. It calculates similarity using the cosine distance operator (`<=>`), filters results based on a `match_threshold`, and limits the number of returned documents by `match_count`. This approach is necessary because PostgREST does not directly support `pgvector` similarity operators.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/vector-columns.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create or replace function match_documents (
  query_embedding vector(384),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  title text,
  body text,
  similarity float
)
language sql stable
as $$
  select
    documents.id,
    documents.title,
    documents.body,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  where 1 - (documents.embedding <=> query_embedding) > match_threshold
  order by (documents.embedding <=> query_embedding) asc
  limit match_count;
$$;
```

----------------------------------------

TITLE: Supabase Database Schema and Policies for Profiles
DESCRIPTION: SQL script to define the `profiles` table, including columns for user ID, update timestamp, username, avatar URL, and website. It sets up Row Level Security (RLS) policies to control access for viewing, inserting, and updating profiles. Additionally, it configures Supabase Realtime for the `profiles` table and creates a storage bucket named 'avatars' with public access policies.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/nuxt3-user-management/README.md#_snippet_1

LANGUAGE: sql
CODE:
```
-- Create a table for public "profiles"
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );

create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Supabase Auth: Sign in with Email Magic Link
DESCRIPTION: Demonstrates how to initiate a passwordless login using a Magic Link sent to a user's email address. The `signInWithOtp` method is used, which sends a Magic Link by default. Options like `shouldCreateUser` (to prevent automatic sign-up) and `emailRedirectTo` (for post-login redirection) can be configured.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-email-passwordless.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('url', 'anonKey')

async function signInWithEmail() {
  const { data, error } = await supabase.auth.signInWithOtp({
    email: 'valid.email@supabase.io',
    options: {
      // set this to false if you do not want the user to be automatically signed up
      shouldCreateUser: false,
      emailRedirectTo: 'https://example.com/welcome',
    },
  })
}
```

LANGUAGE: TypeScript
CODE:
```
import { makeRedirectUri } from 'expo-auth-session'

const redirectTo = makeRedirectUri()

const { error } = await supabase.auth.signInWithOtp({
  email: 'valid.email@supabase.io',
  options: {
    emailRedirectTo: redirectTo,
  },
})
```

LANGUAGE: Dart
CODE:
```
Future<void> signInWithEmail() async {
  final AuthResponse res = await supabase.auth.signinwithotp(email: 'valid.email@supabase.io');
}
```

LANGUAGE: Swift
CODE:
```
try await supabase.auth.signInWithOTP(
  email: "valid.email@supabase.io",
  redirectTo: URL(string: "https://example.com/welcome"),
  // set this to false if you do not want the user to be automatically signed up
  shouldCreateUser: false
)
```

LANGUAGE: Kotlin
CODE:
```
suspend fun signInWithEmail() {
	supabase.auth.signInWith(OTP) {
		email = "valid.email@supabase.io"
	}
}
```

LANGUAGE: Python
CODE:
```
response = supabase.auth.sign_in_with_otp({
  'email': 'valid.email@supabase.io',
  'options': {
    # set this to false if you do not want the user to be automatically signed up
    'should_create_user': False,
    'email_redirect_to': 'https://example.com/welcome',
  },
})
```

----------------------------------------

TITLE: Create Supabase User Profile Table and Auth Trigger with Security Definer
DESCRIPTION: This comprehensive SQL example demonstrates how to set up a `profiles` table and an associated trigger on `auth.users` that automatically populates profile data for new users. The key is the `security definer` clause on the `handle_new_user` function, which allows the trigger to operate with the privileges of the function's creator (e.g., `postgres` role), thereby preventing permission errors when interacting with tables outside the `auth` schema.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/dashboard-errors-when-managing-users-N1ls4A.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,

  constraint username_length check (char_length(username) >= 3)
);

create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
```

----------------------------------------

TITLE: Postgres Default Data Types Reference
DESCRIPTION: A comprehensive list of default data types available in PostgreSQL, including their names, common aliases, and a brief description of their purpose and characteristics. These types can be used when defining columns in a Postgres database.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/tables.mdx#_snippet_1

LANGUAGE: APIDOC
CODE:
```
Postgres Data Types:
  - Name: bigint
    Aliases: int8
    Description: signed eight-byte integer
  - Name: bigserial
    Aliases: serial8
    Description: autoincrementing eight-byte integer
  - Name: bit
    Aliases: 
    Description: fixed-length bit string
  - Name: bit varying
    Aliases: varbit
    Description: variable-length bit string
  - Name: boolean
    Aliases: bool
    Description: logical Boolean (true/false)
  - Name: box
    Aliases: 
    Description: rectangular box on a plane
  - Name: bytea
    Aliases: 
    Description: binary data (“byte array”)
  - Name: character
    Aliases: char
    Description: fixed-length character string
  - Name: character varying
    Aliases: varchar
    Description: variable-length character string
  - Name: cidr
    Aliases: 
    Description: IPv4 or IPv6 network address
  - Name: circle
    Aliases: 
    Description: circle on a plane
  - Name: date
    Aliases: 
    Description: calendar date (year, month, day)
  - Name: double precision
    Aliases: float8
    Description: double precision floating-point number (8 bytes)
  - Name: inet
    Aliases: 
    Description: IPv4 or IPv6 host address
  - Name: integer
    Aliases: int, int4
    Description: signed four-byte integer
  - Name: interval [ fields ]
    Aliases: 
    Description: time span
  - Name: json
    Aliases: 
    Description: textual JSON data
  - Name: jsonb
    Aliases: 
    Description: binary JSON data, decomposed
  - Name: line
    Aliases: 
    Description: infinite line on a plane
  - Name: lseg
    Aliases: 
    Description: line segment on a plane
  - Name: macaddr
    Aliases: 
    Description: MAC (Media Access Control) address
  - Name: macaddr8
    Aliases: 
    Description: MAC (Media Access Control) address (EUI-64 format)
  - Name: money
    Aliases: 
    Description: currency amount
  - Name: numeric
    Aliases: decimal
    Description: exact numeric of selectable precision
  - Name: path
    Aliases: 
    Description: geometric path on a plane
  - Name: pg_lsn
    Aliases: 
    Description: Postgres Log Sequence Number
  - Name: pg_snapshot
    Aliases: 
    Description: user-level transaction ID snapshot
  - Name: point
    Aliases: 
    Description: geometric point on a plane
  - Name: polygon
    Aliases: 
    Description: closed geometric path on a plane
  - Name: real
    Aliases: float4
    Description: single precision floating-point number (4 bytes)
  - Name: smallint
    Aliases: int2
    Description: signed two-byte integer
  - Name: smallserial
    Aliases: serial2
    Description: autoincrementing two-byte integer
  - Name: serial
    Aliases: serial4
    Description: autoincrementing four-byte integer
  - Name: text
    Aliases: 
    Description: variable-length character string
  - Name: time [ without time zone ]
    Aliases: 
    Description: time of day (no time zone)
```

----------------------------------------

TITLE: Migrate `withApiAuth` to `createPagesServerClient` for Next.js API Routes
DESCRIPTION: The `withApiAuth` higher-order function is deprecated. This snippet demonstrates how to update Next.js API routes by replacing `withApiAuth` with `createPagesServerClient`. The new approach involves explicitly creating an authenticated Supabase client within the `NextApiHandler` and manually checking for user sessions before performing RLS-enabled queries.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_15

LANGUAGE: tsx
CODE:
```
import { withApiAuth } from '@supabase/auth-helpers-nextjs'

export default withApiAuth(async function ProtectedRoute(req, res, supabase) {
  // Run queries with RLS on the server
  const { data } = await supabase.from('test').select('*')
  res.json(data)
})
```

LANGUAGE: tsx
CODE:
```
import { NextApiHandler } from 'next'
import { createPagesServerClient } from '@supabase/auth-helpers-nextjs'

const ProtectedRoute: NextApiHandler = async (req, res) => {
  // Create authenticated Supabase Client
  const supabase = createPagesServerClient({ req, res })
  // Check if we have a session
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user)
    return res.status(401).json({
      error: 'not_authenticated',
      description: 'The user does not have an active session or is not authenticated',
    })

  // Run queries with RLS on the server
  const { data } = await supabase.from('test').select('*')
  res.json(data)
}

export default ProtectedRoute
```

----------------------------------------

TITLE: Supabase Edge Function for Similarity Search with OpenAI
DESCRIPTION: This Edge Function handles incoming search queries, generates a one-time OpenAI embedding for the query, and then calls a Supabase RPC function ('match_documents') to find and return relevant documents based on vector similarity. It also includes CORS handling.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-02-03-openai-embeddings-postgres-vector.mdx#_snippet_5

LANGUAGE: TypeScript
CODE:
```
import { serve } from 'https://deno.land/std@0.170.0/http/server.ts'
import 'https://deno.land/x/xhr@0.2.1/mod.ts'
import { createClient } from 'jsr:@supabase/supabase-js@2'
import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.1.0'
import { supabaseClient } from './lib/supabase'

export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  // Search query is passed in request payload
  const { query } = await req.json()

  // OpenAI recommends replacing newlines with spaces for best results
  const input = query.replace(/\n/g, ' ')

  const configuration = new Configuration({ apiKey: '<YOUR_OPENAI_API_KEY>' })
  const openai = new OpenAIApi(configuration)

  // Generate a one-time embedding for the query itself
  const embeddingResponse = await openai.createEmbedding({
    model: 'text-embedding-ada-002',
    input,
  })

  const [{ embedding }] = embeddingResponse.data.data

  // In production we should handle possible errors
  const { data: documents } = await supabaseClient.rpc('match_documents', {
    query_embedding: embedding,
    match_threshold: 0.78, // Choose an appropriate threshold for your data
    match_count: 10, // Choose the number of matches
  })

  return new Response(JSON.stringify(documents), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
})
```

----------------------------------------

TITLE: Disable Next.js Caching for Dynamic Data
DESCRIPTION: These Next.js page configurations prevent data caching, ensuring fresh data is fetched on every request. This is particularly useful when dealing with frequently changing data or Row Level Security (RLS) updates that might not immediately reflect due to Next.js's default caching behavior.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/nextjs-1314-stale-data-when-changing-rls-or-table-data-85b8oQ.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
export const dynamic = 'force-dynamic'; // no caching
```

LANGUAGE: JavaScript
CODE:
```
export const fetchCache = 'force-no-store' // to page.js
```

LANGUAGE: JavaScript
CODE:
```
export const revalidate = 0
```

----------------------------------------

TITLE: Initialize Supabase Client with URL and Anon Key
DESCRIPTION: This code demonstrates how to initialize the Supabase client using your project's URL and anonymous public key. These credentials are required to connect your application to your Supabase database.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-03-11-using-supabase-replit.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
const supabase = createClient(
  'https://ajsstlnzcmdmzbtcgbbd.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...'
)
```

----------------------------------------

TITLE: Create triggers for embedding jobs on insert/update in PostgreSQL
DESCRIPTION: Sets up PostgreSQL triggers to enqueue embedding jobs whenever content is inserted or updated in the `documents` table. These triggers use the `util.queue_embeddings` function to queue the jobs, ensuring that embeddings are automatically generated for new and modified content.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/automatic-embeddings.mdx#_snippet_15

LANGUAGE: SQL
CODE:
```
-- Trigger for insert events
create trigger embed_documents_on_insert
  after insert
  on documents
  for each row
  execute function util.queue_embeddings('embedding_input', 'embedding');

-- Trigger for update events
create trigger embed_documents_on_update
  after update of title, content -- must match the columns in embedding_input()
  on documents
  for each row
  execute function util.queue_embeddings('embedding_input', 'embedding');
```

----------------------------------------

TITLE: Automating Supabase Type Updates with GitHub Actions Workflow (YAML)
DESCRIPTION: This YAML snippet defines a GitHub Actions workflow that runs daily to automatically update Supabase database types. It checks out the repository, sets up Node.js, runs the `update-types` script defined in `package.json`, checks for file changes, commits any new type definitions, and pushes them back to the repository. It requires `SUPABASE_ACCESS_TOKEN` and `PROJECT_REF` as environment variables.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/rest/generating-types.mdx#_snippet_17

LANGUAGE: yaml
CODE:
```
name: Update database types

on:
  schedule:
    # sets the action to run daily. You can modify this to run the action more or less frequently
    - cron: '0 0 * * *'

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      SUPABASE_ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
      PROJECT_REF: <your-project-id>
    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: 22
      - run: npm run update-types
      - name: check for file changes
        id: git_status
        run: |
          echo "status=$(git status -s)" >> $GITHUB_OUTPUT
      - name: Commit files
        if: ${{contains(steps.git_status.outputs.status, ' ')}}
        run: |
          git add database.types.ts
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git commit -m "Update database types" -a
      - name: Push changes
        if: ${{contains(steps.git_status.outputs.status, ' ')}}
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}
```

----------------------------------------

TITLE: Implement Flutter Account Page with Supabase Integration
DESCRIPTION: This Dart code defines the `AccountPage` widget, which manages user profiles in a Flutter application using Supabase. It includes methods for fetching user profiles (`_getProfile`), updating profile details (`_updateProfile`), signing out (`_signOut`), and handling avatar uploads (`_onUpload`). The page displays user information, allows editing, and updates the avatar URL in the Supabase 'profiles' table upon image upload.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-flutter.mdx#_snippet_10

LANGUAGE: dart
CODE:
```
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:supabase_quickstart/components/avatar.dart';
import 'package:supabase_quickstart/main.dart';
import 'package:supabase_quickstart/pages/login_page.dart';

class AccountPage extends StatefulWidget {
  const AccountPage({super.key});

  @override
  State<AccountPage> createState() => _AccountPageState();
}

class _AccountPageState extends State<AccountPage> {
  final _usernameController = TextEditingController();
  final _websiteController = TextEditingController();

  String? _avatarUrl;
  var _loading = true;

  /// Called once a user id is received within `onAuthenticated()`
  Future<void> _getProfile() async {
    setState(() {
      _loading = true;
    });

    try {
      final userId = supabase.auth.currentSession!.user.id;
      final data =
          await supabase.from('profiles').select().eq('id', userId).single();
      _usernameController.text = (data['username'] ?? '') as String;
      _websiteController.text = (data['website'] ?? '') as String;
      _avatarUrl = (data['avatar_url'] ?? '') as String;
    } on PostgrestException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    } finally {
      if (mounted) {
        setState(() {
          _loading = false;
        });
      }
    }
  }

  /// Called when user taps `Update` button
  Future<void> _updateProfile() async {
    setState(() {
      _loading = true;
    });
    final userName = _usernameController.text.trim();
    final website = _websiteController.text.trim();
    final user = supabase.auth.currentUser;
    final updates = {
      'id': user!.id,
      'username': userName,
      'website': website,
      'updated_at': DateTime.now().toIso8601String(),
    };
    try {
      await supabase.from('profiles').upsert(updates);
      if (mounted) context.showSnackBar('Successfully updated profile!');
    } on PostgrestException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    } finally {
      if (mounted) {
        setState(() {
          _loading = false;
        });
      }
    }
  }

  Future<void> _signOut() async {
    try {
      await supabase.auth.signOut();
    } on AuthException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    } finally {
      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const LoginPage()),
        );
      }
    }
  }

  /// Called when image has been uploaded to Supabase storage from within Avatar widget
  Future<void> _onUpload(String imageUrl) async {
    try {
      final userId = supabase.auth.currentUser!.id;
      await supabase.from('profiles').upsert({
        'id': userId,
        'avatar_url': imageUrl,
      });
      if (mounted) {
        const SnackBar(
          content: Text('Updated your profile image!'),
        );
      }
    } on PostgrestException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    }
    if (!mounted) {
      return;
    }

    setState(() {
      _avatarUrl = imageUrl;
    });
  }

  @override
  void initState() {
    super.initState();
    _getProfile();
  }

  @override
  void dispose() {
    _usernameController.dispose();
    _websiteController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 12),
        children: [
          Avatar(
            imageUrl: _avatarUrl,
            onUpload: _onUpload,
          ),
          const SizedBox(height: 18),
          TextFormField(
            controller: _usernameController,
            decoration: const InputDecoration(labelText: 'User Name'),
          ),
          const SizedBox(height: 18),
          TextFormField(
            controller: _websiteController,
            decoration: const InputDecoration(labelText: 'Website'),
          ),
          const SizedBox(height: 18),
          ElevatedButton(
            onPressed: _loading ? null : _updateProfile,

```

----------------------------------------

TITLE: Perform Metadata Filtered Similarity Search in LangChain with Supabase
DESCRIPTION: This JavaScript example extends the basic usage by demonstrating how to apply metadata filtering during a similarity search. It uses the `match_documents` Postgres function's filter parameter to narrow down search results based on specified JSONB metadata values, such as `user_id`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/langchain.mdx#_snippet_2

LANGUAGE: js
CODE:
```
import { SupabaseVectorStore } from 'langchain/vectorstores/supabase'
import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
import { createClient } from '@supabase/supabase-js'

// First, follow set-up instructions above

const privateKey = process.env.SUPABASE_SERVICE_ROLE_KEY
if (!privateKey) throw new Error(`Expected env var SUPABASE_SERVICE_ROLE_KEY`)

const url = process.env.SUPABASE_URL
if (!url) throw new Error(`Expected env var SUPABASE_URL`)

export const run = async () => {
  const client = createClient(url, privateKey)

  const vectorStore = await SupabaseVectorStore.fromTexts(
    ['Hello world', 'Hello world', 'Hello world'],
    [{ user_id: 2 }, { user_id: 1 }, { user_id: 3 }],
    new OpenAIEmbeddings(),
    {
      client,
      tableName: 'documents',
      queryName: 'match_documents',
    }
  )

  const result = await vectorStore.similaritySearch('Hello world', 1, {
    user_id: 3,
  })

  console.log(result)
}
```

----------------------------------------

TITLE: Implement Supabase Authentication Middleware in Next.js
DESCRIPTION: This code snippet provides the implementation for a Next.js middleware designed to handle Supabase authentication. Its primary functions include refreshing expired authentication tokens by calling `supabase.auth.getUser()`, and then propagating these refreshed tokens to both Server Components (via `request.cookies.set`) and the user's browser (via `response.cookies.set`). The `config.matcher` is used to specify paths where the middleware should run, optimizing performance. A critical security warning is highlighted: always use `supabase.auth.getUser()` for protecting pages and user data, and never rely on `supabase.auth.getSession()` in server-side code like middleware, as it does not guarantee token revalidation. The snippet also includes important guidelines on the correct handling of `supabaseResponse` and the placement of `auth.getUser()` calls to prevent session issues.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/nextjs.mdx#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { type NextRequest } from 'next/server'
import { updateSession } from '@/utils/supabase/middleware'

export async function middleware(request: NextRequest) {
  return await updateSession(request)
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'
  ]
}
```

LANGUAGE: TypeScript
CODE:
```
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        }
      }
    }
  )

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()

  const {
    data: { user }
  } = await supabase.auth.getUser()

  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse
}
```

----------------------------------------

TITLE: Optimize Supabase RLS Policy with Wrapped SQL Function
DESCRIPTION: This snippet demonstrates how to improve the performance of Row-Level Security (RLS) policies in PostgreSQL, particularly with Supabase's `auth.uid()` function. By wrapping the function call in a `SELECT` statement within the `USING` clause of a `CREATE POLICY` statement, the Postgres optimizer can run an `initPlan` and cache the function's result per-statement, avoiding repeated execution for each row. This technique is effective for JWT functions and `security definer` functions, but only when the function's result does not depend on row data.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_16

LANGUAGE: SQL
CODE:
```
create policy "rls_test_select" on test_table
to authenticated
using ( auth.uid() = user_id );
```

LANGUAGE: SQL
CODE:
```
create policy "rls_test_select" on test_table
to authenticated
using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Initialize Supabase client with generated types
DESCRIPTION: Shows how to import and apply the generated `Database` types when initializing the Supabase client. This enables type-safe queries, as illustrated by selecting data from the 'messages' table with compile-time type checking.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-16-supabase-js-v2.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
import type { Database } from './DatabaseDefinitions'

const supabase = createClient<Database>(SUPABASE_URL, ANON_KEY)

const { data } = await supabase.from('messages').select().match({ id: 1 })
```

----------------------------------------

TITLE: Start the local Supabase stack
DESCRIPTION: Start the Supabase services locally on your machine. This command spins up the necessary containers for your local Postgres database, Auth, Storage, and other Supabase features. Requires a Docker-compatible container runtime.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/local-development.mdx#_snippet_2

LANGUAGE: sh
CODE:
```
npx supabase start
```

LANGUAGE: sh
CODE:
```
yarn supabase start
```

LANGUAGE: sh
CODE:
```
pnpx supabase start
```

LANGUAGE: sh
CODE:
```
supabase start
```

----------------------------------------

TITLE: Implementing AI-Powered Filter Generation API with TypeScript
DESCRIPTION: This TypeScript code defines an API endpoint (POST) that uses the AI SDK to generate complex filter groups from natural language prompts. It leverages Zod for robust schema validation of both input filter properties and the generated filter structure, including nested filter groups. The endpoint validates generated property names and operators against predefined properties, ensuring data integrity and preventing invalid queries.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/design-system/content/docs/fragments/filter-bar.mdx#_snippet_6

LANGUAGE: TypeScript
CODE:
```
import { generateObject } from 'ai'
import { openai } from '@ai-sdk/openai'
import { z } from 'zod'

// Define schemas for validation
const FilterProperty = z.object({
  label: z.string(),
  name: z.string(),
  type: z.enum(['string', 'number', 'date', 'boolean']),
  options: z.array(z.string()).optional(),
  operators: z.array(z.string()).optional()
})

const FilterCondition = z.object({
  propertyName: z.string(),
  value: z.union([z.string(), z.number(), z.boolean(), z.null()]),
  operator: z.string()
})

type FilterGroupType = {
  logicalOperator: 'AND' | 'OR'
  conditions: Array<z.infer<typeof FilterCondition> | FilterGroupType>
}

const FilterGroup: z.ZodType<FilterGroupType> = z.lazy(() =>
  z.object({
    logicalOperator: z.enum(['AND', 'OR']),
    conditions: z.array(z.union([FilterCondition, FilterGroup]))
  })
)

export async function POST(req: Request) {
  const { prompt, filterProperties } = await req.json()
  const filterPropertiesString = JSON.stringify(filterProperties)

  try {
    const { object } = await generateObject({
      model: openai('gpt-4-mini'),
      schema: FilterGroup,
      prompt: `Generate a filter group based on the following prompt: "${prompt}". 
              Use only these filter properties: ${filterPropertiesString}. 
              Each property has its own set of valid operators defined in the operators field. 
              Return a filter group with a logical operator ('AND'/'OR') and an array of conditions. 
              Each condition can be either a filter condition or another filter group. 
              Filter conditions should have the structure: { propertyName: string, value: string | number | boolean | null, operator: string }. 
              Ensure that the generated filters use only the provided property names and their corresponding operators.`
    })

    // Validate that all propertyNames exist in filterProperties
    const validatePropertyNames = (group: FilterGroupType): boolean => {
      return group.conditions.every((condition) => {
        if ('logicalOperator' in condition) {
          return validatePropertyNames(condition as FilterGroupType)
        }
        const property = filterProperties.find(
          (p: z.infer<typeof FilterProperty>) => p.name === condition.propertyName
        )
        if (!property) return false
        // Validate operator is valid for this property
        return property.operators?.includes(condition.operator) ?? false
      })
    }

    if (!validatePropertyNames(object)) {
      throw new Error('Invalid property names or operators in generated filter')
    }

    // Zod will throw an error if the object doesn't match the schema
    const validatedFilters = FilterGroup.parse(object)
    return Response.json(validatedFilters)
  } catch (error: any) {
    console.error('Error in AI filtering:', error)
    return Response.json({ error: error.message || 'AI filtering failed' }, { status: 500 })
  }
}
```

----------------------------------------

TITLE: Supabase Database and Storage Schema
DESCRIPTION: SQL script defining the `profiles` table with user authentication references, row-level security policies for select, insert, and update operations, Realtime setup for `profiles`, and Storage bucket configuration for `avatars` with public access policies.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/flutter-user-management/README.md#_snippet_2

LANGUAGE: sql
CODE:
```
-- Create a table for public "profiles"
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );

create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: Add the necessary Supabase URL and anonymous key to your project's .env file. These variables are crucial for your application to connect and interact with your Supabase backend, enabling authentication and data operations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/ui-library/content/docs/tanstack/password-based-auth.mdx#_snippet_0

LANGUAGE: env
CODE:
```
VITE_SUPABASE_URL=
VITE_SUPABASE_ANON_KEY=
```

----------------------------------------

TITLE: Store Amazon Bedrock Embeddings in Postgres with vecs
DESCRIPTION: This Python code connects to a Postgres database using `vecs`, creates or retrieves a vector collection named 'sentences' with a dimension matching the Titan embeddings, and then upserts the previously generated embeddings into this collection. Finally, it creates an index for efficient similarity searches.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/integrations/amazon-bedrock.mdx#_snippet_2

LANGUAGE: python
CODE:
```
import vecs

DB_CONNECTION = "postgresql://<user>:<password>@<host>:<port>/<db_name>"

# create vector store client
vx = vecs.Client(DB_CONNECTION)

# create a collection named 'sentences' with 1536 dimensional vectors
# to match the default dimension of the Titan Embeddings G1 - Text model
sentences = vx.get_or_create_collection(name="sentences", dimension=1536)

# upsert the embeddings into the 'sentences' collection
sentences.upsert(records=embeddings)

# create an index for the 'sentences' collection
sentences.create_index()
```

----------------------------------------

TITLE: Define Foreign Key with CASCADE Delete
DESCRIPTION: Illustrates how to create a foreign key constraint on `child_table` referencing `parent_table` with the `ON DELETE CASCADE` option, ensuring that deleting a parent row also deletes all related rows in the child table.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/cascade-deletes.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
alter table child_table
add constraint fk_parent foreign key (parent_id) references parent_table (id)
  on delete cascade;
```

----------------------------------------

TITLE: Create GIN and HNSW indexes for hybrid search performance
DESCRIPTION: Establishes indexes on the `documents` table to optimize search performance. A GIN index is created on the `fts` column for efficient full-text search, and an HNSW index is applied to the `embedding` column using `vector_ip_ops` for fast approximate nearest neighbor semantic search. These indexes are crucial for scaling queries.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/hybrid-search.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
-- Create an index for the full-text search
create index on documents using gin(fts);

-- Create an index for the semantic vector search
create index on documents using hnsw (embedding vector_ip_ops);
```

----------------------------------------

TITLE: Postgres Row Level Security Policies, Realtime, and Storage Setup
DESCRIPTION: This SQL snippet defines the 'profiles' table, enables Row Level Security (RLS), and sets up policies for public viewing, user-specific inserts, and updates. It also configures Supabase Realtime for the 'profiles' table and creates policies for 'avatars' storage bucket, allowing public access and uploads.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/sveltekit-user-management/README.md#_snippet_0

LANGUAGE: SQL
CODE:
```
-- Create a table for Public Profiles
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,
  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);
alter table profiles enable row level security;
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );
create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );
create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );
-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;
-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');
create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );
create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Generate TypeScript Types for Supabase Schemas
DESCRIPTION: This command generates TypeScript type definitions for the `storage` and `public` schemas from your Supabase project, saving them to a `types.ts` file within your Edge Function directory. Remember to replace `your-project-ref` with your actual Supabase project ID.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/edge-functions/supabase/functions/huggingface-image-captioning/README.md#_snippet_0

LANGUAGE: bash
CODE:
```
supabase gen types typescript --project-id=your-project-ref --schema=storage,public > supabase/functions/huggingface-image-captioning/types.ts
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: This snippet shows the required environment variables for connecting to a Supabase project. These values are essential for the Supabase client to initialize and interact with your backend services, allowing your application to communicate with Supabase.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/ui-library/content/docs/react/password-based-auth.mdx#_snippet_0

LANGUAGE: env
CODE:
```
VITE_SUPABASE_URL=
VITE_SUPABASE_ANON_KEY=
```

----------------------------------------

TITLE: Creating `authorize` Function for RLS in PostgreSQL
DESCRIPTION: This PostgreSQL function, `public.authorize`, is designed to implement Role-Based Access Control (RBAC) within Row Level Security (RLS) policies. It retrieves the `user_role` from the user's JWT, then checks if that role has the `requested_permission` by querying the `public.role_permissions` table, returning `true` if authorized.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  -- Fetch user role once and store it to reduce number of calls
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;

  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';
```

----------------------------------------

TITLE: Deno Edge Function for Authenticated OpenAI Realtime API Relay
DESCRIPTION: This Deno Edge Function sets up an authenticated WebSocket relay to OpenAI's Realtime API. It handles WebSocket upgrade requests, authenticates users via Supabase Auth using a JWT passed in URL query parameters, and then proxies messages between the client and OpenAI's WebSocket, ensuring the OpenAI API key remains secure on the server-side. It also includes error handling for authentication failures and connection issues.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-12-03-edge-functions-background-tasks-websockets.mdx#_snippet_2

LANGUAGE: jsx
CODE:
```
import { createClient } from 'jsr:@supabase/supabase-js@2'

const supabase = createClient(
  Deno.env.get('SUPABASE_URL'),
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
)
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY')

Deno.serve(async (req) => {
  const upgrade = req.headers.get('upgrade') || ''

  if (upgrade.toLowerCase() != 'websocket') {
    return new Response("request isn't trying to upgrade to websocket.")
  }

  // WebSocket browser clients does not support sending custom headers.
  // We have to use the URL query params to provide user's JWT.
  // Please be aware query params may be logged in some logging systems.
  const url = new URL(req.url)
  const jwt = url.searchParams.get('jwt')
  if (!jwt) {
    console.error('Auth token not provided')
    return new Response('Auth token not provided', { status: 403 })
  }
  const { error, data } = await supabase.auth.getUser(jwt)
  if (error) {
    console.error(error)
    return new Response('Invalid token provided', { status: 403 })
  }
  if (!data.user) {
    console.error('user is not authenticated')
    return new Response('User is not authenticated', { status: 403 })
  }

  const { socket, response } = Deno.upgradeWebSocket(req)

  socket.onopen = () => {
    // initiate an outbound WebSocket connection to OpenAI
    const url = 'wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01'

    // openai-insecure-api-key isn't a problem since this code runs in an Edge Function
    const openaiWS = new WebSocket(url, [
      'realtime',
      `openai-insecure-api-key.${OPENAI_API_KEY}`,
      'openai-beta.realtime-v1'
    ])

    openaiWS.onopen = () => {
      console.log('Connected to OpenAI server.')

      socket.onmessage = (e) => {
        console.log('socket message:', e.data)
        // only send the message if openAI ws is open
        if (openaiWS.readyState === 1) {
          openaiWS.send(e.data)
        } else {
          socket.send(
            JSON.stringify({
              type: 'error',
              msg: 'openAI connection not ready'
            })
          )
        }
      }
    }

    openaiWS.onmessage = (e) => {
      console.log(e.data)
      socket.send(e.data)
    }

    openaiWS.onerror = (e) => console.log('OpenAI error: ', e.message)
    openaiWS.onclose = (e) => console.log('OpenAI session closed')
  }

  socket.onerror = (e) => console.log('socket errored:', e.message)
  socket.onclose = () => console.log('socket closed')

  return response // 101 (Switching Protocols)
})
```

----------------------------------------

TITLE: Supabase Postgres RLS for Profiles and Storage
DESCRIPTION: This SQL snippet defines a `profiles` table with Row Level Security (RLS) policies for public viewing, user-specific inserts and updates. It also includes a PL/pgSQL trigger function (`handle_new_user`) to automatically create a profile entry when a new user signs up via Supabase Auth. Additionally, it sets up an `avatars` storage bucket with RLS policies for public access, and user-specific uploads and updates.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/nextjs-user-management/README.md#_snippet_3

LANGUAGE: sql
CODE:
```
-- Create a table for public profiles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,

  constraint username_length check (char_length(username) >= 3)
);
-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/auth/row-level-security for more details.
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles
  for update using ((select auth.uid()) = id);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

create policy "Anyone can update their own avatar." on storage.objects
  for update using ( auth.uid() = owner ) with check (bucket_id = 'avatars');
```

----------------------------------------

TITLE: Implement Supabase Email OTP Confirmation Endpoint Across Frameworks
DESCRIPTION: This collection of code snippets demonstrates how to create an API endpoint (`/auth/confirm`) to handle email OTP (One-Time Password) verification using Supabase across various JavaScript frameworks like Next.js, SvelteKit, Astro, and Remix. Each example extracts `token_hash` and `type` from the URL, uses `supabase.auth.verifyOtp` to confirm the user's email, and redirects based on the verification outcome. The implementations vary slightly based on the framework's server-side request and response handling, as well as Supabase client initialization.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/passwords.mdx#_snippet_9

LANGUAGE: TypeScript
CODE:
```
import { type EmailOtpType } from '@supabase/supabase-js'
import { cookies } from 'next/headers'
import { NextRequest, NextResponse } from 'next/server'
// The client you created from the Server-Side Auth instructions
import { createClient } from '@/utils/supabase/server'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type') as EmailOtpType | null
  const next = searchParams.get('next') ?? '/'
  const redirectTo = request.nextUrl.clone()
  redirectTo.pathname = next

  if (token_hash && type) {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })
    if (!error) {
      return NextResponse.redirect(redirectTo)
    }
  }

  // return the user to an error page with some instructions
  redirectTo.pathname = '/auth/auth-code-error'
  return NextResponse.redirect(redirectTo)
}
```

LANGUAGE: TypeScript
CODE:
```
import { redirect } from '@sveltejs/kit'
import { type EmailOtpType } from '@supabase/supabase-js'

export const GET = async (event) => {
  const {
    url,
    locals: { supabase },
  } = event
  const token_hash = url.searchParams.get('token_hash') as string
  const type = url.searchParams.get('type') as EmailOtpType | null
  const next = url.searchParams.get('next') ?? '/'

  /**
   * Clean up the redirect URL by deleting the Auth flow parameters.
   *
   * `next` is preserved for now, because it's needed in the error case.
   */
  const redirectTo = new URL(url)
  redirectTo.pathname = next
  redirectTo.searchParams.delete('token_hash')
  redirectTo.searchParams.delete('type')

  if (token_hash && type) {
    const { error } = await supabase.auth.verifyOtp({ token_hash, type })
    if (!error) {
      redirectTo.searchParams.delete('next')
      redirect(303, redirectTo)
    }
  }

  // return the user to an error page with some instructions
  redirectTo.pathname = '/auth/error'
  redirect(303, redirectTo)
}
```

LANGUAGE: TypeScript
CODE:
```
import { createServerClient, parseCookieHeader } from '@supabase/ssr'
import { type EmailOtpType } from '@supabase/supabase-js'
import { type APIRoute } from 'astro'

export const GET: APIRoute = async ({ request, cookies, redirect }) => {
  const requestUrl = new URL(request.url)
  const token_hash = requestUrl.searchParams.get('token_hash')
  const type = requestUrl.searchParams.get('type') as EmailOtpType | null
  const next = requestUrl.searchParams.get('next') || '/'

  if (token_hash && type) {
    const supabase = createServerClient(
      import.meta.env.PUBLIC_SUPABASE_URL,
      import.meta.env.PUBLIC_SUPABASE_ANON_KEY,
      {
        cookies: {
          getAll() {
            return parseCookieHeader(request.headers.get('Cookie') ?? '')
          },
          setAll(cookiesToSet) {
            cookiesToSet.forEach(({ name, value, options }) => cookies.set(name, value, options))
          },
        },
      }
    )

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })

    if (!error) {
      return redirect(next)
    }
  }

  // return the user to an error page with some instructions
  return redirect('/auth/auth-code-error')
}
```

LANGUAGE: TypeScript
CODE:
```
import { redirect, type LoaderFunctionArgs } from '@remix-run/node'
import { createServerClient, parseCookieHeader, serializeCookieHeader } from '@supabase/ssr'
import { type EmailOtpType } from '@supabase/supabase-js'

export async function loader({ request }: LoaderFunctionArgs) {
  const requestUrl = new URL(request.url)
  const token_hash = requestUrl.searchParams.get('token_hash')
  const type = requestUrl.searchParams.get('type') as EmailOtpType | null
  const next = requestUrl.searchParams.get('next') || '/'
  const headers = new Headers()

  if (token_hash && type) {
    const supabase = createServerClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!, {
      cookies: {
        getAll() {
          return parseCookieHeader(request.headers.get('Cookie') ?? '')
        }
```

----------------------------------------

TITLE: Supabase CLI: Manage Database Migration Scripts
DESCRIPTION: Provides documentation for the `supabase migration` command, designed to manage version-controlled SQL database migration files. It includes subcommands for listing local and remote migrations, creating new scripts, repairing migration history, squashing multiple migrations into one file, and applying pending migrations to the local database.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-08-supabase-local-dev.mdx#_snippet_2

LANGUAGE: APIDOC
CODE:
```
supabase migration
Manage database migration scripts

Usage:
  supabase migration [command]

Available Commands:
  list        List local and remote migrations
  new         Create an empty migration script
  repair      Repair the migration history table
  squash      Squash migrations to a single file
  up          Apply pending migrations to local database
```

----------------------------------------

TITLE: Start Supabase Locally
DESCRIPTION: This command initializes and starts your local Supabase services. Upon execution, all migration files located in `supabase/migrations` will be applied to your local database, preparing it for development.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/nextjs-vector-search.mdx#_snippet_6

LANGUAGE: bash
CODE:
```
supabase start
```

----------------------------------------

TITLE: Create Indexes for WHERE Clause Conditions
DESCRIPTION: These SQL commands create B-tree indexes on the 'sign_up_date' column in the 'customers' table and the 'status' column in the 'orders' table. Indexing these columns can significantly speed up queries that filter data based on these conditions, especially if the columns have diverse values or are frequently used in WHERE clauses.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/query-optimization.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
create index idx_customers_sign_up_date on customers (sign_up_date);

create index idx_orders_status on orders (status);
```

----------------------------------------

TITLE: Implement Supabase Service for Ionic Angular App
DESCRIPTION: This comprehensive TypeScript service, `SupabaseService`, encapsulates all interactions with the Supabase API within an Ionic Angular application. It initializes the Supabase client, defines an interface for user profiles, and provides methods for user authentication (sign-in, sign-out, auth changes), profile management (fetching, updating), and avatar storage operations (download, upload). It also includes utility methods for displaying toasts and loading indicators.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-ionic-angular.mdx#_snippet_2

LANGUAGE: typescript
CODE:
```
import { Injectable } from '@angular/core'
import { LoadingController, ToastController } from '@ionic/angular'
import { AuthChangeEvent, createClient, Session, SupabaseClient } from '@supabase/supabase-js'
import { environment } from '../environments/environment'

export interface Profile {
  username: string
  website: string
  avatar_url: string
}

@Injectable({
  providedIn: 'root',
})
export class SupabaseService {
  private supabase: SupabaseClient

  constructor(
    private loadingCtrl: LoadingController,
    private toastCtrl: ToastController
  ) {
    this.supabase = createClient(environment.supabaseUrl, environment.supabaseKey)
  }

  get user() {
    return this.supabase.auth.getUser().then(({ data }) => data?.user)
  }

  get session() {
    return this.supabase.auth.getSession().then(({ data }) => data?.session)
  }

  get profile() {
    return this.user
      .then((user) => user?.id)
      .then((id) =>
        this.supabase.from('profiles').select(`username, website, avatar_url`).eq('id', id).single()
      )
  }

  authChanges(callback: (event: AuthChangeEvent, session: Session | null) => void) {
    return this.supabase.auth.onAuthStateChange(callback)
  }

  signIn(email: string) {
    return this.supabase.auth.signInWithOtp({ email })
  }

  signOut() {
    return this.supabase.auth.signOut()
  }

  async updateProfile(profile: Profile) {
    const user = await this.user
    const update = {
      ...profile,
      id: user?.id,
      updated_at: new Date(),
    }

    return this.supabase.from('profiles').upsert(update)
  }

  downLoadImage(path: string) {
    return this.supabase.storage.from('avatars').download(path)
  }

  uploadAvatar(filePath: string, file: File) {
    return this.supabase.storage.from('avatars').upload(filePath, file)
  }

  async createNotice(message: string) {
    const toast = await this.toastCtrl.create({ message, duration: 5000 })
    await toast.present()
  }

  createLoader() {
    return this.loadingCtrl.create()
  }
}
```

----------------------------------------

TITLE: Improve Supabase RLS Performance by Specifying Roles
DESCRIPTION: This section highlights the importance of explicitly defining roles in Supabase Row Level Security (RLS) policies, particularly using the 'TO' option. Rather than relying solely on auth.uid() or auth.jwt() to implicitly exclude anonymous users, it is recommended to add 'authenticated' to the approved roles. This practice efficiently prevents 'anon' users from taxing the database with unnecessary RLS processing, thereby improving overall system performance for unauthenticated access attempts.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-performance-and-best-practices-Z5Jjwv.mdx#_snippet_5

LANGUAGE: SQL
CODE:
```
-- Inefficient RLS policy (implicitly allows 'anon' access)
-- Example: CREATE POLICY select_policy ON your_table FOR SELECT USING (auth.uid() = user_id);
```

LANGUAGE: SQL
CODE:
```
-- Efficient RLS policy (explicitly restricts to authenticated users)
-- Example: CREATE POLICY select_policy ON your_table FOR SELECT TO authenticated USING (auth.uid() = user_id);
```

LANGUAGE: SQL
CODE:
```
TO authenticated
```

----------------------------------------

TITLE: Create AccountForm Component for User Profile Management (JavaScript)
DESCRIPTION: This React component allows authenticated users to view and update their profile details such as full name, username, website, and avatar URL. It fetches initial profile data on mount using Supabase and provides a function to update the profile. It also includes a sign-out button.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-nextjs.mdx#_snippet_11

LANGUAGE: jsx
CODE:
```
'use client'\nimport { useCallback, useEffect, useState } from 'react'\nimport { createClient } from '@/utils/supabase/client'\n\nexport default function AccountForm({ user }) {\n  const supabase = createClient()\n  const [loading, setLoading] = useState(true)\n  const [fullname, setFullname] = useState(null)\n  const [username, setUsername] = useState(null)\n  const [website, setWebsite] = useState(null)\n  const [avatar_url, setAvatarUrl] = useState(null)\n\n  const getProfile = useCallback(async () => {\n    try {\n      setLoading(true)\n\n      const { data, error, status } = await supabase\n        .from('profiles')\n        .select(`full_name, username, website, avatar_url`)\n        .eq('id', user?.id)\n        .single()\n\n      if (error && status !== 406) {\n        throw error\n      }\n\n      if (data) {\n        setFullname(data.full_name)\n        setUsername(data.username)\n        setWebsite(data.website)\n        setAvatarUrl(data.avatar_url)\n      }\n    } catch (error) {\n      alert('Error loading user data!')\n    } finally {\n      setLoading(false)\n    }\n  }, [user, supabase])\n\n  useEffect(() => {\n    getProfile()\n  }, [user, getProfile])\n\n  async function updateProfile({ username, website, avatar_url }) {\n    try {\n      setLoading(true)\n\n      const { error } = await supabase.from('profiles').upsert({\n        id: user?.id,\n        full_name: fullname,\n        username,\n        website,\n        avatar_url,\n        updated_at: new Date().toISOString(),\n      })\n      if (error) throw error\n      alert('Profile updated!')\n    } catch (error) {\n      alert('Error updating the data!')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    <div className="form-widget">\n      <div>\n        <label htmlFor="email">Email</label>\n        <input id="email" type="text" value={user?.email} disabled />\n      </div>\n      <div>\n        <label htmlFor="fullName">Full Name</label>\n        <input\n          id="fullName"\n          type="text"\n          value={fullname || ''}\n          onChange={(e) => setFullname(e.target.value)}\n        />\n      </div>\n      <div>\n        <label htmlFor="username">Username</label>\n        <input\n          id="username"\n          type="text"\n          value={username || ''}\n          onChange={(e) => setUsername(e.target.value)}\n        />\n      </div>\n      <div>\n        <label htmlFor="website">Website</label>\n        <input\n          id="website"\n          type="url"\n          value={website || ''}\n          onChange={(e) => setWebsite(e.target.value)}\n        />\n      </div>\n\n      <div>\n        <button\n          className="button primary block"\n          onClick={() => updateProfile({ fullname, username, website, avatar_url })}\n          disabled={loading}\n        >\n          {loading ? 'Loading ...' : 'Update'}\n        </button>\n      </div>\n\n      <div>\n        <form action="/auth/signout" method="post">\n          <button className="button block" type="submit">\n            Sign out\n          </button>\n        </form>\n      </div>\n    </div>\n  )\n}
```

----------------------------------------

TITLE: Create HNSW Index for Vector Embeddings in Postgres
DESCRIPTION: This SQL command creates an approximate nearest neighbor (ANN) index using HNSW on the `embedding` column of the `documents` table. This index, configured with `vector_ip_ops` for inner product distance, significantly speeds up similarity searches. The `lists = 10` parameter is a recommended starting point for tables with fewer than 1 million records.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/building-chatgpt-plugins.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
create index on documents
using hnsw (embedding vector_ip_ops)
with (lists = 10);
```

----------------------------------------

TITLE: Supabase Postgres Row Level Security and Realtime Setup
DESCRIPTION: SQL commands to create a `profiles` table linked to `auth.users`, define row-level security policies for public viewing, user-specific inserts and updates, and configure Realtime and Storage buckets for avatar management.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/angular-user-management/README.md#_snippet_6

LANGUAGE: sql
CODE:
```
-- Create a table for Public Profiles
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,
  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);
alter table profiles enable row level security;
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );
create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );
create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );
-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;
-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');
create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );
create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Initialize Supabase browser and server clients with type safety
DESCRIPTION: Illustrates the new methods for initializing Supabase clients, `createPagesBrowserClient` for client-side and `createPagesServerClient` for server-side API routes. These methods replace the direct `supabaseClient` and `supabaseServerClient` objects and allow for passing CLI-generated types for enhanced type safety and auto-completion.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_19

LANGUAGE: tsx
CODE:
```
// client-side
import type { Database } from 'types_db'
const [supabaseClient] = useState(() => createPagesBrowserClient<Database>())

// server-side API route
import type { NextApiRequest, NextApiResponse } from 'next'
import type { Database } from 'types_db'

export default async (req: NextApiRequest, res: NextApiResponse) => {
  const supabaseServerClient = createPagesServerClient<Database>({
    req,
    res,
  })
  const {
    data: { user },
  } = await supabaseServerClient.auth.getUser()

  res.status(200).json({ name: user?.name ?? '' })
}
```

----------------------------------------

TITLE: Authenticated-Only Page with getServerSideProps in Next.js
DESCRIPTION: Demonstrates how to create a page accessible only to authenticated users using `getServerSideProps` in Next.js. It fetches user data from Supabase and redirects unauthenticated users to the home page. Emphasizes using `supabase.auth.getUser()` for secure page protection, as `getSession()` is not guaranteed to revalidate the Auth token on the server.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/nextjs.mdx#_snippet_18

LANGUAGE: tsx
CODE:
```
import type { User } from '@supabase/supabase-js'
import type { GetServerSidePropsContext } from 'next'

import { createClient } from '@/utils/supabase/server-props'

export default function PrivatePage({ user }: { user: User }) {
  return <h1>Hello, {user.email || 'user'}!</h1>
}

export async function getServerSideProps(context: GetServerSidePropsContext) {
  const supabase = createClient(context)

  const { data, error } = await supabase.auth.getUser()

  if (error || !data) {
    return {
      redirect: {
        destination: '/',
        permanent: false,
      },
    }
  }

  return {
    props: {
      user: data.user,
    },
  }
}
```

----------------------------------------

TITLE: Implement Supabase OAuth and Magic Link Handlers in React Native
DESCRIPTION: This TypeScript/React Native code provides a comprehensive example of handling Supabase authentication flows, including OAuth redirects and magic links. It utilizes Expo modules like `expo-auth-session` and `expo-linking` to manage browser sessions and deep links, allowing users to sign in with OAuth providers (e.g., GitHub) or via email magic links. The `createSessionFromUrl` function processes the redirect URL to establish a user session.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-11-16-react-native-authentication.mdx#_snippet_7

LANGUAGE: tsx
CODE:
```
import { Button } from 'react-native'
import { makeRedirectUri } from 'expo-auth-session'
import * as QueryParams from 'expo-auth-session/build/QueryParams'
import * as WebBrowser from 'expo-web-browser'
import * as Linking from 'expo-linking'
import { supabase } from 'app/utils/supabase'

WebBrowser.maybeCompleteAuthSession() // required for web only
const redirectTo = makeRedirectUri()

const createSessionFromUrl = async (url: string) => {
  const { params, errorCode } = QueryParams.getQueryParams(url)

  if (errorCode) throw new Error(errorCode)
  const { access_token, refresh_token } = params

  if (!access_token) return

  const { data, error } = await supabase.auth.setSession({
    access_token,
    refresh_token,
  })
  if (error) throw error
  return data.session
}

const performOAuth = async () => {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'github',
    options: {
      redirectTo,
      skipBrowserRedirect: true,
    },
  })
  if (error) throw error

  const res = await WebBrowser.openAuthSessionAsync(data?.url ?? '', redirectTo)

  if (res.type === 'success') {
    const { url } = res
    await createSessionFromUrl(url)
  }
}

const sendMagicLink = async () => {
  const { error } = await supabase.auth.signInWithOtp({
    email: 'example@email.com',
    options: {
      emailRedirectTo: redirectTo,
    },
  })

  if (error) throw error
  // Email sent.
}

export default function Auth() {
  // Handle linking into app from email app.
  const url = Linking.useURL()
  if (url) createSessionFromUrl(url)

  return (
    <>
      <Button onPress={performOAuth} title="Sign in with Github" />
      <Button onPress={sendMagicLink} title="Send Magic Link" />
    </>
  )
}
```

----------------------------------------

TITLE: Sign Out from Supabase Session
DESCRIPTION: Illustrates how to sign out a user from their current Supabase session using the `signOut` method. This action removes the user from the browser session and clears any related data from local storage.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-linkedin.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('<your-project-url>', '<your-anon-key>')

// ---cut---
async function signOut() {
  const { error } = await supabase.auth.signOut()
}
```

LANGUAGE: Flutter
CODE:
```
Future<void> signOut() async {
  await supabase.auth.signOut();
}
```

LANGUAGE: Kotlin
CODE:
```
suspend fun signOut() {
	supabase.auth.signOut()
}
```

----------------------------------------

TITLE: Creating User Roles and Permissions Tables in SQL
DESCRIPTION: This SQL script defines custom types for application roles (`app_role`) and permissions (`app_permission`), then creates two tables: `user_roles` to assign roles to users, and `role_permissions` to map specific permissions to each role. This setup forms the foundation for implementing role-based access control within the application.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- Custom types
create type public.app_permission as enum ('channels.delete', 'messages.delete');
create type public.app_role as enum ('admin', 'moderator');

-- USER ROLES
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);
comment on table public.user_roles is 'Application roles for each user.';

-- ROLE PERMISSIONS
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';
```

----------------------------------------

TITLE: Query one-to-many joined tables using Supabase Data APIs
DESCRIPTION: This snippet demonstrates how to fetch data from `orchestral_sections` and its related `instruments` using Supabase's automatic foreign key detection. Examples are provided for various client libraries and direct API access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/joins-and-nesting.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
const { data, error } = await supabase.from('orchestral_sections').select(`
  id,
  name,
  instruments ( id, name )
`)
```

LANGUAGE: Dart
CODE:
```
final data = await supabase.from('orchestral_sections').select('id, name, instruments(id, name)');
```

LANGUAGE: Swift
CODE:
```
struct OrchestralSection: Codable {
  let id: Int
  let name: String
  let instruments: [Instrument]

  struct Instrument: Codable {
    let id: Int
    let name: String
  }
}

let orchestralSections: [OrchestralSection] = try await supabase
  .from("orchestral_sections")
  .select("id, name, instruments(id, name)")
  .execute()
  .value
```

LANGUAGE: Kotlin
CODE:
```
val data = supabase.from("orchestral_sections").select(Columns.raw("id, name, instruments(id, name)"))
```

LANGUAGE: Python
CODE:
```
data = supabase.from_('orchestral_sections').select('id, name, instruments(id, name)').execute()
```

LANGUAGE: GraphQL
CODE:
```
const Query = `
  query {
    orchestral_sectionsCollection {
      edges {
        node {
          id
          name
          instruments {
            id,
            name
          }
        }
      }
    }
  }
`
```

LANGUAGE: URL
CODE:
```
GET https://[REF].supabase.co/rest/v1/orchestral_sections?select=id,name,instruments(id,name)
```

----------------------------------------

TITLE: Streaming Row Updates with Supabase Realtime (JavaScript)
DESCRIPTION: This snippet illustrates how to configure a Supabase Realtime channel to monitor `UPDATE` events on the `public` schema. It logs the payload of each updated row, providing real-time notifications for data modifications. Requires a Supabase client initialized with your project URL and API key.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/subscribing-to-database-changes.mdx#_snippet_6

LANGUAGE: JavaScript
CODE:
```
// @noImplicitAny: false
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('your_project_url', 'your_supabase_api_key')

// ---cut---
const channel = supabase
  .channel('schema-db-changes')
  .on(
    'postgres_changes',
    {
      event: 'UPDATE',
      schema: 'public'
    },
    (payload) => console.log(payload)
  )
  .subscribe()
```

----------------------------------------

TITLE: Fetch Teams with Associated Users (Many-to-Many Join)
DESCRIPTION: Illustrates how to query the `teams` table and automatically include associated `users` data through the detected many-to-many relationship. This simplifies data fetching by allowing direct selection of related entities without explicit join table queries across various programming languages and API methods.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/joins-and-nesting.mdx#_snippet_4

LANGUAGE: javascript
CODE:
```
const { data, error } = await supabase.from('teams').select(`
  id,
  team_name,
  users ( id, name )
`)
```

LANGUAGE: dart
CODE:
```
final data = await supabase.from('teams').select('id, team_name, users(id, name)');
```

LANGUAGE: swift
CODE:
```
struct Team: Codable {
  let id: Int
  let name: String
  let users: [User]

  struct User: Codable {
    let id: Int
    let name: String
  }

  enum CodingKeys: String, CodingKey {
    case id, users
    case name = "team_name"
  }
}
let teams [Team] = try await supabase
  .from("teams")
  .select(
    """
      id,
      team_name,
      users ( id, name )
    """
  )
  .execute()
  .value
```

LANGUAGE: kotlin
CODE:
```
val data = supabase.from("teams").select(Columns.raw("id, team_name, users(id, name)"));
```

LANGUAGE: python
CODE:
```
data = supabase.from_('teams').select('id, team_name, users(id, name)').execute()
```

LANGUAGE: graphql
CODE:
```
const Query = `
  query {
    teamsCollection {
      edges {
        node {
          id
          team_name
          users {
            id,
            name
          }
        }
      }
    }
  }
`
```

LANGUAGE: bash
CODE:
```
GET https://[REF].supabase.co/rest/v1/teams?select=id,team_name,users(id,name)
```

----------------------------------------

TITLE: Supabase Profiles Table and Security Policies
DESCRIPTION: This SQL script defines the `profiles` table, which stores user profile information linked to `auth.users`. It includes columns for `id`, `updated_at`, `username`, `avatar_url`, and `website`. The script also establishes Row Level Security (RLS) policies for `profiles` to control read, insert, and update access, ensuring users can only manage their own profiles. Furthermore, it configures Supabase Realtime for the `profiles` table and sets up a `storage.buckets` entry for 'avatars' with RLS policies for public access and upload.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/vue3-user-management/README.md#_snippet_1

LANGUAGE: sql
CODE:
```
-- Create a table for public "profiles"
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );

create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Next.js Google One-Tap Authentication with Supabase
DESCRIPTION: This Next.js component demonstrates how to integrate Google One-Tap for user authentication with Supabase. It includes generating a nonce for security, initializing the Google Identity Services client, handling the `CredentialResponse` to sign in with an ID token via `supabase.auth.signInWithIdToken`, and managing user sessions and redirects.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-google.mdx#_snippet_9

LANGUAGE: tsx
CODE:
```
'use client'

import Script from 'next/script'
import { createClient } from '@/utils/supabase/client'
import { CredentialResponse } from 'google-one-tap'
import { useRouter } from 'next/navigation'
import { useEffect } from 'react'

const OneTapComponent = () => {
  const supabase = createClient()
  const router = useRouter()

  // generate nonce to use for google id token sign-in
  const generateNonce = async (): Promise<string[]> => {
    const nonce = btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(32))))
    const encoder = new TextEncoder()
    const encodedNonce = encoder.encode(nonce)
    const hashBuffer = await crypto.subtle.digest('SHA-256', encodedNonce)
    const hashArray = Array.from(new Uint8Array(hashBuffer))
    const hashedNonce = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')

    return [nonce, hashedNonce]
  }

  useEffect(() => {
    const initializeGoogleOneTap = () => {
      console.log('Initializing Google One Tap')
      window.addEventListener('load', async () => {
        const [nonce, hashedNonce] = await generateNonce()
        console.log('Nonce: ', nonce, hashedNonce)

        // check if there's already an existing session before initializing the one-tap UI
        const { data, error } = await supabase.auth.getSession()
        if (error) {
          console.error('Error getting session', error)
        }
        if (data.session) {
          router.push('/')
          return
        }

        /* global google */
        google.accounts.id.initialize({
          client_id: process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID,
          callback: async (response: CredentialResponse) => {
            try {
              // send id token returned in response.credential to supabase
              const { data, error } = await supabase.auth.signInWithIdToken({
                provider: 'google',
                token: response.credential,
                nonce,
              })

              if (error) throw error
              console.log('Session data: ', data)
              console.log('Successfully logged in with Google One Tap')

              // redirect to protected page
              router.push('/')
            } catch (error) {
              console.error('Error logging in with Google One Tap', error)
            }
          },
          nonce: hashedNonce,
          // with chrome's removal of third-party cookies, we need to use FedCM instead (https://developers.google.com/identity/gsi/web/guides/fedcm-migration)
          use_fedcm_for_prompt: true,
        })
        google.accounts.id.prompt() // Display the One Tap UI
      })
    }
    initializeGoogleOneTap()
    return () => window.removeEventListener('load', initializeGoogleOneTap)
  }, [])

  return (
    <>
      <Script src="https://accounts.google.com/gsi/client" />
      <div id="oneTap" className="fixed top-0 right-0 z-[100]" />
    </>
  )
}

export default OneTapComponent
```

----------------------------------------

TITLE: Create Postgres Function and Trigger for New User Signup
DESCRIPTION: This SQL snippet defines a Postgres function `handle_new_user` that inserts a new row into the `public.profiles` table upon a new user signup in `auth.users`. It also copies the username from the user's metadata. A trigger `on_auth_user_created` is then created to automatically execute this function after an insert operation on the `auth.users` table. This ensures that every new authenticated user has a corresponding profile entry.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-06-30-flutter-tutorial-building-a-chat-app.mdx#_snippet_11

LANGUAGE: SQL
CODE:
```
-- Function to create a new row in profiles table upon signup
-- Also copies the username value from metadata
create or replace function handle_new_user() returns trigger as $$
    begin
        insert into public.profiles(id, username)
        values(new.id, new.raw_user_meta_data->>'username');

        return new;
    end;
$$ language plpgsql security definer;

-- Trigger to call `handle_new_user` when new user signs up
create trigger on_auth_user_created
    after insert on auth.users
    for each row
    execute function handle_new_user();
```

----------------------------------------

TITLE: Query Data with Direct Postgres RLS Enforcement
DESCRIPTION: Executes a `SELECT` query on `document_sections`. With RLS enabled and the `app.current_user_id` session variable set, this query automatically returns only the document sections owned by the current user, demonstrating RLS in action for direct connections.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/rag-with-permissions.mdx#_snippet_11

LANGUAGE: SQL
CODE:
```
-- Only document sections owned by the user are returned
select *
from document_sections
where document_sections.embedding <#> embedding < -match_threshold
order by document_sections.embedding <#> embedding;
```

----------------------------------------

TITLE: Initialize Supabase Project Locally
DESCRIPTION: This command creates a new Supabase project in your current directory, setting up the necessary local development environment and project structure.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/edge-functions/supabase/functions/elevenlabs-text-to-speech/README.md#_snippet_0

LANGUAGE: bash
CODE:
```
supabase init
```

----------------------------------------

TITLE: Supabase Client Initialization Across JavaScript and Dart
DESCRIPTION: Demonstrates how to initialize the Supabase client in both JavaScript and Dart. These snippets are typically presented within a tabbed interface to allow users to select their preferred language.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/app/contributing/content.mdx#_snippet_14

LANGUAGE: js
CODE:
```
const supabase = createSupabaseClient()
```

LANGUAGE: dart
CODE:
```
void main() async {
  Supabase.initialize();
}
```

----------------------------------------

TITLE: Generate TypeScript Types for Supabase Schema using CLI
DESCRIPTION: This bash command sequence uses the Supabase CLI to log in, initialize, link to a project, and then generate TypeScript types from the 'public' schema, outputting them to 'utils/database.types.ts'. These types enable strong typing for data returned from Supabase queries.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-01-12-react-query-nextjs-app-router-cache-helpers.mdx#_snippet_4

LANGUAGE: bash
CODE:
```
supabase login
supabase init
supabase link
supabase gen types typescript --linked --schema=public > utils/database.types.ts
```

----------------------------------------

TITLE: Perform an image search from a text query using Supabase Vector
DESCRIPTION: This Python function `search` demonstrates how to perform an image search from a text query using Supabase Vector. It initializes a vector store client, generates an embedding from the input text using the Amazon Titan multimodal model, and then queries a collection named 'image_vectors'. The query is limited to one result and filtered to include only 'jpg' images. Finally, it displays the most relevant image using `matplotlib`. The function can be invoked with an optional `query_term` or by passing it as a command-line argument.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/semantic-image-search-amazon-titan.mdx#_snippet_9

LANGUAGE: Python
CODE:
```
def search(query_term: Optional[str] = None):
    if query_term is None:
        query_term = sys.argv[1]

    # create vector store client
    vx = vecs.create_client(DB_CONNECTION)
    images = vx.get_or_create_collection(name="image_vectors", dimension=1024)

    # Encode text query
    text_emb = get_embedding_from_titan_multimodal(json.dumps(
        {
            "inputText": query_term,
            "embeddingConfig": {"outputEmbeddingLength": 1024},
        }
    ))

    # query the collection filtering metadata for "type" = "jpg"
    results = images.query(
        data=text_emb,                      # required
        limit=1,                            # number of records to return
        filters={"type": {"$eq": "jpg"}},   # metadata filters
    )
    result = results[0]
    print(result)
    plt.title(result)
    image = mpimg.imread('./images/' + result)
    plt.imshow(image)
    plt.show()
```

----------------------------------------

TITLE: Compare Supabase Client Latency with Direct Psycopg Postgres Query in Python
DESCRIPTION: A Python script designed to compare the query execution time between a direct PostgreSQL connection using `psycopg` and the Supabase Python client. It defines functions for both methods, measures the time taken to fetch all rows from 'your_table_name', and prints the elapsed time for each, along with their ratio. Requires `psycopg[binary]` and the Supabase client library.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/high-latency-with-supabase-client-z0pZzR.mdx#_snippet_1

LANGUAGE: Python
CODE:
```
import time
from supabase import Client, create_client

import psycopg


def psycop_call(): #user_ids: list[str]):
    user="YOUR_SUPABASE_USER"
    password="YOUR_SUPABASE_PASSWORD"
    host="SUPABASE_HOST"
    port=5432
    database="postgres"

    with psycopg.connect(f"host={host} port={port} dbname={database} user={user} password={password}") as conn:
        # Open a cursor to perform database operations
        results = []
        with conn.cursor() as cur:
            start = time.time()
            # Execute a command: this creates a new table
            cur.execute("SELECT * FROM public.your_table_name")
            cur.fetchall()
            for record in cur:
                results.append(record)
            stop = time.time()
            return (stop - start)


def supabase_call():
    supabase: Client = create_client("SUPABASE_URL", "SUPBASE_SERVICE_ROLE_KEY")
    start = time.time()
    result = supabase.table("your_table_name").select("*").execute()
    stop = time.time()
    return (stop - start)


if __name__ == "__main__":
    ref = psycop_call()
    sup = supabase_call()
    print(f"postgres: {ref}, supabase: {sup}, ratio: {sup/ref}")
```

----------------------------------------

TITLE: Implementing Custom Access Token Auth Hook in PL/pgSQL
DESCRIPTION: This PL/pgSQL function, `custom_access_token_hook`, is designed to run as a Supabase Auth Hook before a JWT is issued. It fetches the user's role from the `user_roles` table and injects it as a `user_role` custom claim into the JWT, enabling role-based access control. The script also includes necessary `GRANT` and `REVOKE` statements to manage permissions for the function and the `user_roles` table, ensuring secure execution within the Supabase environment.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_3

LANGUAGE: plpgsql
CODE:
```
-- Create the auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$$;

grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)
```

----------------------------------------

TITLE: Query Postgres for Similar Sentences using Bedrock Embeddings
DESCRIPTION: This Python snippet demonstrates how to perform a similarity search. It first generates an embedding for a query sentence using the Amazon Titan model, then queries the 'sentences' collection in Postgres via `vecs` to find the most similar sentences based on their vector distance, and prints the results.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/integrations/amazon-bedrock.mdx#_snippet_3

LANGUAGE: python
CODE:
```
query_sentence = "A quick animal jumps over a lazy one."

# create vector store client
vx = vecs.Client(DB_CONNECTION)

# create an embedding for the query sentence
response = client.invoke_model(
        body= json.dumps({"inputText": query_sentence}),
        modelId= "amazon.titan-embed-text-v1",
        accept = "application/json",
        contentType = "application/json"
    )

response_body = json.loads(response["body"].read())

query_embedding = response_body.get("embedding")

# query the 'sentences' collection for the most similar sentences
results = sentences.query(
    data=query_embedding,
    limit=3,
    include_value = True
)

# print the results
for result in results:
    print(result)
```

----------------------------------------

TITLE: Call Llamafile from Supabase Edge Function using OpenAI Deno SDK
DESCRIPTION: This TypeScript code defines a Supabase Edge Function that uses the OpenAI Deno SDK to interact with a Llamafile server. It handles incoming JSON requests with a 'prompt', streams responses, and sets appropriate headers for server-sent events. Note that the 'model' parameter in `client.chat.completions.create` has no effect, as the running Llamafile determines the model.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-21-mozilla-llamafile-in-supabase-edge-functions.mdx#_snippet_5

LANGUAGE: ts
CODE:
```
import OpenAI from 'https://deno.land/x/openai@v4.53.2/mod.ts'

Deno.serve(async (req) => {
  const client = new OpenAI()
  const { prompt } = await req.json()
  const stream = true

  const chatCompletion = await client.chat.completions.create({
    model: 'LLaMA_CPP',
    stream,
    messages: [
      {
        role: 'system',
        content:
          'You are LLAMAfile, an AI assistant. Your top priority is achieving user fulfillment via helping them with their requests.',
      },
      {
        role: 'user',
        content: prompt,
      },
    ],
  })

  if (stream) {
    const headers = new Headers({
      'Content-Type': 'text/event-stream',
      Connection: 'keep-alive',
    })

    // Create a stream
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder()

        try {
          for await (const part of chatCompletion) {
            controller.enqueue(encoder.encode(part.choices[0]?.delta?.content || ''))
          }
        } catch (err) {
          console.error('Stream error:', err)
        } finally {
          controller.close()
        }
      },
    })

    // Return the stream to the user
    return new Response(stream, {
      headers,
    })
  }

  return Response.json(chatCompletion)
})
```

----------------------------------------

TITLE: Set Supabase API Keys as Environment Variables
DESCRIPTION: Instructions to set the Supabase project URL, anonymous public key, and service role secret key as environment variables. This method is recommended for securely managing API credentials.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-06-15-loading-data-supabase-python.mdx#_snippet_1

LANGUAGE: Bash
CODE:
```
export SUPABASE_URL=<<the value under config > URL>>
export SUPABASE_KEY=<<the value present in Project API keys > anon public>>
export SUPABASE_SECRET_KEY=<<the value present in Project API keys > service_role secret>>
```

----------------------------------------

TITLE: Overview of Supabase Client Creation Methods in Next.js Auth Helpers
DESCRIPTION: This section outlines the five different methods for instantiating the Supabase client within various Next.js contexts using the Auth Helpers. It details which `createClient` function to use for Client Components, Server Components, Server Actions, Route Handlers, and Middleware, emphasizing context-specific client instantiation.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_9

LANGUAGE: APIDOC
CODE:
```
Supabase Client Creation Methods:
  - createClientComponentClient: For use in Client Components
  - createServerComponentClient: For use in Server Components
  - createServerActionClient: For use in Server Actions
  - createRouteHandlerClient: For use in Route Handlers
  - createMiddlewareClient: For use in Middleware
```

----------------------------------------

TITLE: Deprecated Supabase setAuth() method
DESCRIPTION: The `setAuth()` method has been deprecated and removed. To set a custom `access_token` JWT, the custom header should now be passed directly into the `createClient()` method instead.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/release-notes.mdx#_snippet_9

LANGUAGE: APIDOC
CODE:
```
Method: setAuth()
Status: Deprecated and Removed
Replacement: Pass custom `access_token` JWT as a custom header into the `createClient()` method.
```

----------------------------------------

TITLE: Initializing Supabase Client with Service Role Key (TypeScript)
DESCRIPTION: This snippet demonstrates how to create a Supabase client instance specifically for server-side operations using the `service_role` secret. It imports `createClient` from `@supabase/supabase-js` and configures the `auth` object to disable session persistence, auto-refresh, and URL session detection, which are crucial for secure server environments to prevent accidental exposure of the secret.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/performing-administration-tasks-on-the-server-side-with-the-servicerole-secret-BYM4Fa.mdx#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(supabaseUrl, serviceRoleSecret, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
    detectSessionInUrl: false,
  },
})
```

----------------------------------------

TITLE: Measure SQL Query Performance with EXPLAIN ANALYZE for RLS Testing
DESCRIPTION: Demonstrates how to set session roles and JWT claims to test Row Level Security (RLS) performance using EXPLAIN ANALYZE on a SELECT COUNT(*) query. This helps in comparing execution times under different RLS configurations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-performance-and-best-practices-Z5Jjwv.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
set session role authenticated;
set request.jwt.claims to '{"role":"authenticated", "sub":"5950b438-b07c-4012-8190-6ce79e4bd8e5"}';

explain analyze SELECT count(*) FROM rlstest;
set session role postgres;
```

----------------------------------------

TITLE: Automate Profile Creation on New User Signup
DESCRIPTION: Defines a PL/pgSQL function 'handle_new_user' that automatically inserts a new entry into the 'public.profiles' table when a user signs up via Supabase Auth. A trigger 'on_auth_user_created' is set up to execute this function after an insert on 'auth.users'.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/user_management_quickstart_sql_template.mdx#_snippet_2

LANGUAGE: PL/pgSQL
CODE:
```
-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
```

----------------------------------------

TITLE: Implement Client-side Supabase Authentication in Next.js
DESCRIPTION: This code demonstrates how to handle user authentication (sign-up, sign-in, sign-out) within a Next.js Client Component using `@supabase/auth-helpers-nextjs`. It sets up a basic form with email and password inputs, and uses `createClientComponentClient` to interact with Supabase Auth. The `router.refresh()` call is used to re-render the page after authentication actions.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_4

LANGUAGE: JavaScript
CODE:
```
'use client'

import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

export default function Login() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const router = useRouter()
  const supabase = createClientComponentClient()

  const handleSignUp = async () => {
    await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${location.origin}/auth/callback`,
      },
    })
    router.refresh()
  }

  const handleSignIn = async () => {
    await supabase.auth.signInWithPassword({
      email,
      password,
    })
    router.refresh()
  }

  const handleSignOut = async () => {
    await supabase.auth.signOut()
    router.refresh()
  }

  return (
    <>
      <input name="email" onChange={(e) => setEmail(e.target.value)} value={email} />
      <input
        type="password"
        name="password"
        onChange={(e) => setPassword(e.target.value)}
        value={password}
      />
      <button onClick={handleSignUp}>Sign up</button>
      <button onClick={handleSignIn}>Sign in</button>
      <button onClick={handleSignOut}>Sign out</button>
    </>
  )
}
```

LANGUAGE: TypeScript
CODE:
```
'use client'

import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'
import { useRouter } from 'next/navigation'
import { useState } from 'react'

import type { Database } from '@/lib/database.types'

export default function Login() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const router = useRouter()
  const supabase = createClientComponentClient<Database>()

  const handleSignUp = async () => {
    await supabase.auth.signUp({
      email,
      password,
      options: {
        emailRedirectTo: `${location.origin}/auth/callback`,
      },
    })
    router.refresh()
  }

  const handleSignIn = async () => {
    await supabase.auth.signInWithPassword({
      email,
      password,
    })
    router.refresh()
  }

  const handleSignOut = async () => {
    await supabase.auth.signOut()
    router.refresh()
  }

  return (
    <>
      <input name="email" onChange={(e) => setEmail(e.target.value)} value={email} />
      <input
        type="password"
        name="password"
        onChange={(e) => setPassword(e.target.value)}
        value={password}
      />
      <button onClick={handleSignUp}>Sign up</button>
      <button onClick={handleSignIn}>Sign in</button>
      <button onClick={handleSignOut}>Sign out</button>
    </>
  )
}
```

----------------------------------------

TITLE: Initialize Supabase Client in TypeScript/JavaScript
DESCRIPTION: Code snippet demonstrating how to import `createClient` from `@supabase/supabase-js` and initialize a Supabase client instance using a project URL and public anonymous key.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-07-16-supabase-js-on-jsr.mdx#_snippet_3

LANGUAGE: javascript
CODE:
```
import { createClient } from '@supabase/supabase-js'

const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')

console.log('Supabase Instance: ', supabase)
```

----------------------------------------

TITLE: Implement Supabase OAuth and Magic Link Handlers in Expo React Native
DESCRIPTION: This TypeScript/TSX code provides an `Auth` component for Expo React Native that demonstrates how to handle Supabase OAuth redirects (e.g., GitHub) and send magic links. It utilizes `expo-auth-session` for redirect management and `supabase-js` for authentication, ensuring proper session creation from deep link URLs.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/native-mobile-deep-linking.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
import { Button } from "react-native";
import { makeRedirectUri } from "expo-auth-session";
import * as QueryParams from "expo-auth-session/build/QueryParams";
import * as WebBrowser from "expo-web-browser";
import * as Linking from "expo-linking";
import { supabase } from "app/utils/supabase";

WebBrowser.maybeCompleteAuthSession(); // required for web only
const redirectTo = makeRedirectUri();

const createSessionFromUrl = async (url: string) => {
  const { params, errorCode } = QueryParams.getQueryParams(url);

  if (errorCode) throw new Error(errorCode);
  const { access_token, refresh_token } = params;

  if (!access_token) return;

  const { data, error } = await supabase.auth.setSession({
    access_token,
    refresh_token,
  });
  if (error) throw error;
  return data.session;
};

const performOAuth = async () => {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: "github",
    options: {
      redirectTo,
      skipBrowserRedirect: true,
    },
  });
  if (error) throw error;

  const res = await WebBrowser.openAuthSessionAsync(
    data?.url ?? "",
    redirectTo
  );

  if (res.type === "success") {
    const { url } = res;
    await createSessionFromUrl(url);
  }
};

const sendMagicLink = async () => {
  const { error } = await supabase.auth.signInWithOtp({
    email: "valid.email@supabase.io",
    options: {
      emailRedirectTo: redirectTo,
    },
  });

  if (error) throw error;
  // Email sent.
};

export default function Auth() {
  // Handle linking into app from email app.
  const url = Linking.useURL();
  if (url) createSessionFromUrl(url);

  return (
    <>
      <Button onPress={performOAuth} title="Sign in with Github" />
      <Button onPress={sendMagicLink} title="Send Magic Link" />
    </>
  );
}
```

----------------------------------------

TITLE: Initialize Supabase Client for Realtime Presence
DESCRIPTION: This snippet demonstrates how to initialize the Supabase client using your project's URL and anonymous public API key. This is the first step to interact with Supabase services, including Realtime Presence.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/presence.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'

const SUPABASE_URL = 'https://<project>.supabase.co'
const SUPABASE_KEY = '<your-anon-key>'

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)
```

LANGUAGE: Dart
CODE:
```
void main() {
  Supabase.initialize(
    url: 'https://<project>.supabase.co',
    anonKey: '<your-anon-key>',
  );

  runApp(MyApp());
}

final supabase = Supabase.instance.client;
```

LANGUAGE: Swift
CODE:
```
let supabaseURL = "https://<project>.supabase.co"
let supabaseKey = "<your-anon-key>"
let supabase = SupabaseClient(supabaseURL: URL(string: supabaseURL)!, supabaseKey: supabaseKey)

let realtime = supabase.realtime
```

LANGUAGE: Kotlin
CODE:
```
val supabaseUrl = "https://<project>.supabase.co"
val supabaseKey = "<your-anon-key>"
val supabase = createSupabaseClient(supabaseUrl, supabaseKey) {
    install(Realtime)
}
```

LANGUAGE: Python
CODE:
```
from supabase import create_client

SUPABASE_URL = 'https://<project>.supabase.co'
SUPABASE_KEY = '<your-anon-key>'

supabase = create_client(SUPABASE_URL, SUPABASE_KEY)
```

----------------------------------------

TITLE: JavaScript Search Interface for Supabase Edge Function
DESCRIPTION: This JavaScript snippet demonstrates how to build a client-side search interface that sends user queries to a Supabase Edge Function and streams the AI-generated answer back. It uses the EventSource API to handle server-sent events, allowing for real-time updates of the answer as it streams from OpenAI.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/headless-vector-search.mdx#_snippet_1

LANGUAGE: js
CODE:
```
const onSubmit = (e: Event) => {
  e.preventDefault()
  answer.value = ""
  isLoading.value = true

  const query = new URLSearchParams({ query: inputRef.current!.value })
  const projectUrl = `https://your-project-ref.supabase.co/functions/v1`
  const queryURL = `${projectURL}/${query}`
  const eventSource = new EventSource(queryURL)

  eventSource.addEventListener("error", (err) => {
    isLoading.value = false
    console.error(err)
  })

  eventSource.addEventListener("message", (e: MessageEvent) => {
    isLoading.value = false

    if (e.data === "[DONE]") {
      eventSource.close()
      return
    }

    const completionResponse: CreateCompletionResponse = JSON.parse(e.data)
    const text = completionResponse.choices[0].text

    answer.value += text
  });

  isLoading.value = true
}
```

----------------------------------------

TITLE: Implement Phone-Based Multi-Factor Authentication (MFA) with Supabase
DESCRIPTION: This snippet shows how to initiate an SMS or WhatsApp MFA challenge and then verify the code received by the user. Upon successful verification, the user's authentication assurance level (aal) claim in the JWT will be upgraded to aal2, indicating a higher level of security.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-14-third-party-auth-mfa-phone-send-hooks.mdx#_snippet_1

LANGUAGE: ts
CODE:
```
// Send an SMS or WhatsApp message to the user
const { data: { challengeId } } = await supabase.auth.mfa.challenge({
  factorId,
})

// To verify the code received by the user
await supabase.auth.mfa.verify({
  factorId,
  challengeId,
  code: '123456',
})

// The user's `aal` claim in the JWT 
// will be upgraded to aal2
```

----------------------------------------

TITLE: Perform Similarity Search using Supabase RPC (TypeScript)
DESCRIPTION: After generating the embedding for the question, this code performs a similarity search by calling a remote procedure (RPC) on the Supabase database. It uses the generated embedding to find relevant content sections based on a match threshold and count.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/nextjs-vector-search.mdx#_snippet_12

LANGUAGE: ts
CODE:
```
const { error: matchError, data: pageSections } = await supabaseClient.rpc(
  'match_page_sections',
  {
    embedding,
    match_threshold: 0.78,
    match_count: 10,
    min_content_length: 50,
  }
)
```

----------------------------------------

TITLE: Regranting Public Schema Access to API Roles
DESCRIPTION: This SQL script restores default object-level access in the `public` schema for `anon`, `authenticated`, and `service_role` API roles. It grants usage on the schema, all privileges on existing tables, routines, and sequences, and alters default privileges for future objects created by the `postgres` role to ensure full visibility.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/database-api-42501-errors.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
grant usage on schema public to anon, authenticated, service_role;
grant all on all tables in schema public to anon, authenticated, service_role;
grant all on all routines in schema public to anon, authenticated, service_role;
grant all ON all sequences in schema public to anon, authenticated, service_role;
alter default privileges for role postgres in schema public grant all on tables to anon, authenticated, service_role;
alter default privileges for role postgres in schema public grant all on routines to anon, authenticated, service_role;
alter default privileges for role postgres in schema public grant all on sequences to anon, authenticated, service_role;
```

----------------------------------------

TITLE: Global Authentication and Redirection with Expo Router Layout
DESCRIPTION: This TypeScript/React code defines the root layout for an Expo Router application. It uses `useEffect` to monitor authentication state (`session` and `initialized`) from a custom `AuthProvider`. Based on the user's session, it redirects authenticated users to `/list` and unauthenticated users to the root (`/`) login page, ensuring protected routes are only accessible to logged-in users. It wraps the entire application with `AuthProvider`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-01-react-native-storage.mdx#_snippet_6

LANGUAGE: tsx
CODE:
```
import { Slot, useRouter, useSegments } from 'expo-router'
import { useEffect } from 'react'
import { AuthProvider, useAuth } from '../provider/AuthProvider'

// Makes sure the user is authenticated before accessing protected pages
const InitialLayout = () => {
  const { session, initialized } = useAuth()
  const segments = useSegments()
  const router = useRouter()

  useEffect(() => {
    if (!initialized) return

    // Check if the path/url is in the (auth) group
    const inAuthGroup = segments[0] === '(auth)'

    if (session && !inAuthGroup) {
      // Redirect authenticated users to the list page
      router.replace('/list')
    } else if (!session) {
      // Redirect unauthenticated users to the login page
      router.replace('/')
    }
  }, [session, initialized])

  return <Slot />
}

// Wrap the app with the AuthProvider
const RootLayout = () => {
  return (
    <AuthProvider>
      <InitialLayout />
    </AuthProvider>
  )
}

export default RootLayout
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: Add the necessary Supabase URL and anonymous key to your project's .env file. These variables are essential for connecting your application to your Supabase project, whether hosted on supabase.com or running locally.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/ui-library/content/docs/tanstack/social-auth.mdx#_snippet_0

LANGUAGE: env
CODE:
```
VITE_SUPABASE_URL=
VITE_SUPABASE_ANON_KEY=
```

----------------------------------------

TITLE: Create Generic PL/pgSQL Trigger Function to Queue Embedding Jobs
DESCRIPTION: This PL/pgSQL function, `util.queue_embeddings`, is designed to be used as a trigger. It automatically sends a message to the 'embedding_jobs' queue whenever a row is inserted or updated in a table. The message includes the row's ID, schema, table name, a content function name, and the target embedding column, enabling flexible content extraction and storage.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/automatic-embeddings.mdx#_snippet_5

LANGUAGE: PL/pgSQL
CODE:
```
create or replace function util.queue_embeddings()
returns trigger
language plpgsql
security definer
set search_path = ''
as $$
declare
  content_function text = TG_ARGV[0];
  embedding_column text = TG_ARGV[1];
begin
  perform pgmq.send(
    queue_name => 'embedding_jobs',
    msg => jsonb_build_object(
      'id', NEW.id,
      'schema', TG_TABLE_SCHEMA,
      'table', TG_TABLE_NAME,
      'contentFunction', content_function,
      'embeddingColumn', embedding_column
    )
  );
  return NEW;
end;
$$;
```

----------------------------------------

TITLE: Improve RLS Performance with Indexing on RLS Columns
DESCRIPTION: Adding a B-tree index to columns used in RLS policies, especially those not already primary keys or unique, can drastically improve query performance on large tables. This example shows an RLS policy context and the corresponding index creation.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-performance-and-best-practices-Z5Jjwv.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
auth.uid() = user_id
```

LANGUAGE: sql
CODE:
```
create index userid on test_table using btree (user_id) tablespace pg_default;
```

----------------------------------------

TITLE: Correct Supabase SSR Authentication Middleware for Next.js
DESCRIPTION: This TypeScript code demonstrates the correct implementation of Supabase authentication middleware in a Next.js application. It utilizes `@supabase/ssr` to create a server client and manages cookies through `getAll` and `setAll` methods to ensure proper session state. The middleware includes logic for redirecting unauthenticated users and defines a matcher configuration to control which paths trigger the middleware.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/nextjs-supabase-auth.md#_snippet_4

LANGUAGE: typescript
CODE:
```
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
    let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        }
      }
    }
  )

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()

  const {
    data: {
      user
    }
  } = await supabase.auth.getUser()

  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'
  ]
}
```

----------------------------------------

TITLE: Query Supabase Vector Collection for Similar Documents
DESCRIPTION: This code performs a similarity search on the vector collection using a specified query vector. It allows filtering by metadata, setting a limit on results, and choosing a distance measure like cosine distance to retrieve the most similar documents.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/google-colab.mdx#_snippet_3

LANGUAGE: python
CODE:
```
collection.query(
    query_vector=[0.4,0.5,0.6],  # required
    limit=5,                     # number of records to return
    filters={},                  # metadata filters
    measure="cosine_distance",   # distance measure to use
    include_value=False,         # should distance measure values be returned?
    include_metadata=False       # should record metadata be returned?
)
```

----------------------------------------

TITLE: Sign In with Email and Password using Supabase
DESCRIPTION: This snippet demonstrates how to authenticate a user by calling the `signInWithPassword` (or equivalent) method with their email address and password. It shows examples across multiple programming languages for integrating with Supabase's authentication service.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/passwords.mdx#_snippet_6

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('https://your-project.supabase.co', 'your-anon-key')

async function signInWithEmail() {
  const { data, error } = await supabase.auth.signInWithPassword({
    email: 'valid.email@supabase.io',
    password: 'example-password',
  })
}
```

LANGUAGE: Dart
CODE:
```
Future<void> signInWithEmail() async {
  final AuthResponse res = await supabase.auth.signInWithPassword(
    email: 'valid.email@supabase.io',
    password: 'example-password'
  );
}
```

LANGUAGE: Swift
CODE:
```
try await supabase.auth.signIn(
  email: "valid.email@supabase.io",
  password: "example-password"
)
```

LANGUAGE: Kotlin
CODE:
```
suspend fun signInWithEmail() {
	supabase.auth.signInWith(Email) {
		email = "valid.email@supabase.io"
		password = "example-password"
	}
}
```

LANGUAGE: Python
CODE:
```
data = client.auth.sign_in_with_password({
  'email': 'valid.email@supabase.io',
  'password': 'example-password',
})
```

----------------------------------------

TITLE: Enforce MFA for All Users with Supabase Row Level Security Policy
DESCRIPTION: Provides a PostgreSQL Row Level Security (RLS) policy template to enforce Multi-Factor Authentication (MFA) for all users accessing a specific table. This policy restricts access to only those users whose JWT `aal` claim is `aal2` (highest assurance level), ensuring MFA completion. The `as restrictive` clause ensures this policy overrides others.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-mfa.mdx#_snippet_3

LANGUAGE: SQL
CODE:
```
create policy "Policy name."
  on table_name
  as restrictive
  to authenticated
  using ((select auth.jwt()->>'aal') = 'aal2');
```

----------------------------------------

TITLE: Querying Supabase with JavaScript Client
DESCRIPTION: Example using the official '@supabase/supabase-js' client to query an e-commerce schema, demonstrating how to select specific fields and embed relationships (e.g., products within orders) with auto-generated TypeScript types.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-05-17-simplify-backend-with-data-api.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
const { data, error } = await supabase
  .from('orders')
  .select(
    `
    id,
    created_at,
    total,
    products (
      id,
      name,
      price
    )
  `
  )
  .eq('customer_id', customerId)
```

----------------------------------------

TITLE: Convert SQL Select with Basic Clauses to JavaScript API
DESCRIPTION: Demonstrates how to translate a SQL SELECT statement with WHERE, ORDER BY, and LIMIT clauses into the Supabase JavaScript API, showing equivalent filtering, sorting, and pagination.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/sql-to-api.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
select first_name, last_name, team_id, age
from players
where age between 20 and 24 and team_id != 'STL'
order by last_name, first_name desc
limit 20;
```

LANGUAGE: js
CODE:
```
const { data, error } = await supabase
  .from('players')
  .select('first_name,last_name,team_id,age')
  .gte('age', 20)
  .lte('age', 24)
  .not('team_id', 'eq', 'STL')
  .order('last_name', { ascending: true }) // or just .order('last_name')
  .order('first_name', { ascending: false })
  .limit(20)
```

----------------------------------------

TITLE: Supabase Realtime: Subscribe to Postgres Database Changes
DESCRIPTION: This JavaScript example demonstrates how to subscribe to real-time changes in a Postgres database using Supabase. It shows filtering for specific events (e.g., INSERT) on a table within a schema and receiving the payload.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-18-supabase-realtime-multiplayer-general-availability.mdx#_snippet_2

LANGUAGE: javascript
CODE:
```
const channelId = '#random'

// Create a filter only for new messages
const databaseFilter = {
  schema: 'public',
  table: 'messages',
  filter: `room_id=eq.${channelId}`,
  event: 'INSERT',
}

const channel = supabase
  .channel(channelId)
  .on('postgres_changes', databaseFilter, (payload) => receivedDatabaseEvent(payload))
  .subscribe()

const receivedDatabaseEvent = (event) => {
  const { payload } = event
  console.log(payload)
}
```

----------------------------------------

TITLE: Complete Infinite Scroll Implementation with Supabase and React
DESCRIPTION: This comprehensive code snippet demonstrates how to build an infinite scrolling list of items (tickets) using Supabase for data management, React for the frontend, and Next.js for server-side rendering. It includes state management for loaded items and pagination, scroll event handling to detect when more items are needed, and data fetching logic to load additional pages from Supabase. Framer Motion is used for smooth entry animations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-04-04-infinite-scroll-with-nextjs-framer-motion.mdx#_snippet_8

LANGUAGE: jsx
CODE:
```
import { useEffect, useState, useRef } from 'react'
import { createClient } from '@supabase/supabase-js'
import { debounce } from 'lodash'
import { motion } from 'framer-motion'

const supabase = createClient('supabase-url', 'supabase-key')

export default function TicketsPage({ tickets }) {
  const PAGE_COUNT = 20
  const containerRef = useRef(null)
  const [loadedTickets, setLoadedTickets] = useState(tickets)
  const [offset, setOffset] = useState(1)
  const [isLoading, setIsLoading] = useState(false)
  const [isInView, setIsInView] = useState(false)

  const handleScroll = (container) => {
    if (containerRef.current && typeof window !== 'undefined') {
      const container = containerRef.current
      const { bottom } = container.getBoundingClientRect()
      const { innerHeight } = window
      setIsInView((prev) => bottom <= innerHeight)
    }
  }

  useEffect(() => {
    const handleDebouncedScroll = debounce(() => !isLast && handleScroll(), 200)
    window.addEventListener('scroll', handleScroll)
    return () => {
      window.removeEventListener('scroll', handleScroll)
    }
  }, [])

  useEffect(() => {
    if (isInView) {
      loadMoreTickets(offset)
    }
  }, [isInView])

  const loadMoreTickets = async (offset) => {
    setIsLoading(true)
    setOffset((prev) => prev + 1)
    const { data: newTickets } = await fetchTickets(offset, PAGE_COUNT)
    setLoadedTickets((prevTickets) => [...prevTickets, ...newTickets])
    setIsLoading(false)
  }

  const fetchTickets = async (offset) => {
    const from = offset * PAGE_COUNT
    const to = from + PAGE_COUNT - 1

    const { data } = await supabase!
        .from('my_tickets_table')
        .select('*')
        .range(from, to)
        .order('createdAt', { ascending: false })

    return data
  }

  return (
    <div ref={containerRef}>
      {
        loadedTickets.map((ticket, index) => {
          const recalculatedDelay =
            index >= PAGE_COUNT * 2 ? (index - PAGE_COUNT * (offset - 1)) / 15 : index / 15

          return (
            <motion.div
              key={ticket.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{
                duration: 0.4,
                ease: [0.25, 0.25, 0, 1],
                delay: recalculatedDelay,
              }}
            >
              {/* Actual ticket component */}
            </motion.div>
          )
        })
      }
    </div>
  )
}

export const getServerSideProps = async ({ req, res }) => {
  const { data: tickets } = await supabase!
    .from('my_tickets_table')
    .select('*')
    .order('createdAt', { ascending: false })
    .limit(20)

  return {
    props: {
      tickets,
    },
  }
}
```

----------------------------------------

TITLE: Create Postgres 'embeddings' table with 'vector' extension
DESCRIPTION: This SQL snippet defines the `embeddings` table, which stores text content and its corresponding vector embedding. It enables the `vector` extension, sets up row-level security, and creates an HNSW index for efficient similarity search on the `embedding` column.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/examples/semantic-search.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create extension if not exists vector with schema extensions;

create table embeddings (
  id bigint primary key generated always as identity,
  content text not null,
  embedding vector (384)
);
alter table embeddings enable row level security;

create index on embeddings using hnsw (embedding vector_ip_ops);
```

----------------------------------------

TITLE: Apply Row Level Security (RLS) to Database Queries in Deno Edge Function
DESCRIPTION: This snippet demonstrates how Row Level Security (RLS) is automatically enforced when performing database queries from a Supabase Edge Function. After initializing the Supabase client with the user's Auth context, any subsequent `supabaseClient.from().select()` calls will respect the RLS policies defined for the authenticated user.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/auth.mdx#_snippet_2

LANGUAGE: js
CODE:
```
import { createClient } from 'npm:@supabase/supabase-js@2'

Deno.serve(async (req: Request) => {

  const supabaseClient = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_ANON_KEY') ?? '',
    // Create client with Auth context of the user that called the function.
    // This way your row-level-security (RLS) policies are applied.
    {
      global: {
        headers: { Authorization: req.headers.get('Authorization')! },
      },
    }
  );

  // Get the session or user object
  const authHeader = req.headers.get('Authorization')!;
  const token = authHeader.replace('Bearer ', '');
  const { data: userData } = await supabaseClient.auth.getUser(token);
  const { data, error } = await supabaseClient.from('profiles').select('*');

  return new Response(JSON.stringify({ data }), {
    headers: { 'Content-Type': 'application/json' },
    status: 200,
  })

})
```

----------------------------------------

TITLE: Initialize Supabase SSR Client in SvelteKit Server Hook
DESCRIPTION: Configures the Supabase client for server-side rendering in `src/hooks.server.ts`. This setup automatically uses cookies for session management, making the user's session available throughout the SvelteKit stack. It also includes a `safeGetSession` utility to validate the JWT before returning the session.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-sveltekit.mdx#_snippet_4

LANGUAGE: ts
CODE:
```
// src/hooks.server.ts
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public'
import { createServerClient } from '@supabase/ssr'
import type { Handle } from '@sveltejs/kit'

export const handle: Handle = async ({ event, resolve }) => {
  event.locals.supabase = createServerClient(PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY, {
    cookies: {
      getAll: () => event.cookies.getAll(),
      /**
       * SvelteKit's cookies API requires `path` to be explicitly set in
       * the cookie options. Setting `path` to `/` replicates previous/
       * standard behavior.
       */
      setAll: (cookiesToSet) => {
        cookiesToSet.forEach(({ name, value, options }) => {
          event.cookies.set(name, value, { ...options, path: '/' })
        })
      }
    }
  })

  /**
   * Unlike `supabase.auth.getSession()`, which returns the session _without_
   * validating the JWT, this function also calls `getUser()` to validate the
   * JWT before returning the session.
   */
  event.locals.safeGetSession = async () => {
    const {
      data: { session }
    } = await event.locals.supabase.auth.getSession()
    if (!session) {
      return { session: null, user: null }
    }

    const {
      data: { user },
      error
    } = await event.locals.supabase.auth.getUser()
    if (error) {
      // JWT validation has failed
      return { session: null, user: null }
    }

    return { session, user }
  }

  return resolve(event, {
    filterSerializedResponseHeaders(name) {
      return name === 'content-range' || name === 'x-supabase-api-version'
    }
  })
}
```

----------------------------------------

TITLE: PL/pgSQL Hook: Notify User on Failed Login Attempts
DESCRIPTION: This comprehensive PL/pgSQL function, `hook_notify_user_on_failed_attempts`, acts as a Supabase Auth hook. It records all sign-in attempts, counts failed attempts within a 24-hour period, and if a threshold (e.g., 5 attempts) is met, it fetches an email API key from Supabase Vault and sends a security alert email to the user via `pg_net`. It handles potential email sending errors and then instructs Supabase Auth to continue.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/password-verification-hook.mdx#_snippet_9

LANGUAGE: sql
CODE:
```
create or replace function public.hook_notify_user_on_failed_attempts(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    user_id uuid;
    server_token text;
    user_email_address text;
    email_body jsonb;
    response_id int; -- Variable to store the response ID
    http_code int;
    error_message jsonb;
    attempt_count int;
    max_attempts int := 5; -- Set the threshold for failed attempts
  begin
    user_id := (event->>'user_id')::uuid;

    -- Record the attempt
    insert into public.password_sign_in_attempts (user_id, attempt_id, last_attempt_at, attempt_successful)
    values (user_id, (event->>'attempt_id')::uuid, now(), (event->>'valid')::boolean)
    on conflict (user_id, attempt_id)
    do update set last_attempt_at = now(), attempt_successful = (event->>'valid')::boolean;

    -- Check failed attempts and fetch user email
    select count(*), u.email into attempt_count, user_email_address
    from public.password_sign_in_attempts a
    join auth.users u on a.user_id = u.id
    where a.user_id = user_id and attempt_successful = false and last_attempt_at > (now() - interval '1 day');

    -- Notify user if the number of failed attempts exceeds the threshold
    if attempt_count >= max_attempts then
      -- Fetch the server token
      select decrypted_secret into server_token from vault.decrypted_secrets where name = 'my_api_key_name';

      -- Prepare the email body
      email_body := format('{
        "from": "yoursenderemail@example.com",
        "to": "%s",
        "subject": "Security Alert: Repeated Login Attempts Detected",
        "textbody": "We have detected repeated login attempts for your account. If this was not you, please secure your account.",
        "htmlbody": "<html><body><strong>Security Alert:</strong> We have detected repeated login attempts for your account. If this was not you, please secure your account.</body></html>",
        "messagestream": "outbound"
      }', user_email_address)::jsonb;

      -- Perform the HTTP POST request using Postmark
      select id into response_id from net.http_post(
        'https://api.youremailprovider.com/email',
        email_body,
        'application/json',
        array['Accept: application/json', 'X-Postmark-Server-Token: ' || server_token]
      );

      -- Fetch the response from net._http_response using the obtained id
      select status_code, content into http_code, error_message from net._http_response where id = response_id;

      -- Handle email sending errors
      if http_code is null or (http_code < 200 or http_code >= 300) then
        return jsonb_build_object(
          'error', jsonb_build_object(
            'http_code', coalesce(http_code, 0),
            'message', coalesce(error_message ->> 'message', 'error sending email')
          )
        );
      end if;
    end if;

    -- Continue with default behavior
    return jsonb_build_object('decision', 'continue');
  end;
$$;
```

----------------------------------------

TITLE: Perform Data Mutation with Supabase in Next.js Server Action
DESCRIPTION: This snippet illustrates how to perform a data mutation (inserting a todo) using Supabase within a Next.js Server Action. It utilizes `createServerActionClient` to interact with Supabase and `revalidatePath` to refresh the data after the mutation, all executed server-side.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_13

LANGUAGE: jsx
CODE:
```
import { cookies } from 'next/headers'
import { createServerActionClient } from '@supabase/auth-helpers-nextjs'
import { revalidatePath } from 'next/cache'

export default async function NewTodo() {
  const addTodo = async (formData) => {
    'use server'

    const title = formData.get('title')
    const supabase = createServerActionClient({ cookies })
    await supabase.from('todos').insert({ title })
    revalidatePath('/')
  }

  return (
    <form action={addTodo}>
      <input name="title" />
    </form>
  )
}
```

LANGUAGE: tsx
CODE:
```
import { cookies } from 'next/headers'
import { createServerActionClient } from '@supabase/auth-helpers-nextjs'
import { revalidatePath } from 'next/cache'

import type { Database } from '@/lib/database.types'

export default async function NewTodo() {
  const addTodo = async (formData: FormData) => {
    'use server'

    const title = formData.get('title')
    const cookieStore = cookies()
    const supabase = createServerActionClient<Database>({ cookies: () => cookieStore })
    await supabase.from('todos').insert({ title })
    revalidatePath('/')
  }

  return (
    <form action={addTodo}>
      <input name="title" />
    </form>
  )
}
```

----------------------------------------

TITLE: Deno Serverless Function for Email Dispatch with Fallback
DESCRIPTION: This Deno.serve handler processes incoming webhook requests, verifies the payload using a secret, and attempts to send emails. It prioritizes Postmark as the primary email provider and falls back to SendGrid if Postmark fails. The function handles environment variables for API keys and webhook secrets, and returns appropriate JSON responses for success or failure.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/send-email-hook.mdx#_snippet_25

LANGUAGE: TypeScript
CODE:
```
Deno.serve(async (req) => {
    const payload = await req.text();
    const postmarkServerToken = Deno.env.get("POSTMARK_SERVER_TOKEN");
    const sendGridApiKey = Deno.env.get("SENDGRID_API_KEY");
    const headers = Object.fromEntries(req.headers);
    const base64_secret = Deno.env.get('SEND_EMAIL_HOOK_SECRET').replace('v1,whsec_', '');
    const wh = new Webhook(base64_secret);
    const {
        user,
        email_data
    } = wh.verify(payload, headers);

    try {
        // Try sending email using Postmark
        let response = await sendEmailWithPostmark(user, email_data, postmarkServerToken!);

        if (!response.ok) {
            // If Postmark fails, try SendGrid
            console.error(`Primary email send failed: ${await response.text()}`);
            response = await sendEmailWithSendGrid(user, email_data, sendGridApiKey!);

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Failed to send email via backup: ${errorData.errors[0].message}`);
            }
        }

        return new Response(JSON.stringify({
            message: "Email sent successfully."
        }), {
            headers: {
                "Content-Type": "application/json"
            }
        });
    } catch (error) {
        return new Response(JSON.stringify({
            error: `Failed to process the request: ${error.message}`
        }), {
            status: 500,
            headers: {
                "Content-Type": "application/json"
            }
        });
    }
});
```

----------------------------------------

TITLE: Release Supabase Schema Changes to Staging/Production
DESCRIPTION: This snippet shows how to link a local project to a remote Supabase project (e.g., staging or production) using its project reference ID, and then push local database schema changes. This is a common step in CI/CD workflows for deploying migrations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-15-supabase-cli-v1-and-admin-api-beta.mdx#_snippet_6

LANGUAGE: bash
CODE:
```
supabase link --project-ref $PROJECT_ID
supabase db push
```

----------------------------------------

TITLE: Gotrue-js: Session Management and Multi-tab Support
DESCRIPTION: Deprecated and removed `session()` and `user()` in favor of `getSession()`, which ensures a valid session if a user is logged in. Multi-tab support settings are also removed as `getSession()` and GoTrue's reuse interval handle cross-tab session management automatically.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/release-notes.mdx#_snippet_14

LANGUAGE: APIDOC
CODE:
```
gotrue-js:
  - `session()`: Deprecated and removed (use `getSession()`)
  - `user()`: Deprecated and removed (use `getSession()`)
  - `multitab` support setting: Deprecated and removed
```

----------------------------------------

TITLE: Improve Supabase Query Performance with Explicit Client-Side Filters
DESCRIPTION: This section explains a performance best practice for Supabase client-side queries. Even when Row-Level Security (RLS) policies are active, explicitly adding filters (e.g., using `.eq()`) to `select` statements allows PostgreSQL to construct a more efficient query plan. Omitting filters, even if RLS would eventually restrict the results, leads to poorer performance.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_17

LANGUAGE: JavaScript
CODE:
```
const { data } = supabase
  .from('table')
  .select()
```

LANGUAGE: JavaScript
CODE:
```
const { data } = supabase
  .from('table')
  .select()
  .eq('user_id', userId)
```

----------------------------------------

TITLE: SQL Schema for Many-to-Many Relationship
DESCRIPTION: Defines the database tables `users`, `teams`, and `members`. The `members` table acts as a join table, linking users to teams in a many-to-many fashion using foreign keys and a composite primary key.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/joins-and-nesting.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create table users (
  "id" serial primary key,
  "name" text
);

create table teams (
  "id" serial primary key,
  "team_name" text
);

create table members (
  "user_id" int references users,
  "team_id" int references teams,
  primary key (user_id, team_id)
);
```

----------------------------------------

TITLE: Identify Slowest PostgreSQL Queries by Max Execution Time
DESCRIPTION: This SQL query fetches statistics for queries from `pg_stat_statements`, ordered by their maximum execution time. It provides insights into outlier queries with high execution times, similar to the frequently called queries but specifically highlighting those that are slow. Queries with high `max_time` or `mean_time` are prime candidates for optimization.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/inspect.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
select
  auth.rolname,
  statements.query,
  statements.calls,
  -- -- Postgres 13, 14, 15
  statements.total_exec_time + statements.total_plan_time as total_time,
  statements.min_exec_time + statements.min_plan_time as min_time,
  statements.max_exec_time + statements.max_plan_time as max_time,
  statements.mean_exec_time + statements.mean_plan_time as mean_time,
  -- -- Postgres <= 12
  -- total_time,
  -- min_time,
  -- max_time,
  -- mean_time,
  statements.rows / statements.calls as avg_rows
from
  pg_stat_statements as statements
  inner join pg_authid as auth on statements.userid = auth.oid
order by max_time desc
limit 100;
```

----------------------------------------

TITLE: Grant SELECT Privilege to a Role
DESCRIPTION: Demonstrates how the `postgres` user, having `SELECT` privilege with `grant option`, can grant `SELECT` permission on the `public.apps` table to the `senior_dev` role.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-04-11-postgres-roles-and-privileges.mdx#_snippet_21

LANGUAGE: SQL
CODE:
```
# as postgres
postgres=> grant select on table public.apps to senior_dev;
GRANT
```

----------------------------------------

TITLE: Linking Anonymous User to Existing Account - JavaScript
DESCRIPTION: This JavaScript snippet demonstrates how to link an anonymous Supabase user to an existing permanent account. It involves attempting to update the anonymous user's email, catching the conflict error, signing into the existing account, reassigning data associated with the anonymous user to the permanent user, and finally resolving any data conflicts using a custom `resolveDataConflicts` function. This process requires the Supabase JS client.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-anonymous.mdx#_snippet_16

LANGUAGE: JavaScript
CODE:
```
// 1. Sign in anonymously (assuming the user is already signed in anonymously)
const { data: anonData, error: anonError } = await supabase.auth.getSession()

// 2. Attempt to update the user with the existing email
const { data: updateData, error: updateError } = await supabase.auth.updateUser({
  email: 'valid.email@supabase.io',
})

// 3. Handle the error (since the email belongs to an existing user)
if (updateError) {
  console.log('This email belongs to an existing user. Please sign in to that account.')

  // 4. Sign in to the existing account
  const {
    data: { user: existingUser },
    error: signInError,
  } = await supabase.auth.signInWithPassword({
    email: 'valid.email@supabase.io',
    password: 'user_password',
  })

  if (existingUser) {
    // 5. Reassign entities tied to the anonymous user
    // This step will vary based on your specific use case and data model
    const { data: reassignData, error: reassignError } = await supabase
      .from('your_table')
      .update({ user_id: existingUser.id })
      .eq('user_id', anonData.session.user.id)

    // 6. Implement your chosen conflict resolution strategy
    // This could involve merging data, overwriting, or other custom logic
    await resolveDataConflicts(anonData.session.user.id, existingUser.id)
  }
}

// Helper function to resolve data conflicts (implement based on your strategy)
async function resolveDataConflicts(anonymousUserId, existingUserId) {
  // Implement your conflict resolution logic here
  // This could involve ignoring the anonymous user's metadata, overwriting the existing user's metadata, or merging the data of both the anonymous and existing user.
}
```

----------------------------------------

TITLE: Advanced Metadata Filtering with Supabase and LangChain
DESCRIPTION: This JavaScript snippet demonstrates how to initialize a SupabaseVectorStore with OpenAIEmbeddings, add documents containing metadata, and then perform similarity searches with complex metadata filters. It showcases the use of `SupabaseFilterRPCCall` to apply PostgREST-style JSON column filtering (e.g., `metadata->b::int`) and full-text search (`textSearch`) for precise document retrieval.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/langchain.mdx#_snippet_3

LANGUAGE: JavaScript
CODE:
```
import { SupabaseFilterRPCCall, SupabaseVectorStore } from 'langchain/vectorstores/supabase'
import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
import { createClient } from '@supabase/supabase-js'

// First, follow set-up instructions above

const privateKey = process.env.SUPABASE_SERVICE_ROLE_KEY
if (!privateKey) throw new Error(`Expected env var SUPABASE_SERVICE_ROLE_KEY`)

const url = process.env.SUPABASE_URL
if (!url) throw new Error(`Expected env var SUPABASE_URL`)

export const run = async () => {
  const client = createClient(url, privateKey)

  const embeddings = new OpenAIEmbeddings()

  const store = new SupabaseVectorStore(embeddings, {
    client,
    tableName: 'documents',
  })

  const docs = [
    {
      pageContent:
        'This is a long text, but it actually means something because vector database does not understand Lorem Ipsum. So I would need to expand upon the notion of quantum fluff, a theoretical concept where subatomic particles coalesce to form transient multidimensional spaces. Yet, this abstraction holds no real-world application or comprehensible meaning, reflecting a cosmic puzzle.',
      metadata: { b: 1, c: 10, stuff: 'right' },
    },
    {
      pageContent:
        'This is a long text, but it actually means something because vector database does not understand Lorem Ipsum. So I would need to proceed by discussing the echo of virtual tweets in the binary corridors of the digital universe. Each tweet, like a pixelated canary, hums in an unseen frequency, a fascinatingly perplexing phenomenon that, while conjuring vivid imagery, lacks any concrete implication or real-world relevance, portraying a paradox of multidimensional spaces in the age of cyber folklore.',
      metadata: { b: 2, c: 9, stuff: 'right' },
    },
    { pageContent: 'hello', metadata: { b: 1, c: 9, stuff: 'right' } },
    { pageContent: 'hello', metadata: { b: 1, c: 9, stuff: 'wrong' } },
    { pageContent: 'hi', metadata: { b: 2, c: 8, stuff: 'right' } },
    { pageContent: 'bye', metadata: { b: 3, c: 7, stuff: 'right' } },
    { pageContent: "what's this", metadata: { b: 4, c: 6, stuff: 'right' } },
  ]

  await store.addDocuments(docs)

  const funcFilterA: SupabaseFilterRPCCall = (rpc) =>
    rpc
      .filter('metadata->b::int', 'lt', 3)
      .filter('metadata->c::int', 'gt', 7)
      .textSearch('content', `'multidimensional' & 'spaces'`, {
        config: 'english',
      })

  const resultA = await store.similaritySearch('quantum', 4, funcFilterA)

  const funcFilterB: SupabaseFilterRPCCall = (rpc) =>
    rpc
      .filter('metadata->b::int', 'lt', 3)
      .filter('metadata->c::int', 'gt', 7)
      .filter('metadata->>stuff', 'eq', 'right')

  const resultB = await store.similaritySearch('hello', 2, funcFilterB)

  console.log(resultA, resultB)
}
```

----------------------------------------

TITLE: Create Partial Index for Specific Data Subsets
DESCRIPTION: This SQL command creates a partial index on the 'status' column in the 'orders' table, specifically for rows where the status is 'shipped'. Partial indexes are smaller and faster than full indexes when queries frequently target a specific subset of data, provided the query's WHERE clause exactly matches the index's condition.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/query-optimization.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
create index idx_orders_status on orders (status)
where status = 'shipped';
```

----------------------------------------

TITLE: Demonstrate basic auditing setup and DML operations
DESCRIPTION: This snippet shows the end goal of the auditing solution: creating a table, enabling auditing on it, performing DML operations, and then reviewing the audit log.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-03-08-postgres-audit.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
-- create a table
create table public.members (
  id int primary key,
  name text not null
);

-- Enable auditing on the new table
select audit.enable_tracking('public.members');
```

LANGUAGE: SQL
CODE:
```
-- create a new record
insert into public.members
  (id, name)
values
  (1, 'foo');

-- edit the record
update public.members
set name = 'bar'
where id = 1;

-- delete the record
delete from public.members;
```

LANGUAGE: SQL
CODE:
```
select * from audit.record_history;
```

----------------------------------------

TITLE: Allow Authenticated Uploads to User-Specific Folder
DESCRIPTION: An SQL policy that enables authenticated users to upload files to a folder named after their `users.id` within `my_bucket_id`, using `auth.uid()`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/security/access-control.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create policy "Allow authenticated uploads"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'my_bucket_id' and
  (storage.foldername(name))[1] = (select auth.uid()::text)
);
```

----------------------------------------

TITLE: Supabase Authentication Handlers (Signup and Login)
DESCRIPTION: This TypeScript snippet defines server-side actions for user signup and login using Supabase's authentication methods. It handles form data submission, calls `supabase.auth.signUp` or `supabase.auth.signInWithPassword`, and redirects users based on the authentication outcome.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/sveltekit.mdx#_snippet_8

LANGUAGE: ts
CODE:
```
    const password = formData.get('password') as string

    const { error } = await supabase.auth.signUp({ email, password })
    if (error) {
      console.error(error)
      redirect(303, '/auth/error')
    } else {
      redirect(303, '/')
    }
  },
  login: async ({ request, locals: { supabase } }) => {
    const formData = await request.formData()
    const email = formData.get('email') as string
    const password = formData.get('password') as string

    const { error } = await supabase.auth.signInWithPassword({ email, password })
    if (error) {
      console.error(error)
      redirect(303, '/auth/error')
    } else {
      redirect(303, '/private')
    }
  }
```

----------------------------------------

TITLE: Extracting SSO Information from User JWT for RLS
DESCRIPTION: Provides SQL statements to extract SAML SSO-related information from a user's JWT, useful for Row Level Security policies. Includes methods for retrieving the authentication method, SSO provider UUID, and identity provider's EntityID.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/enterprise-sso/auth-sso-saml.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
auth.jwt()#>>'{amr,0,method}'
auth.jwt()#>>'{amr,0,provider}'
auth.jwt()#>>'{user_metadata,iss}'
```

----------------------------------------

TITLE: Query pg_stat_statements to Identify Slow Queries
DESCRIPTION: SQL query to analyze `pg_stat_statements` for performance bottlenecks. It filters for queries with high call counts, significant mean execution time, and substantial total execution time, allowing further filtering by query text.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/extensions/pg_stat_statements.mdx#_snippet_2

LANGUAGE: SQL
CODE:
```
select
	calls,
	mean_exec_time,
	max_exec_time,
	total_exec_time,
	stddev_exec_time,
	query
from
	pg_stat_statements
where
    calls > 50                   -- at least 50 calls
    and mean_exec_time > 2.0     -- averaging at least 2ms/call
    and total_exec_time > 60000  -- at least one minute total server time spent
    and query ilike '%user_in_organization%' -- filter to queries that touch the user_in_organization table
order by
	calls desc
```

----------------------------------------

TITLE: Identify Most Time-Consuming PostgreSQL Queries
DESCRIPTION: This SQL query retrieves the top 100 most time-consuming queries from `pg_stat_statements`, showing their total execution time and their proportion of the overall database time. It helps in identifying queries that consume significant resources, which may or may not indicate a performance issue.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/inspect.mdx#_snippet_7

LANGUAGE: sql
CODE:
```
select
  auth.rolname,
  statements.query,
  statements.calls,
  statements.total_exec_time + statements.total_plan_time as total_time,
  to_char(
    (
      (statements.total_exec_time + statements.total_plan_time) / sum(
        statements.total_exec_time + statements.total_plan_time
      ) over ()
    ) * 100,
    'FM90D0'
  ) || '%' as prop_total_time
from
  pg_stat_statements as statements
  inner join pg_authid as auth on statements.userid = auth.oid
order by total_time desc
limit 100;
```

----------------------------------------

TITLE: Migrate SvelteKit API Route Authentication with Supabase Auth Helpers
DESCRIPTION: This snippet illustrates the migration of API route authentication using `withApiAuth` in SvelteKit from version 0.7.x to 0.8.0 of Supabase Auth Helpers. It shows how to secure API endpoints and fetch data, moving from `withAuth` to `getSupabase` for server-side requests.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/sveltekit.mdx#_snippet_27

LANGUAGE: TypeScript (0.7.x)
CODE:
```
import type { RequestHandler } from './$types'
import { withAuth } from '@supabase/auth-helpers-sveltekit'
import { json, redirect } from '@sveltejs/kit'

interface TestTable {
  id: string
  created_at: string
}

export const GET: RequestHandler = withAuth(async ({ session, getSupabaseClient }) => {
  if (!session.user) {
    redirect(303, '/')
  }

  const { data } = await getSupabaseClient().from<TestTable>('test').select('*')

  return json({ data })
})
```

LANGUAGE: TypeScript (0.8.0)
CODE:
```
import type { RequestHandler } from './$types'
import { getSupabase } from '@supabase/auth-helpers-sveltekit'
import { json, redirect } from '@sveltejs/kit'

export const GET: RequestHandler = async (event) => {
  const { session, supabaseClient } = await getSupabase(event)
  if (!session) {
    redirect(303, '/')
  }
  const { data } = await supabaseClient.from('test').select('*')

  return json({ data })
}
```

----------------------------------------

TITLE: Sign in with a third-party OAuth provider
DESCRIPTION: Illustrates the process of authenticating users via third-party OAuth providers like GitHub, highlighting the transition from `signInWithProvider` to `signInWithOAuth`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/dart/v0/upgrade-guide.mdx#_snippet_6

LANGUAGE: dart
CODE:
```
await supabase.auth.signInWithProvider(
  Provider.github,
  options: AuthOptions(
      redirectTo: kIsWeb
          ? null
          : 'io.supabase.flutter://reset-callback/'),
);
```

LANGUAGE: dart
CODE:
```
await supabase.auth.signInWithOAuth(
  Provider.github,
  redirectTo: kIsWeb ? null : 'io.supabase.flutter://reset-callback/',
);
```

----------------------------------------

TITLE: Supabase Edge Function: Hugging Face Image Captioning
DESCRIPTION: This Deno-based Supabase Edge Function automatically captions images uploaded to Supabase Storage. It uses the Hugging Face Inference API's `imageToText` model to generate a description, which is then stored in a dedicated `image_caption` table in your Supabase database.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/huggingface-image-captioning.mdx#_snippet_1

LANGUAGE: typescript
CODE:
```
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { HfInference } from 'https://esm.sh/@huggingface/inference@2.3.2'
import { createClient } from 'npm:@supabase/supabase-js@2'
import { Database } from './types.ts'

console.log('Hello from `huggingface-image-captioning` function!')

const hf = new HfInference(Deno.env.get('HUGGINGFACE_ACCESS_TOKEN'))

type SoRecord = Database['storage']['Tables']['objects']['Row']
interface WebhookPayload {
  type: 'INSERT' | 'UPDATE' | 'DELETE'
  table: string
  record: SoRecord
  schema: 'public'
  old_record: null | SoRecord
}

serve(async (req) => {
  const payload: WebhookPayload = await req.json()
  const soRecord = payload.record
  const supabaseAdminClient = createClient<Database>(
    // Supabase API URL - env var exported by default when deployed.
    Deno.env.get('SUPABASE_URL') ?? '',
    // Supabase API SERVICE ROLE KEY - env var exported by default when deployed.
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  )

  // Construct image url from storage
  const { data, error } = await supabaseAdminClient.storage
    .from(soRecord.bucket_id!)
    .createSignedUrl(soRecord.path_tokens!.join('/'), 60)
  if (error) throw error
  const { signedUrl } = data

  // Run image captioning with Huggingface
  const imgDesc = await hf.imageToText({
    data: await (await fetch(signedUrl)).blob(),
    model: 'nlpconnect/vit-gpt2-image-captioning',
  })

  // Store image caption in Database table
  await supabaseAdminClient
    .from('image_caption')
    .insert({ id: soRecord.id!, caption: imgDesc.generated_text })
    .throwOnError()

  return new Response('ok')
})
```

----------------------------------------

TITLE: RLS Policy with Explicit Role Specification for Authenticated Users in SQL
DESCRIPTION: This SQL policy grants authenticated users access to their own records. By explicitly using `TO authenticated`, the policy condition `( (select auth.uid()) = user_id )` is only evaluated for authenticated users, preventing unnecessary execution for `anon` users and improving efficiency.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/database-rls-policies.md#_snippet_17

LANGUAGE: SQL
CODE:
```
create policy "Users can access their own records" on rls_test
to authenticated
using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Implement Row Level Security for Multi-Tenancy with SSO
DESCRIPTION: This SQL snippet illustrates how to apply Row Level Security (RLS) in PostgreSQL to enforce multi-tenancy. It restricts access to rows based on a `tenant_id` column, matching it with the `provider` identifier extracted from the authenticated user's JWT `app_metadata`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-04-13-supabase-auth-sso-pkce.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
create policy "Only allow read-write access to tenants" on tablename as restrictive to authenticated using (
  tenant_id = (select auth.jwt() -> 'app_metadata' ->> 'provider')
);
```

----------------------------------------

TITLE: Implement Supabase Server Actions for User Authentication
DESCRIPTION: This code snippet illustrates how to create server actions (`login` and `signup`) in Next.js using `createClient` from `@/utils/supabase/server`. These actions handle user authentication (sign-in and sign-up) by extracting email and password from form data, interacting with Supabase Auth, and redirecting based on the authentication outcome. Input validation is recommended in a production environment.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/how-to-migrate-from-supabase-auth-helpers-to-ssr-package-5NRunM.mdx#_snippet_3

LANGUAGE: TypeScript
CODE:
```
// app/login/actions.ts

'use server';

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

import { createClient } from '@/utils/supabase/server';

export async function login(formData: FormData) {
  const supabase = createClient();

  // type-casting here for convenience
  // in practice, you should validate your inputs
  const data = {
    email: formData.get('email') as string,
    password: formData.get('password') as string
  };

  const { error } = await supabase.auth.signInWithPassword(data);

  if (error) {
    redirect('/error');
  }

  revalidatePath('/', 'layout');
  redirect('/');
}

export async function signup(formData: FormData) {
  const supabase = createClient();

  // type-casting here for convenience
  // in practice, you should validate your inputs
  const data = {
    email: formData.get('email') as string,
    password: formData.get('password') as string
  };

  const { error } = await supabase.auth.signUp(data);

  if (error) {
    redirect('/error');
  }

  revalidatePath('/', 'layout');
  redirect('/');
}
```

----------------------------------------

TITLE: Integrate Resumable Uploads in React with Uppy and Supabase
DESCRIPTION: This React component illustrates how to integrate Uppy with `@uppy/tus` for resumable file uploads to Supabase Storage. It uses a custom hook (`useUppyWithSupabase`) to configure Uppy with Supabase authentication and renders the Uppy Dashboard for a user-friendly drag-and-drop interface, suitable for React applications.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/uploads/resumable-uploads.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { useEffect, useState } from "react";
import { createClient } from "@supabase/supabase-js";
import Uppy from "@uppy/core";
import Tus from "@uppy/tus";
import Dashboard from "@uppy/dashboard";
import "@uppy/core/dist/style.min.css";
import "@uppy/dashboard/dist/style.min.css";

function App() {
    // Initialize Uppy instance with the 'sample' bucket specified for uploads
    const uppy = useUppyWithSupabase({ bucketName: "sample" });

    useEffect(() => {
        // Set up Uppy Dashboard to display as an inline component within a specified target
        uppy.use(Dashboard, {
            inline: true, // Ensures the dashboard is rendered inline
            target: "#drag-drop-area", // HTML element where the dashboard renders
            showProgressDetails: true, // Show progress details for file uploads
        });
    }, []);

    return (
        <div id="drag-drop-area">
        </div>
        {/* Target element for the Uppy Dashboard */}
    );
}

export default App;

/**
 * Custom hook for configuring Uppy with Supabase authentication and TUS resumable uploads
 * @param {Object} options - Configuration options for the Uppy instance.
 * @param {string} options.bucketName - The bucket name in Supabase where files are stored.

```

----------------------------------------

TITLE: Track Edge Function Errors with Sentry Deno SDK
DESCRIPTION: This example demonstrates how to integrate the Sentry Deno SDK into a Supabase Edge Function to capture and report exceptions. It initializes Sentry with a DSN, sets custom tags for region and execution ID, and wraps the main request handling logic in a try-catch block to ensure errors are sent to Sentry.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-12-12-edge-functions-node-npm.mdx#_snippet_2

LANGUAGE: JSX
CODE:
```
import * as Sentry from 'https://deno.land/x/sentry/index.mjs'

Sentry.init({
  dsn: _DSN_,
  integrations: [],
  // Performance Monitoring
  tracesSampleRate: 1.0,
  // Set sampling rate for profiling - this is relative to tracesSampleRate
  profilesSampleRate: 1.0,
})

// Set region and execution_id as custom tags
Sentry.setTag('region', Deno.env.get('SB_REGION'))
Sentry.setTag('execution_id', Deno.env.get('SB_EXECUTION_ID'))

Deno.serve(async (req) => {
  try {
    const { name } = await req.json()
    const data = {
      message: `Hello ${name}!`,
    }

    return new Response(JSON.stringify(data), { headers: { 'Content-Type': 'application/json' } })
  } catch (e) {
    Sentry.captureException(e)
    return new Response(JSON.stringify({ msg: 'error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    })
  }
})
```

----------------------------------------

TITLE: Use a custom `access_token` JWT with Supabase
DESCRIPTION: Explains the updated method for using a custom JWT `access_token` with Supabase. The 'Before' example uses `setAuth`, which is now replaced by configuring the `Authorization` header during client initialization in the 'After' example.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/v1/upgrade-guide.mdx#_snippet_11

LANGUAGE: ts
CODE:
```
const { user, error } = supabase.auth.setAuth(access_token)
```

LANGUAGE: ts
CODE:
```
const supabase = createClient(
  SUPABASE_URL,
  SUPABASE_ANON_KEY,
  {
    global: {
      headers: {
        Authorization: `Bearer ${access_token}`,
      },
    },
  }
)
```

----------------------------------------

TITLE: Normalize Fauna Raw Data into Relational Tables
DESCRIPTION: SQL examples demonstrating the process of normalizing data from the `fauna_users_raw` JSONB table into structured relational tables (`users` and `orders`). It showcases using Postgres JSON functions like `->` and `->>` for extracting fields and `LATERAL jsonb_array_elements` for flattening nested arrays into separate rows.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-03-21-migrating-from-fauna-to-supabase.mdx#_snippet_5

LANGUAGE: sql
CODE:
```
-- Example normalization for users
INSERT INTO users (name, email)
SELECT
  data->'data'->'name' AS name,
  data->'data'->'email' AS email
FROM fauna_users_raw;

-- Example normalization of nested orders
INSERT INTO orders (user_id, product, quantity)
SELECT
  u.id,
  order_data->>'product',
  (order_data->>'quantity')::INTEGER
FROM fauna_users_raw f
JOIN users u ON (f.data->'data'->>'email') = u.email,
LATERAL jsonb_array_elements(f.data->'data'->'orders') AS order_data;
```

----------------------------------------

TITLE: Schedule an endpoint call every minute with pg_cron
DESCRIPTION: This SQL snippet demonstrates how to schedule a recurring HTTP POST request using the `pg_cron` extension. It uses cron syntax to execute a `net.http_post` call every minute to a specified Edge Function URL, including authorization headers and a JSON body. This allows Postgres to act as a cron server for external API calls.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/extensions/pg_net.mdx#_snippet_17

LANGUAGE: SQL
CODE:
```
select cron.schedule(
	'cron-job-name',
	'* * * * *', -- Executes every minute (cron syntax)
	$$
	    -- SQL query
	    select "net"."http_post"(
            -- URL of Edge function
            url:='https://project-ref.supabase.co/functions/v1/function-name',
            headers:='{"Authorization": "Bearer <YOUR_ANON_KEY>"}'::jsonb,
            body:='{"name": "pg_net"}'::jsonb
	    ) as "request_id";
	$$
);
```

----------------------------------------

TITLE: Enforce Multi-Factor Authentication with auth.jwt() in RLS
DESCRIPTION: Illustrates how to create a restrictive Row Level Security policy that prevents users from updating their profiles unless their authentication assurance level (AAL) is 'aal2', indicating at least two levels of authentication. This uses the `auth.jwt()` function to access the 'aal' claim.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_13

LANGUAGE: SQL
CODE:
```
create policy "Restrict updates."
on profiles
as restrictive
for update
to authenticated using (
  (select auth.jwt()->>'aal') = 'aal2'
);
```

----------------------------------------

TITLE: Initialize Supabase Project Locally
DESCRIPTION: This command initializes a new Supabase project in the current directory, setting up the necessary local environment for development. It's the first step after getting Llamafile running.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-21-mozilla-llamafile-in-supabase-edge-functions.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
npx supabase bootstrap scratch
```

----------------------------------------

TITLE: Equivalent SQL Query with Implicit RLS Policy Application
DESCRIPTION: This SQL snippet demonstrates the conceptual equivalent of how a Row Level Security (RLS) policy is applied to a `SELECT` query. When the `todo_select_policy` is active, PostgreSQL implicitly adds a `WHERE` clause to filter rows based on the authenticated user's ID (`auth.uid()`), ensuring only rows belonging to the current user are returned. This illustrates the effect of RLS policies on data retrieval.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-12-01-realtime-row-level-security-in-postgresql.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
select *
from todos
where auth.uid() = todos.user_id; -- Policy is implicitly added.
```

----------------------------------------

TITLE: Initialize Supabase Vecs Client with Hugging Face Adapter
DESCRIPTION: This snippet demonstrates how to create a `vecs` client and a new collection. It highlights the use of the new 'adapter' feature, which allows for transforming input data. Here, a `ParagraphChunker` is used to split large text into smaller chunks, followed by a `TextEmbedding` adapter to convert each chunk into an embedding using a Hugging Face model like 'Supabase/gte-small'.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-07-hugging-face-supabase.mdx#_snippet_0

LANGUAGE: Python
CODE:
```
import vecs
from vecs.adapter import Adapter, ParagraphChunker, TextEmbedding

vx = vecs.create_client("postgresql://<user>:<password>@<host>:<port>/<db_name>")

# create a new collection with an associated adapter
docs = vx.get_or_create_collection(
    name="docs",
    # here comes the new part
    adapter=Adapter(
        [
            ParagraphChunker(skip_during_query=True),
            TextEmbedding(model='Supabase/gte-small'),
        ]
    )
)
```

----------------------------------------

TITLE: Supabase User Sign Out
DESCRIPTION: This snippet illustrates how to sign out a user from their Supabase session, removing them from the browser session and clearing relevant data from localStorage. Implementations are provided for JavaScript, Flutter, and Kotlin, all calling the `signOut()` method.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-kakao.mdx#_snippet_1

LANGUAGE: js
CODE:
```
async function signOut() {
  const { error } = await supabase.auth.signOut()
}
```

LANGUAGE: dart
CODE:
```
Future<void> signOut() async {
  await supabase.auth.signOut();
}
```

LANGUAGE: kotlin
CODE:
```
suspend fun signOut() {
	supabase.auth.signOut()
}
```

----------------------------------------

TITLE: Next.js Middleware for Supabase Session Management
DESCRIPTION: This code demonstrates how to implement a Next.js middleware to manage Supabase user sessions on the server. It uses `createMiddlewareClient` to read and update session cookies, ensuring the user's authentication remains active for Server Components. The `config.matcher` is used to specify paths where the middleware should run, optimizing performance by excluding static assets.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_2

LANGUAGE: JavaScript
CODE:
```
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'

export async function middleware(req) {
  const res = NextResponse.next()

  // Create a Supabase client configured to use cookies
  const supabase = createMiddlewareClient({ req, res })

  // Refresh session if expired - required for Server Components
  await supabase.auth.getUser()

  return res
}

// Ensure the middleware is only called for relevant paths.
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico).*),'
  ]
}
```

LANGUAGE: TypeScript
CODE:
```
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'

import type { NextRequest } from 'next/server'
import type { Database } from '@/lib/database.types'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()

  // Create a Supabase client configured to use cookies
  const supabase = createMiddlewareClient<Database>({ req, res })

  // Refresh session if expired - required for Server Components
  await supabase.auth.getSession()

  return res
}

// Ensure the middleware is only called for relevant paths.
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*),'
  ]
}
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: Create a .env.local file and add the necessary environment variables for your Supabase project, including your database URL and anonymous key, to connect the Next.js application.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/realtime/nextjs-auth-presence/README.md#_snippet_1

LANGUAGE: Bash
CODE:
```
NEXT_PUBLIC_SUPABASE_URL=<<insert-your-db-url-here>>

NEXT_PUBLIC_SUPABASE_ANON_KEY=<<insert-your-anon-key-here>>
```

----------------------------------------

TITLE: Create Restrictive RLS Policy for Firebase and Supabase Auth
DESCRIPTION: This SQL snippet demonstrates how to create a restrictive Row-Level Security (RLS) policy for a table. This policy ensures that only JWTs issued by your specific Firebase project or Supabase Auth can access the data, preventing unauthorized access from other Firebase projects. It's crucial for self-hosted Supabase instances.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/third-party/firebase-auth.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
create policy "Restrict access to Supabase Auth and Firebase Auth for project ID <firebase-project-id>"
  on table_name
  as restrictive
  to authenticated
  using (
    (auth.jwt()->>'iss' = 'https://<project-ref>.supabase.co/auth/v1')
    or
    (
        auth.jwt()->>'iss' = 'https://securetoken.google.com/<firebase-project-id>'
        and
        auth.jwt()->>'aud' = '<firebase-project-id>'
     )
  );
```

----------------------------------------

TITLE: Define Zod Schema for Form Validation
DESCRIPTION: Shows how to define a Zod schema to specify the validation rules and shape of the form data, in this case, a username field with minimum and maximum length constraints.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/design-system/content/docs/components/form.mdx#_snippet_4

LANGUAGE: tsx
CODE:
```
'use client'

import { z } from 'zod'

const formSchema = z.object({
  username: z.string().min(2).max(50),
})
```

----------------------------------------

TITLE: Implement Angular Auth Guard for Page Protection
DESCRIPTION: This TypeScript code defines an Angular `AuthGuard` that implements the `CanActivate` interface. It injects `AuthService`, `Router`, and `ToastController` to check the current user's authentication status. The guard filters out initial observable values, takes the first emission, and maps the authentication status: if authenticated, it returns `true`; otherwise, it displays a toast message and redirects the user to the '/groups' page.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-11-08-authentication-in-ionic-angular.mdx#_snippet_27

LANGUAGE: typescript
CODE:
```
import { AuthService } from './../services/auth.service';
import { Injectable } from '@angular/core';
import { ActivatedRouteSnapshot, CanActivate, Router, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';
import { filter, map, take } from 'rxjs/operators';
import { ToastController } from '@ionic/angular';

@Injectable({
  providedIn: 'root',
})
export class AuthGuard implements CanActivate {
  constructor(
    private auth: AuthService,
    private router: Router,
    private toastController: ToastController
  ) {}

  canActivate(route: ActivatedRouteSnapshot): Observable<boolean | UrlTree> {
    return this.auth.getCurrentUser().pipe(
      filter((val) => val !== null), // Filter out initial Behavior subject value
      take(1), // Otherwise the Observable doesn't complete!
      map((isAuthenticated) => {
        if (isAuthenticated) {
          return true;
        } else {
          this.toastController
            .create({
              message: 'You are not allowed to access this!',
              duration: 2000,
            })
            .then((toast) => toast.present());

          return this.router.createUrlTree(['/groups']);
        }
      })
    );
  }
}
```

----------------------------------------

TITLE: Define Supabase Application Schema Tables
DESCRIPTION: SQL DDL statements to create the core tables for a Supabase application. This includes `profiles` for user information, `organizations` for multi-tenancy, `org_members` for linking users to organizations with roles, `posts` for content, and `comments` for post interactions. Each table defines primary keys, foreign key relationships, data types, default values, and constraints for data integrity.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/local-development/testing/pgtap-extended.mdx#_snippet_7

LANGUAGE: sql
CODE:
```
create table public.profiles (
  id uuid references auth.users(id) primary key,
  username text unique not null,
  full_name text,
  bio text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table public.organizations (
  id bigint primary key generated always as identity,
  name text not null,
  slug text unique not null,
  plan_type text not null check (plan_type in ('free', 'pro', 'enterprise')),
  max_posts int not null default 5,
  created_at timestamptz default now()
);

create table public.org_members (
  org_id bigint references public.organizations(id) on delete cascade,
  user_id uuid references auth.users(id) on delete cascade,
  role text not null check (role in ('owner', 'admin', 'editor', 'viewer')),
  created_at timestamptz default now(),
  primary key (org_id, user_id)
);

create table public.posts (
  id bigint primary key generated always as identity,
  title text not null,
  content text not null,
  author_id uuid references public.profiles(id) not null,
  org_id bigint references public.organizations(id),
  status text not null check (status in ('draft', 'published', 'archived')),
  is_premium boolean default false,
  scheduled_for timestamptz,
  category text,
  view_count int default 0,
  published_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table public.comments (
  id bigint primary key generated always as identity,
  post_id bigint references public.posts(id) on delete cascade,
  author_id uuid references public.profiles(id),
  content text not null,
  is_deleted boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
```

----------------------------------------

TITLE: Implement Supabase Auth Code Exchange API Route in Next.js
DESCRIPTION: This API route handles the server-side authentication flow by exchanging an auth code for a user session. The session is then set as a cookie for subsequent Supabase requests, enabling secure server-side rendering.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_4

LANGUAGE: JavaScript
CODE:
```
import { NextApiHandler } from 'next'
import { createPagesServerClient } from '@supabase/auth-helpers-nextjs'

const handler = async (req, res) => {
  const { code } = req.query

  if (code) {
    const supabase = createPagesServerClient({ req, res })
    await supabase.auth.exchangeCodeForSession(String(code))
  }

  res.redirect('/')
}

export default handler
```

LANGUAGE: TypeScript
CODE:
```
import { NextApiHandler } from 'next'
import { createPagesServerClient } from '@supabase/auth-helpers-nextjs'

const handler: NextApiHandler = async (req, res) => {
  const { code } = req.query

  if (code) {
    const supabase = createPagesServerClient({ req, res })
    await supabase.auth.exchangeCodeForSession(String(code))
  }

  res.redirect('/')
}

export default handler
```

----------------------------------------

TITLE: Perform Full-Text Search Queries Across Languages
DESCRIPTION: This section provides examples of executing full-text search queries against the previously created `fts` column. It demonstrates how to search for specific terms (e.g., 'little' and 'big') using PostgreSQL's `to_tsquery` operator, and shows the corresponding implementation using Supabase client libraries in JavaScript, Dart, Swift, Kotlin, and Python.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/full-text-search.mdx#_snippet_16

LANGUAGE: SQL
CODE:
```
select
  *
from
  books
where
  fts @@ to_tsquery('little & big');
```

LANGUAGE: JavaScript
CODE:
```
const { data, error } = await supabase.from('books').select().textSearch('fts', `'little' & 'big'`)
```

LANGUAGE: Dart
CODE:
```
final result = await client
  .from('books')
  .select()
  .textSearch('fts', "'little' & 'big'");
```

LANGUAGE: Swift
CODE:
```
let response = try await client
  .from("books")
  .select()
  .textSearch("fts", value: "'little' & 'big'")
  .execute()
```

LANGUAGE: Kotlin
CODE:
```
val data = supabase.from("books").select {
    filter {
        textSearch("fts", "'title' & 'big'", TextSearchType.NONE)
    }
}
```

LANGUAGE: Python
CODE:
```
data = client.from_('books').select().text_search('fts', "'little' & 'big'").execute()
```

----------------------------------------

TITLE: Implement Vector Similarity Search with pgvector in Postgres
DESCRIPTION: pgvector is a popular Postgres extension that enables vector functionality, allowing users to store OpenAI embeddings and perform vector similarity searches. It serves as an open-source alternative to dedicated vector databases like Pinecone and Milvus.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-04-14-launch-week-7-community-highlights.mdx#_snippet_4

LANGUAGE: APIDOC
CODE:
```
Postgres Extension: pgvector
  Functionality: Vector similarity search.
  Usage: Store OpenAI embeddings, alternative to Pinecone/Milvus.
  Integration: Enabled within Supabase's Postgres image.
```

----------------------------------------

TITLE: Main Application Setup with go_router and Supabase for MFA
DESCRIPTION: This Dart code snippet demonstrates the main.dart file setup for a Flutter application, integrating go_router for navigation and Supabase for authentication and Multi-Factor Authentication (MFA). It initializes Supabase, defines application routes for login, registration, home, and various MFA pages, and implements a go_router redirect function. This redirect logic intelligently guides users based on their session status and MFA assurance level, ensuring unauthenticated users are redirected to registration, and users without AAL2 (MFA verified) are directed to MFA enrollment or verification pages.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-05-04-flutter-multi-factor-authentication.mdx#_snippet_18

LANGUAGE: dart
CODE:
```
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:mfa_app/pages/auth/login_page.dart';
import 'package:mfa_app/pages/auth/register_page.dart';
import 'package:mfa_app/pages/home_page.dart';
import 'package:mfa_app/pages/list_mfa_page.dart';
import 'package:mfa_app/pages/mfa/verify_page.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:mfa_app/pages/mfa/enroll_page.dart';

void main() async {
  await Supabase.initialize(
    url: 'YOUR_SUPABASE_URL',
    anonKey: 'YOUR_ANON_KEY',
  );
  runApp(const MyApp());
}

/// Extract SupabaseClient instance in a handy variable
final supabase = Supabase.instance.client;

final _router = GoRouter(
  routes: [
    GoRoute(
      path: HomePage.route,
      builder: (context, state) => const HomePage(),
    ),
    GoRoute(
      path: ListMFAPage.route,
      builder: (context, state) => ListMFAPage(),
    ),
    GoRoute(
      path: LoginPage.route,
      builder: (context, state) => const LoginPage(),
    ),
    GoRoute(
      path: RegisterPage.route,
      builder: (context, state) => const RegisterPage(),
    ),
    GoRoute(
      path: MFAEnrollPage.route,
      builder: (context, state) => const MFAEnrollPage(),
    ),
    GoRoute(
      path: MFAVerifyPage.route,
      builder: (context, state) => const MFAVerifyPage(),
    )
  ],
  redirect: (context, state) async {
    // Any users can visit the /auth route
    if (state.location.contains('/auth') == true) {
      return null;
    }

    final session = supabase.auth.currentSession;
    // A user without a session should be redirected to the register page
    if (session == null) {
      return RegisterPage.route;
    }

    final assuranceLevelData =
        supabase.auth.mfa.getAuthenticatorAssuranceLevel();

    // The user has not setup MFA yet, so send them to enroll MFA page.
    if (assuranceLevelData.currentLevel == AuthenticatorAssuranceLevels.aal1) {
      await supabase.auth.refreshSession();
      final nextLevel =
          supabase.auth.mfa.getAuthenticatorAssuranceLevel().nextLevel;
      if (nextLevel == AuthenticatorAssuranceLevels.aal2) {
        // The user has already setup MFA, but haven't login via MFA
        // Redirect them to the verify page
        return MFAVerifyPage.route;
      } else {
        // The user has not yet setup MFA
        // Redirect them to the enrollment page
        return MFAEnrollPage.route;
      }
    }

    // The user has signed invia MFA, and is allowed to view any page.
    return null;
  }
);

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'MFA App',
      debugShowCheckedModeBanner: false,
      theme: ThemeData.light().copyWith(
        inputDecorationTheme: const InputDecorationTheme(
          border: OutlineInputBorder(),
        ),
      ),
      routerConfig: _router,
    );
  }
}
```

----------------------------------------

TITLE: Supabase Auth Multi-Factor Authentication APIs and Assurance Levels
DESCRIPTION: Overview of the core APIs provided by Supabase Auth for managing multi-factor authentication flows, including enrollment, challenge/verification, and listing factors. Also details the Authenticator Assurance Levels (AAL) encoded in JWTs for session security.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-mfa.mdx#_snippet_0

LANGUAGE: APIDOC
CODE:
```
Supabase Auth Multi-Factor Authentication (MFA) APIs:
- Enrollment API: Used to build user interfaces for adding and removing MFA factors. Access can be controlled via the Supabase Dashboard.
- Challenge and Verify APIs: Used to securely verify that a user has access to a specific MFA factor. Access can be controlled via the Supabase Dashboard.
- List Factors API: Used to build user interfaces for signing in with additional MFA factors.

Authenticator Assurance Levels (AAL) in JWT:
- 'aal' claim in the JWT indicates the assurance level of the user's identity for that particular session.
- aal1: User's identity was verified using a conventional login method (e.g., email+password, magic link, one-time password, phone auth, or social login).
- aal2: User's identity was additionally verified using at least one second factor (e.g., a TOTP code or One-Time Password code).
- JWTs without an 'aal' claim are considered to be at the 'aal1' level.
```

----------------------------------------

TITLE: Protect SvelteKit API Routes with Supabase Session Check
DESCRIPTION: This example demonstrates how to secure a SvelteKit API route by checking for a valid Supabase user session. If no session is found, it throws a 401 Unauthorized error. Otherwise, it proceeds to fetch data from Supabase, ensuring only authenticated users can access the route.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/sveltekit.mdx#_snippet_10

LANGUAGE: typescript
CODE:
```
// src/routes/api/protected-route/+server.ts
import { json, error } from '@sveltejs/kit'

export const GET = async ({ locals: { supabase, safeGetSession } }) => {
  const { session } = await safeGetSession()
  if (!session) {
    // the user is not signed in
    throw error(401, { message: 'Unauthorized' })
  }
  const { data } = await supabase.from('test').select('*')

  return json({ data })
}
```

----------------------------------------

TITLE: Implement Next.js Middleware for Supabase Authentication
DESCRIPTION: This example shows how to use a Next.js Middleware to protect an entire directory or specific routes by checking user authentication. It creates a Supabase client within the middleware, redirects unauthenticated users, and allows authenticated users to proceed.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_12

LANGUAGE: TypeScript
CODE:
```
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  // We need to create a response and hand it to the supabase client to be able to modify the response headers.
  const res = NextResponse.next()
  // Create authenticated Supabase Client.
  const supabase = createMiddlewareClient({ req, res })
  // Check if we have a session
  const {
    data: { user },
  } = await supabase.auth.getUser()

  // Check auth condition
  if (user?.email?.endsWith('@gmail.com')) {
    // Authentication successful, forward request to protected route.
    return res
  }

  // Auth condition not met, redirect to home page.
  const redirectUrl = req.nextUrl.clone()
  redirectUrl.pathname = '/'
  redirectUrl.searchParams.set(`redirectedFrom`, req.nextUrl.pathname)
  return NextResponse.redirect(redirectUrl)
}

export const config = {
  matcher: '/middleware-protected/:path*',
}
```

----------------------------------------

TITLE: Create Search Term Embedding with Hugging Face Transformers Web Worker (JavaScript)
DESCRIPTION: This JavaScript code sets up a web worker to generate embeddings for search terms using `@huggingface/transformers`. It implements a Singleton pattern for the `PipelineSingleton` to lazily load the `feature-extraction` pipeline. The worker listens for messages from the main thread, processes text input to generate embeddings, and sends the result back, enabling efficient off-main-thread computation.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-29-in-browser-semantic-search-pglite.mdx#_snippet_8

LANGUAGE: JavaScript
CODE:
```
import { pipeline } from '@huggingface/transformers'

// Use the Singleton pattern to enable lazy construction of the pipeline.
class PipelineSingleton {
  static task = 'feature-extraction'
  static model = 'Supabase/gte-small'
  static instance = null

  static async getInstance(progress_callback = null) {
    if (this.instance === null) {
      this.instance = pipeline(this.task, this.model, {
        progress_callback,
        dtype: 'fp32',
        device: !!navigator.gpu ? 'webgpu' : 'wasm',
      })
    }
    return this.instance
  }
}

// Listen for messages from the main thread
self.addEventListener('message', async (event) => {
  // Retrieve the classification pipeline. When called for the first time,
  // this will load the pipeline and save it for future use.
  let classifier = await PipelineSingleton.getInstance((x) => {
    // We also add a progress callback to the pipeline so that we can
    // track model loading.
    self.postMessage(x)
  })

  // Actually perform the classification
  let output = await classifier(event.data.text, {
    pooling: 'mean',
    normalize: true,
  })

  // Extract the embedding output
  const embedding = Array.from(output.data)

  // Send the output back to the main thread
  self.postMessage({
    status: 'complete',
    embedding,
  })
})
```

----------------------------------------

TITLE: Create PostgreSQL Function for Document Similarity Search
DESCRIPTION: SQL function 'match_documents' designed to perform a similarity search on stored document embeddings. It takes a query embedding, a similarity threshold, and a desired match count, returning matching documents along with their calculated cosine similarity.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-02-03-openai-embeddings-postgres-vector.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
create or replace function match_documents (
  query_embedding vector(1536),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  content text,
  similarity float
)
language sql stable
as $$
  select
    documents.id,
    documents.content,
    1 - (documents.embedding <=> query_embedding) as similarity
  from documents
  where documents.embedding <=> query_embedding < 1 - match_threshold
  order by documents.embedding <=> query_embedding
  limit match_count;
$$;
```

----------------------------------------

TITLE: Push Supabase Changes to Cloud
DESCRIPTION: These commands allow you to link your local Supabase project to a cloud-hosted instance and then push any local database schema changes to that remote project. Replace `your-project-ref` with your actual Supabase project reference.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/nextjs-vector-search.mdx#_snippet_7

LANGUAGE: bash
CODE:
```
supabase link --project-ref=your-project-ref

supabase db push
```

----------------------------------------

TITLE: Configure environment variables for Postgres datastore
DESCRIPTION: Set these environment variables to connect the ChatGPT Retrieval Plugin to a Postgres database. This includes your OpenAI API key, specifying 'postgres' as the DATASTORE, your Postgres host URL, and the database password.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/building-chatgpt-plugins.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
export OPENAI_API_KEY=<open_ai_api_key>
export DATASTORE=postgres
export PG_HOST=<postgres_host_url>
export PG_PASSWORD=<postgres_password>
```

----------------------------------------

TITLE: Use LangChain Supabase Hybrid Search in JavaScript
DESCRIPTION: This JavaScript (JSX) code demonstrates how to integrate `SupabaseHybridSearch` from LangChain with a Supabase client to perform document searches. It initializes embeddings and a retriever, then executes a query to find relevant documents, showcasing front-end interaction with the configured backend.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-04-14-dbdev.mdx#_snippet_3

LANGUAGE: jsx
CODE:
```
import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
import { createClient } from '@supabase/supabase-js'
import { SupabaseHybridSearch } from 'langchain/retrievers/supabase'

const privateKey = process.env.SUPABASE_PRIVATE_KEY
if (!privateKey) throw new Error(`Expected env var SUPABASE_PRIVATE_KEY`)

const url = process.env.SUPABASE_URL
if (!url) throw new Error(`Expected env var SUPABASE_URL`)

export const run = async () => {
  const client = createClient(url, privateKey)

  const embeddings = new OpenAIEmbeddings()

  const retriever = new SupabaseHybridSearch(embeddings, {
    client,
    //  Below are the defaults, expecting that you set up your supabase table and functions according to the guide above. Please change if necessary.
    similarityK: 2,
    keywordK: 2,
    tableName: 'documents',
    similarityQueryName: 'match_documents',
    keywordQueryName: 'kw_match_documents',
  })

  const results = await retriever.getRelevantDocuments('hello bye')

  console.log(results)
}
```

----------------------------------------

TITLE: Supabase CLI: Generate TypeScript Types
DESCRIPTION: These commands use the Supabase CLI to generate TypeScript types for your database. The first command generates types from a local Supabase project setup, while the second generates them directly from a specified database URL, useful for integrating database schemas into your application's type system.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-15-supabase-cli-v1-and-admin-api-beta.mdx#_snippet_8

LANGUAGE: bash
CODE:
```
supabase gen types typescript --local
supabase gen types typescript --db-url $SUPABASE_DB_URL
```

----------------------------------------

TITLE: Adding Admin Role to JWT Claims (SQL)
DESCRIPTION: This SQL function implements a custom access token hook that checks if a user is an administrator based on an `is_admin` flag in a `profiles` table. If the user is an admin, it adds an `admin: true` claim to their `app_metadata` within the JWT, allowing for restricted actions. It also includes DDL for the `profiles` table and grants/revokes for permissions.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/custom-access-token-hook.mdx#_snippet_3

LANGUAGE: SQL
CODE:
```
create table profiles (
  user_id uuid not null primary key references auth.users (id),
  is_admin boolean not null default false
);
```

LANGUAGE: SQL
CODE:
```
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    claims jsonb;
    is_admin boolean;
  begin
    -- Check if the user is marked as admin in the profiles table
    select is_admin into is_admin from profiles where user_id = (event->>'user_id')::uuid;

    -- Proceed only if the user is an admin
    if is_admin then
      claims := event->'claims';

      -- Check if 'app_metadata' exists in claims
      if jsonb_typeof(claims->'app_metadata') is null then
        -- If 'app_metadata' does not exist, create an empty object
        claims := jsonb_set(claims, '{app_metadata}', '{}');
      end if;

      -- Set a claim of 'admin'
      claims := jsonb_set(claims, '{app_metadata, admin}', 'true');

      -- Update the 'claims' object in the original event
      event := jsonb_set(event, '{claims}', claims);
    end if;

    -- Return the modified or original event
    return event;
  end;
$$;
```

LANGUAGE: SQL
CODE:
```
grant all
  on table public.profiles
  to supabase_auth_admin;

revoke all
  on table public.profiles
  from authenticated, anon, public;
```

----------------------------------------

TITLE: Generate Text Embeddings with Deno Edge Function
DESCRIPTION: This Deno (TypeScript) code snippet defines a Supabase Edge Function that accepts text input, uses a Hugging Face `transformers` pipeline to generate a text embedding, and then stores this embedding in a Postgres database table (`collections`) via `supabase-js`. It's designed for faster warm starts by constructing the pipeline outside the `serve` function.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-07-hugging-face-supabase.mdx#_snippet_3

LANGUAGE: ts
CODE:
```
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { env, pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.5.0'
import { createClient } from 'jsr:@supabase/supabase-js@2'

// Preparation for Deno runtime
env.useBrowserCache = false
env.allowLocalModels = false

const supabase = createClient(
  'https://xyzcompany.supabase.co',
  'public-anon-key',
)

// Construct pipeline outside of serve for faster warm starts
const pipe = await pipeline(
  'feature-extraction',
  'Supabase/gte-small',
)

// Deno Handler
serve(async (req) => {
  const { input } = await req.json()

  // Generate the embedding from the user input
  const output = await pipe(input, {
    pooling: 'mean',
    normalize: true,
  })

  // Get the embedding output
  const embedding = Array.from(output.data)

  // Store the embedding
  const { data, error } = await supabase
    .from('collections')
    .insert({ embedding })

  // Return the embedding
  return new Response(
    JSON.stringify({ new_row: data }),
    { headers: { 'Content-Type': 'application/json' } },
  )
})
```

----------------------------------------

TITLE: Subscribe to Postgres Database Changes with Supabase Realtime in JavaScript
DESCRIPTION: This code demonstrates how to subscribe to real-time database changes using Supabase Realtime's Postgres Changes extension. It initializes the client, creates a channel, and then uses the `on` method to listen for all (`*`) events in the `public` schema. The `subscribe` method activates the listener, logging any received database change payloads.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/concepts.mdx#_snippet_3

LANGUAGE: js
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('your_project_url', 'your_supabase_api_key')

const allChanges = supabase
  .channel('schema-db-changes')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public'
    },
    (payload) => console.log(payload)
  )
  .subscribe()
```

----------------------------------------

TITLE: Define Supabase Database Tables (SQL)
DESCRIPTION: SQL script to create `users`, `groups`, and `messages` tables in a Supabase PostgreSQL database, including primary keys, foreign keys, and default values for timestamps and user IDs.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-11-08-authentication-in-ionic-angular.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create table users (
  id uuid not null primary key,
  email text
);

create table groups (
  id bigint generated by default as identity primary key,
  creator uuid references public.users not null default auth.uid(),
  title text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table messages (
  id bigint generated by default as identity primary key,
  user_id uuid references public.users not null default auth.uid(),
  text text check (char_length(text) > 0),
  group_id bigint references groups on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
```

----------------------------------------

TITLE: Supabase Edge Function for Context-Aware OpenAI Search
DESCRIPTION: This Deno-based Supabase Edge Function implements a two-phase search process. It accepts a user query, generates an OpenAI embedding for it, then uses a Supabase RPC call (`match_documents`) to retrieve the most relevant documents from a database. These documents are then concatenated and injected as context into a GPT-3 prompt, allowing the model to generate an informed answer while managing token limits.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-02-03-openai-embeddings-postgres-vector.mdx#_snippet_6

LANGUAGE: TypeScript
CODE:
```
import { serve } from 'https://deno.land/std@0.170.0/http/server.ts'
import 'https://deno.land/x/xhr@0.2.1/mod.ts'
import { createClient } from 'jsr:@supabase/supabase-js@2'
import GPT3Tokenizer from 'https://esm.sh/gpt3-tokenizer@1.1.5'
import { Configuration, OpenAIApi } from 'https://esm.sh/openai@3.1.0'
import { oneLine, stripIndent } from 'https://esm.sh/common-tags@1.8.2'
import { supabaseClient } from './lib/supabase'

export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  // Search query is passed in request payload
  const { query } = await req.json()

  // OpenAI recommends replacing newlines with spaces for best results
  const input = query.replace(/\n/g, ' ')

  const configuration = new Configuration({ apiKey: '<YOUR_OPENAI_API_KEY>' })
  const openai = new OpenAIApi(configuration)

  // Generate a one-time embedding for the query itself
  const embeddingResponse = await openai.createEmbedding({
    model: 'text-embedding-ada-002',
    input,
  })

  const [{ embedding }] = embeddingResponse.data.data

  // Fetching whole documents for this simple example.
  //
  // Ideally for context injection, documents are chunked into
  // smaller sections at earlier pre-processing/embedding step.
  const { data: documents } = await supabaseClient.rpc('match_documents', {
    query_embedding: embedding,
    match_threshold: 0.78, // Choose an appropriate threshold for your data
    match_count: 10, // Choose the number of matches
  })

  const tokenizer = new GPT3Tokenizer({ type: 'gpt3' })
  let tokenCount = 0
  let contextText = ''

  // Concat matched documents
  for (let i = 0; i < documents.length; i++) {
    const document = documents[i]
    const content = document.content
    const encoded = tokenizer.encode(content)
    tokenCount += encoded.text.length

    // Limit context to max 1500 tokens (configurable)
    if (tokenCount > 1500) {
      break
    }

    contextText += `${content.trim()}\n---\n`
  }

  const prompt = stripIndent`${oneLine`
    You are a very enthusiastic Supabase representative who loves
    to help people! Given the following sections from the Supabase
    documentation, answer the question using only that information,
    outputted in markdown format. If you are unsure and the answer
    is not explicitly written in the documentation, say
    "Sorry, I don't know how to help with that."`}

    Context sections:
    ${contextText}

    Question: """
    ${query}
    """

    Answer as markdown (including related code snippets if available):
  `

  // In production we should handle possible errors
  const completionResponse = await openai.createCompletion({
    model: 'text-davinci-003',
    prompt,
    max_tokens: 512, // Choose the max allowed tokens in completion
    temperature: 0, // Set to 0 for deterministic results
  })

  const {
    id,
    choices: [{ text }],
  } = completionResponse.data

  return new Response(JSON.stringify({ id, text }), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' },
  })
})
```

----------------------------------------

TITLE: Apply Row Level Security for User-Specific Data in Postgres
DESCRIPTION: This SQL policy demonstrates how to implement Row Level Security (RLS) in PostgreSQL to restrict access to individual rows based on the authenticated user's ID. Specifically, it ensures that users can only view their own records in the `public.todos` table, preventing unauthorized data access at the database level and enforcing data isolation.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-16-vec2pg.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create policy "Individuals can view their own todos."
  on public.todos
  for select
  using
    ( ( select auth.uid() ) = user_id );
```

----------------------------------------

TITLE: Process OpenAI API Event Stream with Server-Sent Events (SSE) in TypeScript
DESCRIPTION: This TypeScript `useCallback` hook demonstrates how to initiate a Server-Sent Events (SSE) connection to a `/api/vector-search` endpoint, stream responses from the OpenAI API, and update the UI incrementally. It handles `[DONE]` signals, parses completion responses, and includes error handling for the event stream.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/nextjs-vector-search.mdx#_snippet_14

LANGUAGE: TypeScript
CODE:
```
const handleConfirm = React.useCallback(
  async (query: string) => {
    setAnswer(undefined)
    setQuestion(query)
    setSearch('')
    dispatchPromptData({ index: promptIndex, answer: undefined, query })
    setHasError(false)
    setIsLoading(true)

    const eventSource = new SSE(`api/vector-search`, {
      headers: {
        apikey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ?? '',
        Authorization: `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json',
      },
      payload: JSON.stringify({ query }),
    })

    function handleError<T>(err: T) {
      setIsLoading(false)
      setHasError(true)
      console.error(err)
    }

    eventSource.addEventListener('error', handleError)
    eventSource.addEventListener('message', (e: any) => {
      try {
        setIsLoading(false)

        if (e.data === '[DONE]') {
          setPromptIndex((x) => {
            return x + 1
          })
          return
        }

        const completionResponse: CreateCompletionResponse = JSON.parse(e.data)
        const text = completionResponse.choices[0].text

        setAnswer((answer) => {
          const currentAnswer = answer ?? ''

          dispatchPromptData({
            index: promptIndex,
            answer: currentAnswer + text,
          })

          return (answer ?? '') + text
        })
      } catch (err) {
        handleError(err)
      }
    })

    eventSource.stream()

    eventSourceRef.current = eventSource

    setIsLoading(true)
  },
  [promptIndex, promptData]
)
```

----------------------------------------

TITLE: Supabase Helper Function: auth.uid()
DESCRIPTION: Documentation for the 'auth.uid()' helper function provided by Supabase. This function is essential for writing RLS policies as it retrieves the unique identifier of the currently authenticated user making the request.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_10

LANGUAGE: APIDOC
CODE:
```
auth.uid()
  Returns: UUID
  Description: Returns the ID of the user making the request.
```

----------------------------------------

TITLE: Supabase Real-time Canvas Object and Cursor Sync in Flutter
DESCRIPTION: This code snippet demonstrates how to set up a real-time subscription to Supabase channels to receive updates on user cursors and canvas objects. It also shows how to fetch initial canvas data from the 'canvas_objects' table upon application startup, ensuring the local state is synchronized with the database.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-01-26-flutter-figma-clone.mdx#_snippet_18

LANGUAGE: Dart
CODE:
```
            callback: (payload) {
              final cursor = UserCursor.fromJson(payload['cursor']);
              _userCursors[cursor.id] = cursor;

              if (payload['object'] != null) {
                final object = CanvasObject.fromJson(payload['object']);
                _canvasObjects[object.id] = object;
              }
              setState(() {});
            })
        .subscribe();

    final initialData = await supabase
        .from('canvas_objects')
        .select()
        .order('created_at', ascending: true);
    for (final canvasObjectData in initialData) {
      final canvasObject = CanvasObject.fromJson(canvasObjectData['object']);
      _canvasObjects[canvasObject.id] = canvasObject;
    }
    setState(() {});
  }
```

----------------------------------------

TITLE: Create Supabase Client Utility Functions for Browser, Server, and Middleware
DESCRIPTION: This section provides utility functions to initialize Supabase clients using `@supabase/ssr` for various environments: browser, server components/actions, and Next.js middleware. These functions ensure proper handling of authentication tokens and session management across different execution contexts, including cookie management for server-side operations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/how-to-migrate-from-supabase-auth-helpers-to-ssr-package-5NRunM.mdx#_snippet_1

LANGUAGE: typescript
CODE:
```
// utils/supabase/client.ts

import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

LANGUAGE: typescript
CODE:
```
// utils/supabase/server.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createClient() {
  const cookieStore = cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        }
      }
    }
  );
}
```

LANGUAGE: typescript
CODE:
```
// utils/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        }
      }
    }
  );

  // IMPORTANT: Avoid writing any logic between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  const {
    data: { user }
  } = await supabase.auth.getUser();

  if (
    !user &&
    !request.nextUrl.pathname.startsWith('/login') &&
    !request.nextUrl.pathname.startsWith('/auth')
  ) {
    // no user, potentially respond by redirecting the user to the login page
    const url = request.nextUrl.clone();
    url.pathname = '/login';
    return NextResponse.redirect(url);
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is. If you're
  // creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse;
}
```

----------------------------------------

TITLE: GitHub Actions Workflow for Supabase Database Tests
DESCRIPTION: This YAML snippet defines a GitHub Actions workflow for continuous integration testing of your Supabase database. It automates the process of checking out the repository, setting up the Supabase CLI, starting a local Supabase instance, and running database tests on push and pull request events to the main branch.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/local-development/testing/overview.mdx#_snippet_5

LANGUAGE: yaml
CODE:
```
name: Database Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1

      - name: Start Supabase
        run: supabase start

      - name: Run Tests
        run: supabase test db
```

----------------------------------------

TITLE: Perform Multi-Column Search using Supabase Client Libraries
DESCRIPTION: Illustrates how to use various Supabase client libraries (JavaScript, Dart, Swift, Kotlin, Python) to perform a text search on a previously defined computed column (`title_description`). This allows searching across multiple underlying database columns with a single client-side query.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/full-text-search.mdx#_snippet_7

LANGUAGE: JavaScript
CODE:
```
const { data, error } = await supabase
  .from('books')
  .select()
  .textSearch('title_description', `little`)
```

LANGUAGE: Dart
CODE:
```
final result = await client
  .from('books')
  .select()
  .textSearch('title_description', "little")
```

LANGUAGE: Swift
CODE:
```
let response = try await client
  .from("books")
  .select()
  .textSearch("title_description", value: "little")
  .execute()
```

LANGUAGE: Kotlin
CODE:
```
val data = supabase.from("books").select {
    filter {
        textSearch("title_description", "title", TextSearchType.NONE)
    }
}
```

LANGUAGE: Python
CODE:
```
data = supabase.from_('books').select().text_search('title_description', "little").execute()
```

----------------------------------------

TITLE: Call Read-Only Postgres Functions via Supabase REST API
DESCRIPTION: Explains how to invoke read-only Postgres functions on Supabase Read Replicas using the REST API. It highlights the requirement to use `GET` requests and explicitly set the `get: true` option for `rpc` calls to ensure routing to a Read Replica.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/platform/read-replicas.mdx#_snippet_0

LANGUAGE: APIDOC
CODE:
```
Supabase REST API for Read Replicas:
  Supported HTTP Method: GET
  Purpose: Invoke read-only Postgres functions.

  RPC Call Option:
    Parameter: get
    Type: boolean
    Required: Yes, for read-only functions on Read Replicas
    Description: Set to 'true' to ensure the RPC call for a read-only Postgres function is routed to a Read Replica.
```

----------------------------------------

TITLE: Create a Supabase Storage bucket
DESCRIPTION: This snippet demonstrates how to create a new storage bucket named 'avatars' using different Supabase client libraries and SQL. Buckets are distinct containers for files and folders, often used to enforce different security and access rules.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/quickstart.mdx#_snippet_0

LANGUAGE: Dashboard
CODE:
```
1. Go to the [Storage](https://supabase.com/dashboard/project/_/storage/buckets) page in the Dashboard.
2. Click **New Bucket** and enter a name for the bucket.
3. Click **Create Bucket**.
```

LANGUAGE: SQL
CODE:
```
-- Use Postgres to create a bucket.

insert into storage.buckets
  (id, name)
values
  ('avatars', 'avatars');
```

LANGUAGE: JavaScript
CODE:
```
// Use the JS library to create a bucket.

const { data, error } = await supabase.storage.createBucket('avatars')
```

LANGUAGE: Dart
CODE:
```
void main() async {
  final supabase = SupabaseClient('supabaseUrl', 'supabaseKey');

  final storageResponse = await supabase
      .storage
      .createBucket('avatars');
}
```

LANGUAGE: Swift
CODE:
```
try await supabase.storage.createBucket("avatars")
```

LANGUAGE: Python
CODE:
```
response = supabase.storage.create_bucket('avatars')
```

----------------------------------------

TITLE: Implementing Row Level Security Policy for User-Specific Messages in Supabase
DESCRIPTION: This PostgreSQL policy restricts users to only insert their own messages into the messages table. It uses Supabase's auth.uid() function to compare the authenticated user's ID with the user_id column, ensuring data isolation at the row level.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-02-27-cracking-postgres-interview.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
CREATE POLICY "Individuals can only write their own messages." ON messages FOR
    INSERT WITH CHECK ((select auth.uid()) = user_id);
```

----------------------------------------

TITLE: Declare Row Level Security Policies for Supabase Tables
DESCRIPTION: This SQL script sets up Row Level Security (RLS) policies across multiple tables in a Supabase PostgreSQL database. It includes the creation of a private schema for security-definer helper functions (`get_user_org_role` and `can_add_post`), enables RLS on `profiles`, `organizations`, `org_members`, `posts`, and `comments` tables, and defines specific `SELECT`, `INSERT`, `UPDATE`, and `ALL` policies for each table based on user roles and organization limits.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/local-development/testing/pgtap-extended.mdx#_snippet_8

LANGUAGE: sql
CODE:
```
-- Create a private schema to store all security definer functions utils
-- As such functions should never be in a API exposed schema
create schema if not exists private;
-- Helper function for role checks
create or replace function private.get_user_org_role(org_id bigint, user_id uuid)
returns text
set search_path = ''
as $$
  select role from public.org_members
  where org_id = $1 and user_id = $2;
-- Note the use of security definer to avoid RLS checking recursion issue
-- see: https://supabase.com/docs/guides/database/postgres/row-level-security#use-security-definer-functions
$$ language sql security definer;
-- Helper utils to check if an org is below the max post limit
create or replace function private.can_add_post(org_id bigint)
returns boolean
set search_path = ''
as $$
  select (select count(*)
          from public.posts p
          where p.org_id = $1) < o.max_posts
  from public.organizations o
  where o.id = $1
$$ language sql security definer;


-- Enable RLS for all tables
alter table public.profiles enable row level security;
alter table public.organizations enable row level security;
alter table public.org_members enable row level security;
alter table public.posts enable row level security;
alter table public.comments enable row level security;

-- Profiles policies
create policy "Public profiles are viewable by everyone"
  on public.profiles for select using (true);

create policy "Users can insert their own profile"
  on public.profiles for insert with check ((select auth.uid()) = id);

create policy "Users can update their own profile"
  on public.profiles for update using ((select auth.uid()) = id)
  with check ((select auth.uid()) = id);

-- Organizations policies
create policy "Public org info visible to all"
  on public.organizations for select using (true);

create policy "Org management restricted to owners"
  on public.organizations for all using (
    private.get_user_org_role(id, (select auth.uid())) = 'owner'
  );

-- Org Members policies
create policy "Members visible to org members"
  on public.org_members for select using (
    private.get_user_org_role(org_id, (select auth.uid())) is not null
  );

create policy "Member management restricted to admins and owners"
  on public.org_members for all using (
    private.get_user_org_role(org_id, (select auth.uid())) in ('owner', 'admin')
  );

-- Posts policies
create policy "Complex post visibility"
  on public.posts for select using (
    -- Published non-premium posts are visible to all
    (status = 'published' and not is_premium)
    or
    -- Premium posts visible to org members only
    (status = 'published' and is_premium and
    private.get_user_org_role(org_id, (select auth.uid())) is not null)
    or
    -- All posts visible to editors and above
    private.get_user_org_role(org_id, (select auth.uid())) in ('owner', 'admin', 'editor')
  );

create policy "Post creation rules"
  on public.posts for insert with check (
    -- Must be org member with appropriate role
    private.get_user_org_role(org_id, (select auth.uid())) in ('owner', 'admin', 'editor')
    and
    -- Check org post limits for free plans
    (
      (select o.plan_type != 'free'
      from organizations o
      where o.id = org_id)
      or
      (select private.can_add_post(org_id))
    )
  );

create policy "Post update rules"
  on public.posts for update using (
    exists (
      select 1
      where
        -- Editors can update non-published posts
        (private.get_user_org_role(org_id, (select auth.uid())) = 'editor' and status != 'published')
        or
        -- Admins and owners can update any post
        private.get_user_org_role(org_id, (select auth.uid())) in ('owner', 'admin')
    )
  );

-- Comments policies
create policy "Comments on published posts are viewable by everyone"
  on public.comments for select using (
    exists (
      select 1 from public.posts
      where id = post_id
      and status = 'published'
    )
    and not is_deleted
  );

create policy "Authenticated users can create comments"
  on public.comments for insert with check ((select auth.uid()) = author_id);

create policy "Users can update their own comments"
  on public.comments for update using (author_id = (select auth.uid()));
```

----------------------------------------

TITLE: Next.js Single Post Page with ISR and `generateStaticParams`
DESCRIPTION: This Next.js App Router component (`app/static-with-revalidate/[id]/page.tsx`) fetches a single post by ID from Supabase. It uses `revalidate = 60` for ISR and `generateStaticParams` to pre-render specific post paths at build time. It handles cases where a post is not found using `notFound()` from `next/navigation`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-11-17-fetching-and-caching-supabase-data-in-next-js-server-components.mdx#_snippet_13

LANGUAGE: tsx
CODE:
```
import supabase from '../../../utils/supabase'
import { notFound } from 'next/navigation'

export const revalidate = 60

export async function generateStaticParams() {
  const { data: posts } = await supabase.from('posts').select('id')

  return posts?.map(({ id }) => ({
    id,
  }))
}

export default async function Post({ params: { id } }: { params: { id: string } }) {
  const { data: post } = await supabase.from('posts').select().match({ id }).single()

  if (!post) {
    notFound()
  }

  return <pre>{JSON.stringify(post, null, 2)}</pre>
}
```

----------------------------------------

TITLE: SQL Schema for Private Projects Table with RLS and Public View
DESCRIPTION: Defines the `private.projects` table with columns, enables Row Level Security (RLS), and establishes `INSERT` and `SELECT` policies for authenticated users based on custom `auth.can_write` and `auth.can_read` functions. It also creates a `public.projects` view that exposes a filtered subset of the private table, demonstrating attribute-based access control (ABAC).
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-04-03-declarative-schemas.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
create table private.projects (
  id              bigint    not null,
  name            text      not null,
  organization_id bigint    not null,
  inserted_at     timestamp not null,
  updated_at      timestamp not null
);

alter table private.projects
enable row level security;

create policy projects_insert
  on private.projects
  for insert
  to authenticated
with check auth.can_write(project_id);

create policy projects_select
  on private.projects
  for select
  to authenticated
using auth.can_read(project_id);

-- Users can only view the projects that they have access to
create view public.projects as select
  projects.id,
  projects.name,
  projects.organization_id,
  projects.inserted_at,
  projects.updated_at
from private.projects
where auth.can_read(projects.id);
```

----------------------------------------

TITLE: Enabling Social Login Providers in Supabase Auth UI
DESCRIPTION: Shows how to configure the Supabase Auth UI component to support social authentication providers. By passing an array of provider names (e.g., 'google', 'facebook', 'twitter') to the `providers` prop, users can log in using their social accounts.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/auth-ui.mdx#_snippet_3

LANGUAGE: js
CODE:
```
import { createClient } from '@supabase/supabase-js'
import { Auth } from '@supabase/auth-ui-react'
import { ThemeSupa } from '@supabase/auth-ui-shared'

const supabase = createClient('<INSERT PROJECT URL>', '<INSERT PROJECT ANON API KEY>')

const App = () => (
  <Auth
    supabaseClient={supabase}
    appearance={{ theme: ThemeSupa }}
    providers={['google', 'facebook', 'twitter']}
  />
)
```

----------------------------------------

TITLE: SQL: Add triggers for asynchronous embedding generation on insert and update
DESCRIPTION: These SQL triggers automate the embedding process by queuing jobs for new and updated documents. `embed_documents_on_insert` fires after new rows are added, while `embed_documents_on_update` activates when `title` or `content` columns are modified, ensuring embeddings are kept in sync asynchronously.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-04-01-automatic-embeddings.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
-- Trigger for insert events
create trigger embed_documents_on_insert
  after insert
  on documents
  for each row
  execute function util.queue_embeddings('embedding_input', 'embedding');

-- Trigger for update events
create trigger embed_documents_on_update
  after update of title, content -- must match the columns in embedding_input()
  on documents
  for each row
  execute function util.queue_embeddings('embedding_input', 'embedding');
```

----------------------------------------

TITLE: Fetching Data with Supabase in Next.js Server Components
DESCRIPTION: This example illustrates how to fetch data from Supabase directly within a Next.js Server Component. It uses the `supabase.from('...').select()` method to retrieve data, simplifying data fetching by allowing direct database calls on the server.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-11-01-supabase-is-now-compatible-with-nextjs-14.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
export default async function Page() {
  const { data } = await supabase.from('...').select()
  return ...
}
```

----------------------------------------

TITLE: Apply Supabase Database Migrations
DESCRIPTION: This command applies pending database migrations from the `supabase/migrations` directory to your Supabase project. It ensures your database schema is up-to-date with your local development environment.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/examples/elevenlabs-transcribe-speech.mdx#_snippet_7

LANGUAGE: bash
CODE:
```
supabase db push
```

----------------------------------------

TITLE: React Account Component for Supabase Profile Management
DESCRIPTION: This component allows authenticated users to view and update their profile details (username, website, avatar URL) stored in Supabase. It fetches existing profile data on load and provides a form to submit updates, handling loading states and errors.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-react.mdx#_snippet_5

LANGUAGE: jsx
CODE:
```
import { useState, useEffect } from 'react'
import { supabase } from './supabaseClient'

export default function Account({ session }) {
  const [loading, setLoading] = useState(true)
  const [username, setUsername] = useState(null)
  const [website, setWebsite] = useState(null)
  const [avatar_url, setAvatarUrl] = useState(null)

  useEffect(() => {
    let ignore = false
    async function getProfile() {
      setLoading(true)
      const { user } = session

      const { data, error } = await supabase
        .from('profiles')
        .select(`username, website, avatar_url`)
        .eq('id', user.id)
        .single()

      if (!ignore) {
        if (error) {
          console.warn(error)
        } else if (data) {
          setUsername(data.username)
          setWebsite(data.website)
          setAvatarUrl(data.avatar_url)
        }
      }

      setLoading(false)
    }

    getProfile()

    return () => {
      ignore = true
    }
  }, [session])

  async function updateProfile(event, avatarUrl) {
    event.preventDefault()

    setLoading(true)
    const { user } = session

    const updates = {
      id: user.id,
      username,
      website,
      avatar_url: avatarUrl,
      updated_at: new Date(),
    }

    const { error } = await supabase.from('profiles').upsert(updates)

    if (error) {
      alert(error.message)
    } else {
      setAvatarUrl(avatarUrl)
    }
    setLoading(false)
  }

  return (
    <form onSubmit={updateProfile} className="form-widget">
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="text" value={session.user.email} disabled />
      </div>
      <div>
        <label htmlFor="username">Name</label>
        <input
          id="username"
          type="text"
          required
          value={username || ''}
          onChange={(e) => setUsername(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="website">Website</label>
        <input
          id="website"
          type="url"
          value={website || ''}
          onChange={(e) => setWebsite(e.target.value)}
        />
      </div>

      <div>
        <button className="button block primary" type="submit" disabled={loading}>
          {loading ? 'Loading ...' : 'Update'}
        </button>
      </div>

      <div>
        <button className="button block" type="button" onClick={() => supabase.auth.signOut()}>
          Sign Out
        </button>
      </div>
    </form>
  )
}
```

----------------------------------------

TITLE: Create Supabase Account Component in React Native
DESCRIPTION: This TypeScript React Native component (`Account.tsx`) allows authenticated users to view and update their profile details (username, website, avatar URL) stored in Supabase. It manages loading states, fetches user profiles on session change, and handles profile updates and sign-out functionality.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-expo-react-native.mdx#_snippet_7

LANGUAGE: tsx
CODE:
```
import { useState, useEffect } from 'react'
import { supabase } from '../lib/supabase'
import { StyleSheet, View, Alert } from 'react-native'
import { Button, Input } from '@rneui/themed'
import { Session } from '@supabase/supabase-js'

export default function Account({ session }: { session: Session }) {
  const [loading, setLoading] = useState(true)
  const [username, setUsername] = useState('')
  const [website, setWebsite] = useState('')
  const [avatarUrl, setAvatarUrl] = useState('')

  useEffect(() => {
    if (session) getProfile()
  }, [session])

  async function getProfile() {
    try {
      setLoading(true)
      if (!session?.user) throw new Error('No user on the session!')

      const { data, error, status } = await supabase
        .from('profiles')
        .select(`username, website, avatar_url`)
        .eq('id', session?.user.id)
        .single()
      if (error && status !== 406) {
        throw error
      }

      if (data) {
        setUsername(data.username)
        setWebsite(data.website)
        setAvatarUrl(data.avatar_url)
      }
    } catch (error) {
      if (error instanceof Error) {
        Alert.alert(error.message)
      }
    } finally {
      setLoading(false)
    }
  }

  async function updateProfile({
    username,
    website,
    avatar_url,
  }: {
    username: string
    website: string
    avatar_url: string
  }) {
    try {
      setLoading(true)
      if (!session?.user) throw new Error('No user on the session!')

      const updates = {
        id: session?.user.id,
        username,
        website,
        avatar_url,
        updated_at: new Date(),
      }

      const { error } = await supabase.from('profiles').upsert(updates)

      if (error) {
        throw error
      }
    } catch (error) {
      if (error instanceof Error) {
        Alert.alert(error.message)
      }
    } finally {
      setLoading(false)
    }
  }

  return (
    <View style={styles.container}>
      <View style={[styles.verticallySpaced, styles.mt20]}>
        <Input label="Email" value={session?.user?.email} disabled />
      </View>
      <View style={styles.verticallySpaced}>
        <Input label="Username" value={username || ''} onChangeText={(text) => setUsername(text)} />
      </View>
      <View style={styles.verticallySpaced}>
        <Input label="Website" value={website || ''} onChangeText={(text) => setWebsite(text)} />
      </View>

      <View style={[styles.verticallySpaced, styles.mt20]}>
        <Button
          title={loading ? 'Loading ...' : 'Update'}
          onPress={() => updateProfile({ username, website, avatar_url: avatarUrl })}
          disabled={loading}
        />
      </View>

      <View style={styles.verticallySpaced}>
        <Button title="Sign Out" onPress={() => supabase.auth.signOut()} />
      </View>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    marginTop: 40,
    padding: 12,
  },
  verticallySpaced: {
    paddingTop: 4,
    paddingBottom: 4,
    alignSelf: 'stretch',
  },
  mt20: {
    marginTop: 20,
  },
})
```

----------------------------------------

TITLE: Installing Supabase CLI via npm
DESCRIPTION: Installs the Supabase Command Line Interface (CLI) as a development dependency using npm. This command ensures that the required minimum version (v1.8.1 or newer) is installed for type generation features.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/rest/generating-types.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
npm i supabase@">=1.8.1" --save-dev
```

----------------------------------------

TITLE: Scaffolding a new Next.js app with Supabase
DESCRIPTION: Use `create-next-app` with the `with-supabase` template to quickly set up a new Next.js application. This template pre-configures server-side cookie-based authentication, TypeScript, and Tailwind CSS, providing an ideal starting point for Supabase projects.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-10-using-supabase-with-vercel.mdx#_snippet_1

LANGUAGE: sh
CODE:
```
npx create-next-app -e with-supabase
```

----------------------------------------

TITLE: View SQL Query Execution Plans with EXPLAIN
DESCRIPTION: Demonstrates how to use the `EXPLAIN` statement in SQL to view the execution plan of a query. Examples include a basic query, a query with a WHERE clause, and an advanced analysis with `ANALYZE` and `BUFFERS` to show actual execution times and buffer usage.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/orioledb.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
EXPLAIN SELECT * FROM blog_post ORDER BY published_at DESC LIMIT 10;
                                                 QUERY PLAN
────────────────────────────────────────────────────────────────────────────────────────────────────────────
 Limit  (cost=0.15..1.67 rows=10 width=120)
   ->  Index Scan Backward using blog_post_published_at on blog_post  (cost=0.15..48.95 rows=320 width=120)
```

LANGUAGE: sql
CODE:
```
EXPLAIN SELECT * FROM blog_post WHERE id = 1;
                                    QUERY PLAN
──────────────────────────────────────────────────────────────────────────────────
 Index Scan using blog_post_pkey on blog_post  (cost=0.15..8.17 rows=1 width=120)
   Index Cond: (id = 1)
```

LANGUAGE: sql
CODE:
```
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM blog_post ORDER BY published_at DESC LIMIT 10;
                                                                      QUERY PLAN
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
 Limit  (cost=0.15..1.67 rows=10 width=120) (actual time=0.052..0.054 rows=1 loops=1)
   ->  Index Scan Backward using blog_post_published_at on blog_post  (cost=0.15..48.95 rows=320 width=120) (actual time=0.050..0.052 rows=1 loops=1)
 Planning Time: 0.186 ms
 Execution Time: 0.088 ms
```

----------------------------------------

TITLE: Generate TypeScript Types for Supabase Database
DESCRIPTION: These Bash commands start the Supabase local development environment and then generate TypeScript types for the Supabase database schema. The generated types are saved to `utils/database.types.ts`, enabling end-to-end type safety in the application.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-09-23-local-first-expo-legend-state.mdx#_snippet_8

LANGUAGE: bash
CODE:
```
supabase start
supabase gen types --lang=typescript --local > utils/database.types.ts
```

----------------------------------------

TITLE: PostgreSQL: Generating UUIDv4 with uuid-ossp
DESCRIPTION: This SQL snippet shows how to generate a Version 4 UUID in PostgreSQL using the `gen_random_uuid()` function, which is part of the `uuid-ossp` extension. UUIDv4s are entirely random and are excellent for globally unique identifiers due to their extremely low collision probability.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-09-08-choosing-a-postgres-primary-key.mdx#_snippet_12

LANGUAGE: SQL
CODE:
```
SELECT gen_random_uuid();
```

----------------------------------------

TITLE: Initializing Supabase Client in JavaScript
DESCRIPTION: This snippet demonstrates how to initialize the Supabase client in JavaScript. It requires the project URL and an anonymous public API key, which can be obtained from the Supabase dashboard. The `createClient` function is used to establish a connection to the Supabase project.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/broadcast.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'

const SUPABASE_URL = 'https://<project>.supabase.co'
const SUPABASE_KEY = '<your-anon-key>'

const supabase = createClient(SUPABASE_URL, SUPABASE_KEY)
```

----------------------------------------

TITLE: Retrieve Most Frequently Called PostgreSQL Queries
DESCRIPTION: This SQL query retrieves statistics for the most frequently executed queries from `pg_stat_statements`, ordered by the number of calls. It includes details such as the executing role, call count, average rows returned, and various execution times (total, min, max, mean). This helps identify frequently run queries that might benefit from optimization, especially those with high `max_time` or `mean_time`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/inspect.mdx#_snippet_5

LANGUAGE: sql
CODE:
```
select
  auth.rolname,
  statements.query,
  statements.calls,
  -- -- Postgres 13, 14, 15
  statements.total_exec_time + statements.total_plan_time as total_time,
  statements.min_exec_time + statements.min_plan_time as min_time,
  statements.max_exec_time + statements.max_plan_time as max_time,
  statements.mean_exec_time + statements.mean_plan_time as mean_time,
  -- -- Postgres <= 12
  -- total_time,
  -- min_time,
  -- max_time,
  -- mean_time,
  statements.rows / statements.calls as avg_rows
from
  pg_stat_statements as statements
  inner join pg_authid as auth on statements.userid = auth.oid
order by statements.calls desc
limit 100;
```

----------------------------------------

TITLE: Initiate Password Reset by Email
DESCRIPTION: Shows how to initiate a password reset flow by sending a recovery email to the user's registered email address using Supabase authentication across various programming languages.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/passwords.mdx#_snippet_11

LANGUAGE: JavaScript
CODE:
```
async function resetPassword() {
  const { data, error } = await supabase.auth.resetPasswordForEmail(email)
}
```

LANGUAGE: Swift
CODE:
```
try await supabase.auth.resetPasswordForEmail("valid.email@supabase.io")
```

LANGUAGE: Kotlin
CODE:
```
supabase.gotrue.sendRecoveryEmail(
    email = "valid.email@supabase.io",
)
```

LANGUAGE: Python
CODE:
```
supabase.auth.reset_password_email('valid.email@supabase.io')
```

----------------------------------------

TITLE: Create Supabase Products Table
DESCRIPTION: This SQL snippet defines a 'products' table in the 'public' schema. It includes columns for 'id' (UUID, primary key), 'name' (text), 'price' (real), and 'image' (text, nullable). The 'id' column defaults to a randomly generated UUID.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/product_management_sql_template.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create table
  public.products (
    id uuid not null default gen_random_uuid (),
    name text not null,
    price real not null,
    image text null,
    constraint products_pkey primary key (id)
  ) tablespace pg_default;
```

----------------------------------------

TITLE: Configure Supabase Realtime Private Channel in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates how to create a private real-time channel using the Supabase client. It highlights the use of the `config: { private: true }` option during channel creation, which is required for private channels and necessitates `@supabase/realtime-js` v2.44.0 or later.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/realtime/nextjs-authorization-demo/README.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
  const channel = supabase.channel('room-1', {
    config: { private: true },
  })
```

----------------------------------------

TITLE: PostgreSQL: Create `security definer` Function with `search_path`
DESCRIPTION: Demonstrates how to create a PostgreSQL function using `security definer`. It highlights the critical requirement of setting `search_path` to an empty string to prevent privilege escalation, emphasizing the need for explicit schema qualification for all relations within the function body.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/functions.mdx#_snippet_7

LANGUAGE: sql
CODE:
```
create function hello_world()
returns text
language plpgsql
security definer set search_path = ''
as $$
begin
  select 'hello world';
end;
$$;
```

----------------------------------------

TITLE: Initialize Local Supabase Project
DESCRIPTION: Initializes a new Supabase project in the current directory, prompting for local Supabase and PostgreSQL ports, and displaying generated URLs and keys for local development.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-03-31-supabase-cli.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
supabase init

# ✔ Port for Supabase URL: · 8000
# ✔ Port for PostgreSQL database: · 5432
# ✔ Project initialized.
# Supabase URL: http://localhost:8000
# Supabase Key (anon, public): eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJzdXBhYmFzZSIsImlhdCI6MTYwMzk2ODgzNCwiZXhwIjoyNTUwNjUzNjM0LCJyb2xlIjoiYW5vbiJ9.36fUebxgx1mcBo4s19v0SzqmzunP--hm_hep0uLX0ew
# Supabase Key (service_role, private): eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJzdXBhYmFzZSIsImlhdCI6MTYwMzk2ODgzNCwiZXhwIjoyNTUwNjUzNjM0LCJyb2xlIjoiYW5vbiJ9.36fUebxgx1mcBo4s19v0SzqmzunP--hm_hep0uLX0ew
# Database URL: postgres://postgres:postgres@localhost:5432/postgres
```

----------------------------------------

TITLE: Search Documents using Supabase Vector Store in LangChain (Node.js)
DESCRIPTION: This JavaScript code demonstrates how to initialize `SupabaseVectorStore` with `OpenAIEmbeddings` and perform a similarity search. It connects to Supabase using service role key and URL, then adds sample texts and metadata before querying for similar documents.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/langchain.mdx#_snippet_1

LANGUAGE: js
CODE:
```
import { SupabaseVectorStore } from 'langchain/vectorstores/supabase'
import { OpenAIEmbeddings } from 'langchain/embeddings/openai'
import { createClient } from '@supabase/supabase-js'

const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY
if (!supabaseKey) throw new Error(`Expected SUPABASE_SERVICE_ROLE_KEY`)

const url = process.env.SUPABASE_URL
if (!url) throw new Error(`Expected env var SUPABASE_URL`)

export const run = async () => {
  const client = createClient(url, supabaseKey)

  const vectorStore = await SupabaseVectorStore.fromTexts(
    ['Hello world', 'Bye bye', "What's this?"],
    [{ id: 2 }, { id: 1 }, { id: 3 }],
    new OpenAIEmbeddings(),
    {
      client,
      tableName: 'documents',
      queryName: 'match_documents',
    }
  )

  const resultOne = await vectorStore.similaritySearch('Hello world', 1)

  console.log(resultOne)
}
```

----------------------------------------

TITLE: SQL: Setting Up Custom Role for Monitoring auth.users Table
DESCRIPTION: SQL commands to create a dedicated `auth_auditor` role with no inheritance and grant it specific permissions (`SELECT`, `DELETE`) on the `auth.users` table. This custom role is then assigned to `pgaudit.role` for the `postgres` user, enabling object-mode logging to monitor read and delete operations on this sensitive table.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/extensions/pgaudit.mdx#_snippet_17

LANGUAGE: sql
CODE:
```
create role "auth_auditor" noinherit;

-- give role permission to observe relevant table events
grant select on auth.users to "auth_auditor";
grant delete on auth.users to "auth_auditor";

-- assign auth_auditor to pgaudit.role
alter role "postgres" set pgaudit.role to 'auth_auditor';
```

----------------------------------------

TITLE: Supabase Authenticated Client in Remix Action Function
DESCRIPTION: Action functions run on the server and respond to HTTP requests other than GET (e.g., POST, PUT, PATCH, DELETE). This snippet illustrates how to create an authenticated Supabase client using `createServerClient` with `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `Request`, and `Response` objects. It is essential to return the `response.headers` to ensure Supabase can manage user authentication sessions via cookies.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/remix.mdx#_snippet_4

LANGUAGE: JavaScript
CODE:
```
import { json } from '@remix-run/node' // change this import to whatever runtime you are using
import { createServerClient } from '@supabase/auth-helpers-remix'

export const action = async ({ request }) => {
  const response = new Response()

  const supabaseClient = createServerClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_ANON_KEY,
    { request, response }
  )

  const { data } = await supabaseClient.from('test').select('*')

  return json(
    { data },
    {
      headers: response.headers,
    }
  )
}
```

LANGUAGE: TypeScript
CODE:
```
import { json } from '@remix-run/node' // change this import to whatever runtime you are using
import { createServerClient } from '@supabase/auth-helpers-remix'

import type { ActionFunctionArgs } from '@remix-run/node' // change this import to whatever runtime you are using

export const action = async ({ request }: ActionFunctionArgs) => {
  const response = new Response()

  const supabaseClient = createServerClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_ANON_KEY!,
    { request, response }
  )

  const { data } = await supabaseClient.from('test').select('*')

  return json(
    { data },
    {
      headers: response.headers,
    }
  )
}
```

----------------------------------------

TITLE: Create RLS Policy for Owner-Only Updates (SQL)
DESCRIPTION: This SQL policy for PostgreSQL's Row Level Security (RLS) restricts `UPDATE` operations on the `posts` table. It ensures that only the user who created a post (identified by `auth.uid()`) can update it, effectively acting as a `WHERE` clause for all update queries.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/column-level-security.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create policy "Allow update for owners" on posts for
update
  using ((select auth.uid()) = user_id);
```

----------------------------------------

TITLE: Create a new table using SQL
DESCRIPTION: This SQL snippet demonstrates how to create a new table named 'movies' with three columns: 'id', 'name', and 'description'. The 'id' column is configured as a primary key with an auto-incrementing bigint type, while 'name' and 'description' are text types. This method allows for direct table creation via SQL queries.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/tables.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create table movies (
  id bigint generated by default as identity primary key,
  name text,
  description text
);
```

----------------------------------------

TITLE: Sign out from Supabase authentication session
DESCRIPTION: This snippet shows how to programmatically sign out a user from their current Supabase authentication session. The `signOut()` method removes the user's session from the browser and clears any related data stored locally.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-twitter.mdx#_snippet_1

LANGUAGE: javascript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('https://your-project-id.supabase.co', 'your-anon-key')

async function signOut() {
  const { error } = await supabase.auth.signOut()
}
```

LANGUAGE: flutter
CODE:
```
Future<void> signOut() async {
  await supabase.auth.signOut();
}
```

LANGUAGE: kotlin
CODE:
```
suspend fun signOut() {
	supabase.auth.signOut()
}
```

----------------------------------------

TITLE: Generate Hashed and Unhashed Nonce for Google and Supabase
DESCRIPTION: This JavaScript code demonstrates how to generate a cryptographically secure random nonce. It then calculates a SHA-256 hash of the nonce, which is required for the Google authentication request, while the original unhashed nonce is used for the `supabase.auth.signInWithIdToken()` method. This ensures consistency and security across both platforms.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-google.mdx#_snippet_8

LANGUAGE: js
CODE:
```
// Adapted from https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#converting_a_digest_to_a_hex_string

const nonce = btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(32))))
const encoder = new TextEncoder()
const encodedNonce = encoder.encode(nonce)
crypto.subtle.digest('SHA-256', encodedNonce).then((hashBuffer) => {
  const hashArray = Array.from(new Uint8Array(hashBuffer))
  const hashedNonce = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')
})

// Use 'hashedNonce' when making the authentication request to Google
// Use 'nonce' when invoking the supabase.auth.signInWithIdToken() method
```

----------------------------------------

TITLE: Flutter Supabase User Login Page Implementation
DESCRIPTION: This complete Flutter `LoginPage` handles user authentication by taking email and password inputs and signing in via Supabase. It manages loading states, disposes controllers, and provides error feedback using snack bars. Navigation away from this page is handled by an external authentication state listener.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-11-22-flutter-authorization-with-rls.mdx#_snippet_19

LANGUAGE: dart
CODE:
```
import 'package:flutter/material.dart';
import 'package:my_chat_app/utils/constants.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({Key? key}) : super(key: key);

  static Route<void> route() {
    return MaterialPageRoute(
        builder: (context) => const LoginPage());
  }

  @override
  _LoginPageState createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  bool _isLoading = false;
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  Future<void> _signIn() async {
    setState(() {
      _isLoading = true;
    });
    try {
      await supabase.auth.signInWithPassword(
        email: _emailController.text,
        password: _passwordController.text,
      );
    } on AuthException catch (error) {
      context.showErrorSnackBar(message: error.message);
    } catch (_) {
      context.showErrorSnackBar(
          message: unexpectedErrorMessage);
    }
    if (mounted) {
      setState(() {
        _isLoading = true;
      });
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Sign In')),
      body: ListView(
        padding: formPadding,
        children: [
          TextFormField(
            controller: _emailController,
            decoration:
                const InputDecoration(labelText: 'Email'),
            keyboardType: TextInputType.emailAddress,
          ),
          spacer,
          TextFormField(
            controller: _passwordController,
            decoration: const InputDecoration(
                labelText: 'Password'),
            obscureText: true,
          ),
          spacer,
          ElevatedButton(
            onPressed: _isLoading ? null : _signIn,
            child: const Text('Login'),
          ),
        ],
      ),
    );
  }
}
```

----------------------------------------

TITLE: Configure Supabase Environment Variables for SvelteKit
DESCRIPTION: Create a `.env.local` file in your SvelteKit project to securely store your Supabase project's URL and anonymous key, which are required for client initialization and API communication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/sveltekit.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
# Find these in your Supabase project settings https://supabase.com/dashboard/project/_/settings/api
PUBLIC_SUPABASE_URL=https://your-project.supabase.co
PUBLIC_SUPABASE_ANON_KEY=your-anon-key
```

----------------------------------------

TITLE: Initialize Supabase Client and Fetch Data in Swift
DESCRIPTION: This Swift code snippet demonstrates how to initialize the Supabase client using a URL and an anonymous key. It then defines a Decodable struct for 'Country' and shows how to fetch data from a 'countries' table using the Supabase Swift library's `from().select().execute().value` pattern.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-04-15-supabase-swift.mdx#_snippet_0

LANGUAGE: swift
CODE:
```
let url = URL(string: "...")!
let anonKey = "public-anon-key"
let client = SupabaseClient(supabaseURL: url, supabaseKey: anonKey)

struct Country: Decodable {
  let id: Int
  let name: String
}

let countries: [Country] = try await supabase.from("countries")
  .select()
  .execute()
  .value
```

----------------------------------------

TITLE: Supabase CLI Commands for Local Development and Migrations
DESCRIPTION: These commands are used with the Supabase CLI to manage local Postgres databases. `supabase start` initializes the entire Supabase stack locally, `supabase db reset` clears the local database, and `supabase db diff` captures changes into a database migration.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-12-13-supabase-branching.mdx#_snippet_0

LANGUAGE: CLI
CODE:
```
supabase start
supabase db reset
supabase db diff
```

----------------------------------------

TITLE: Initialize Supabase Client in TypeScript
DESCRIPTION: Sets up the Supabase client using the `createClient` function, leveraging environment variables for the Supabase URL and anonymous key. This client instance is used for all interactions with the Supabase backend.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-09-23-local-first-expo-legend-state.mdx#_snippet_4

LANGUAGE: ts
CODE:
```
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY
)
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: Sets up environment variables `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` in a `.env` file. These variables store the Supabase project URL and public anonymous key, essential for client-side API access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-react.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
VITE_SUPABASE_URL=YOUR_SUPABASE_URL
VITE_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
```

----------------------------------------

TITLE: Implement Task Management with Express.js Route Parameters
DESCRIPTION: This Express.js example demonstrates how to set up an Edge Function to handle CRUD operations (GET, POST, PATCH, DELETE) for tasks using route parameters. It shows how to capture `id` from the URL for specific task operations, utilizing `express.json()` for body parsing.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/routing.mdx#_snippet_5

LANGUAGE: TypeScript
CODE:
```
import express from 'npm:express@4.18.2'

const app = express();
app.use(express.json());

app.get('/tasks', async (req, res) => {
// return all tasks
});

app.post('/tasks', async (req, res) => {
// create a task
});

app.get('/tasks/:id', async (req, res) => {
const id = req.params.id
const task = {} // get task

res.json(task)
});

app.patch('/tasks/:id', async (req, res) => {
const id = req.params.id
// modify task
});

app.delete('/tasks/:id', async (req, res) => {
const id = req.params.id
// delete task
});
```

----------------------------------------

TITLE: Supabase Flutter: Automatic Auth State Persistence
DESCRIPTION: This snippet demonstrates the simplified authentication state persistence in Supabase Flutter SDK v1.0. Previously, developers needed to extend `SupabaseAuthState` or `SupabaseAuthRequiredState`. Now, initializing Supabase automatically handles state persistence, removing the need for these custom classes.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-02-supabase-flutter-sdk-1-developer-preview.mdx#_snippet_0

LANGUAGE: Dart
CODE:
```
// Before
await Supabase.initialize(
  url: 'SUPABASE_URL',
  anonKey: 'SUPABASE_ANON_KEY',
);
...

class AuthState<T extends StatefulWidget> extends SupabaseAuthState<T> {
  ...
}

// After
await Supabase.initialize(
  url: 'SUPABASE_URL',
  anonKey: 'SUPABASE_ANON_KEY',
);
```

----------------------------------------

TITLE: Supabase Edge Function: Generate and Store OpenAI Embeddings
DESCRIPTION: This TypeScript code implements a Supabase Edge Function designed to process embedding generation jobs. It initializes OpenAI and Postgres clients, defines Zod schemas for job validation, and exposes an HTTP POST endpoint. The function fetches content from a specified database table, generates embeddings using OpenAI's `text-embedding-3-small` model, and updates the corresponding database column. It includes robust error handling and job status reporting. Note: The provided code snippet for the final SQL update is incomplete.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/automatic-embeddings.mdx#_snippet_8

LANGUAGE: typescript
CODE:
```
// Setup type definitions for built-in Supabase Runtime APIs
import 'jsr:@supabase/functions-js/edge-runtime.d.ts'

// We'll use the OpenAI API to generate embeddings
import OpenAI from 'jsr:@openai/openai'

import { z } from 'npm:zod'

// We'll make a direct Postgres connection to update the document
import postgres from 'https://deno.land/x/postgresjs@v3.4.5/mod.js'

// Initialize OpenAI client
const openai = new OpenAI({
  // We'll need to manually set the `OPENAI_API_KEY` environment variable
  apiKey: Deno.env.get('OPENAI_API_KEY'),
})

// Initialize Postgres client
const sql = postgres(
  // `SUPABASE_DB_URL` is a built-in environment variable
  Deno.env.get('SUPABASE_DB_URL')!
)

const jobSchema = z.object({
  jobId: z.number(),
  id: z.number(),
  schema: z.string(),
  table: z.string(),
  contentFunction: z.string(),
  embeddingColumn: z.string(),
})

const failedJobSchema = jobSchema.extend({
  error: z.string(),
})

type Job = z.infer<typeof jobSchema>
type FailedJob = z.infer<typeof failedJobSchema>

type Row = {
  id: string
  content: unknown
}

const QUEUE_NAME = 'embedding_jobs'

// Listen for HTTP requests
Deno.serve(async (req) => {
  if (req.method !== 'POST') {
    return new Response('expected POST request', { status: 405 })
  }

  if (req.headers.get('content-type') !== 'application/json') {
    return new Response('expected json body', { status: 400 })
  }

  // Use Zod to parse and validate the request body
  const parseResult = z.array(jobSchema).safeParse(await req.json())

  if (parseResult.error) {
    return new Response(`invalid request body: ${parseResult.error.message}`, {
      status: 400,
    })
  }

  const pendingJobs = parseResult.data

  // Track jobs that completed successfully
  const completedJobs: Job[] = []

  // Track jobs that failed due to an error
  const failedJobs: FailedJob[] = []

  async function processJobs() {
    let currentJob: Job | undefined

    while ((currentJob = pendingJobs.shift()) !== undefined) {
      try {
        await processJob(currentJob)
        completedJobs.push(currentJob)
      } catch (error) {
        failedJobs.push({
          ...currentJob,
          error: error instanceof Error ? error.message : JSON.stringify(error),
        })
      }
    }
  }

  try {
    // Process jobs while listening for worker termination
    await Promise.race([processJobs(), catchUnload()])
  } catch (error) {
    // If the worker is terminating (e.g. wall clock limit reached),
    // add pending jobs to fail list with termination reason
    failedJobs.push(
      ...pendingJobs.map((job) => ({
        ...job,
        error: error instanceof Error ? error.message : JSON.stringify(error),
      }))
    )
  }

  // Log completed and failed jobs for traceability
  console.log('finished processing jobs:', {
    completedJobs: completedJobs.length,
    failedJobs: failedJobs.length,
  })

  return new Response(
    JSON.stringify({
      completedJobs,
      failedJobs,
    }),
    {
      // 200 OK response
      status: 200,

      // Custom headers to report job status
      headers: {
        'content-type': 'application/json',
        'x-completed-jobs': completedJobs.length.toString(),
        'x-failed-jobs': failedJobs.length.toString(),
      },
    }
  )
})

/**
 * Generates an embedding for the given text.
 */
async function generateEmbedding(text: string) {
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
  })
  const [data] = response.data

  if (!data) {
    throw new Error('failed to generate embedding')
  }

  return data.embedding
}

/**
 * Processes an embedding job.
 */
async function processJob(job: Job) {
  const { jobId, id, schema, table, contentFunction, embeddingColumn } = job

  // Fetch content for the schema/table/row combination
  const [row]: [Row] = await sql`
    select
      id,
      ${sql(contentFunction)}(t) as content
    from
      ${sql(schema)}.${sql(table)} t
    where
      id = ${id}
  `

  if (!row) {
    throw new Error(`row not found: ${schema}.${table}/${id}`)
  }

  if (typeof row.content !== 'string') {
    throw new Error(`invalid content - expected string: ${schema}.${table}/${id}`)
  }

  const embedding = await generateEmbedding(row.content)

  await sql`
    update
      ${sql(schema)}.${sql(table)}
    set
      ${sql(embeddingColumn)} = ${JSON.stringify(embedding)}
    where
      id = ${id}
  `

  await sql`
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: Sets up environment variables for Supabase project URL and anonymous key in a `.env.local` file, essential for connecting to your Supabase project.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
```

----------------------------------------

TITLE: Initialize Supabase Client for Next.js Environments
DESCRIPTION: These snippets demonstrate how to create Supabase client instances tailored for different Next.js environments: server-side, browser-side (components), and API routes. Each client uses environment variables for configuration, and the API route client includes custom cookie handling for authentication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/nextjs.mdx#_snippet_13

LANGUAGE: ts
CODE:
```
import { createServerClient } from '@supabase/ssr'

export function createClient() {
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )

  return supabase
}
```

LANGUAGE: ts
CODE:
```
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )

  return supabase
}
```

LANGUAGE: ts
CODE:
```
import { createServerClient, serializeCookieHeader } from '@supabase/ssr'
import { type NextApiRequest, type NextApiResponse } from 'next'

export default function createClient(req: NextApiRequest, res: NextApiResponse) {
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return Object.keys(req.cookies).map((name) => ({ name, value: req.cookies[name] || '' }))
        },
        setAll(cookiesToSet) {
          res.setHeader(
            'Set-Cookie',
            cookiesToSet.map(({ name, value, options }) =>
              serializeCookieHeader(name, value, options)
            )
          )
        }
      }
    }
  )

  return supabase
}
```

----------------------------------------

TITLE: Postgres RPC Function to Insert Location Data
DESCRIPTION: This SQL code defines a PostgreSQL stored procedure ('location_insert') that is called as an RPC from the Edge Function. It takes a timestamp, latitude, longitude, and user ID as input. Before inserting, it retrieves the 'event_id' from an active session for the given user and then inserts the location data, including a PostGIS 'st_point' geometry, into the 'public.locations' table.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-07-04-postgres-realtime-location-sharing-with-maplibre.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
CREATE OR REPLACE FUNCTION public.location_insert(_timestamp bigint, _lat double precision, _long double precision, _user_id bigint)
RETURNS void AS $$
declare active_event_id uuid;
begin
  select event_id into active_event_id from public.sessions where user_id = _user_id and status = 'ACTIVE'::session_status;

  INSERT INTO public.locations(event_id, user_id, created_at, lat, long, location)
  VALUES (active_event_id, _user_id, to_timestamp(_timestamp), _lat, _long, st_point(_long, _lat));
end;
$$ LANGUAGE plpgsql VOLATILE;
```

----------------------------------------

TITLE: SQL: Perform Semantic Search with RLS Enforcement
DESCRIPTION: Shows how to perform a semantic search (vector similarity search) on `document_sections`. The RLS policy remains active, ensuring that even similarity searches only return results accessible to the current user.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/rag-with-permissions.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
-- Perform inner product similarity based on a match_threshold
select *
from document_sections
where document_sections.embedding <#> embedding < -match_threshold
order by document_sections.embedding <#> embedding;
```

----------------------------------------

TITLE: Install Supabase.js as a Package
DESCRIPTION: Install the `@supabase/supabase-js` library using popular Node.js package managers like npm, Yarn, or pnpm.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/installing.mdx#_snippet_0

LANGUAGE: Shell
CODE:
```
npm install @supabase/supabase-js
```

LANGUAGE: Shell
CODE:
```
yarn add @supabase/supabase-js
```

LANGUAGE: Shell
CODE:
```
pnpm add @supabase/supabase-js
```

----------------------------------------

TITLE: Listening to Supabase Broadcast Changes on Client (JavaScript)
DESCRIPTION: This JavaScript snippet demonstrates how to subscribe to real-time broadcast events using the Supabase client library. It initializes the client, sets Realtime Authorization, creates a private channel for a specific topic (`topic:${gameId}`), and registers listeners for `INSERT`, `UPDATE`, and `DELETE` broadcast events, logging the payload for each.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/subscribing-to-database-changes.mdx#_snippet_3

LANGUAGE: js
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('your_project_url', 'your_supabase_api_key')

// ---cut---
const gameId = 'id'
await supabase.realtime.setAuth() // Needed for Realtime Authorization
const changes = supabase
  .channel(`topic:${gameId}`, {
    config: { private: true },
  })
  .on('broadcast', { event: 'INSERT' }, (payload) => console.log(payload))
  .on('broadcast', { event: 'UPDATE' }, (payload) => console.log(payload))
  .on('broadcast', { event: 'DELETE' }, (payload) => console.log(payload))
  .subscribe()
```

----------------------------------------

TITLE: Implement Supabase Authentication Form in React Native
DESCRIPTION: This snippet creates a basic login and registration form in `app/index.tsx` for a React Native app. It handles user input for email and password, and uses Supabase's `signInWithPassword` and `signUp` methods for authentication, displaying alerts for errors and a loading spinner.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-01-react-native-storage.mdx#_snippet_4

LANGUAGE: tsx
CODE:
```
import { Alert, View, Button, TextInput, StyleSheet, Text, TouchableOpacity } from 'react-native'
import { useState } from 'react'
import React from 'react'
import Spinner from 'react-native-loading-spinner-overlay'
import { supabase } from '../config/initSupabase'

const Login = () => {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)

  // Sign in with email and password
  const onSignInPress = async () => {
    setLoading(true)

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) Alert.alert(error.message)
    setLoading(false)
  }

  // Create a new user
  const onSignUpPress = async () => {
    setLoading(true)
    const { error } = await supabase.auth.signUp({
      email: email,
      password: password,
    })

    if (error) Alert.alert(error.message)
    setLoading(false)
  }

  return (
    <View style={styles.container}>
      <Spinner visible={loading} />

      <Text style={styles.header}>My Cloud</Text>

      <TextInput
        autoCapitalize="none"
        placeholder="john@doe.com"
        value={email}
        onChangeText={setEmail}
        style={styles.inputField}
      />
      <TextInput
        placeholder="password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={styles.inputField}
      />

      <TouchableOpacity onPress={onSignInPress} style={styles.button}>
        <Text style={{ color: '#fff' }}>Sign in</Text>
      </TouchableOpacity>
      <Button onPress={onSignUpPress} title="Create Account" color={'#fff'}></Button>
    </View>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 200,
    padding: 20,
    backgroundColor: '#151515',
  },
  header: {
    fontSize: 30,
    textAlign: 'center',
    margin: 50,
    color: '#fff',
  },
  inputField: {
    marginVertical: 4,
    height: 50,
    borderWidth: 1,
    borderColor: '#2b825b',
    borderRadius: 4,
    padding: 10,
    color: '#fff',
    backgroundColor: '#363636',
  },
  button: {
    marginVertical: 15,
    alignItems: 'center',
    backgroundColor: '#2b825b',
    padding: 12,
    borderRadius: 4,
  },
})

export default Login
```

----------------------------------------

TITLE: PostgreSQL: Function as a Trigger for `updated_at` Column
DESCRIPTION: Provides an example of a PostgreSQL function designed to be used as a trigger, automatically updating an `updated_at` timestamp column on row modification. It includes both the function definition and the `CREATE TRIGGER` statement to attach it to a table.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/database-functions.md#_snippet_2

LANGUAGE: sql
CODE:
```
create or replace function my_schema.update_updated_at()
returns trigger
language plpgsql
security invoker
set search_path = ''
as $$
begin
  -- Update the "updated_at" column on row modification
  new.updated_at := now();
  return new;
end;
$$;

create trigger update_updated_at_trigger
before update on my_schema.my_table
for each row
execute function my_schema.update_updated_at();
```

----------------------------------------

TITLE: Analyzing query plan and performance with EXPLAIN ANALYZE in PostgreSQL
DESCRIPTION: Illustrates how to use `EXPLAIN (ANALYZE)` to view both estimated and actual costs of a query plan. This command is crucial for understanding how PostgreSQL executes a query and for identifying performance bottlenecks, especially after adding or modifying indexes.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2021-02-27-cracking-postgres-interview.mdx#_snippet_2

LANGUAGE: SQL
CODE:
```
EXPLAIN (ANALYZE) SELECT *
FROM students
WHERE surname = 'Krobb';
```

----------------------------------------

TITLE: Initialize Supabase Client in JavaScript
DESCRIPTION: Creates `src/supabaseClient.js` to centralize Supabase client initialization. It imports `createClient` and uses the configured environment variables to establish a connection, then exports the `supabase` instance for use throughout the application.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-react.mdx#_snippet_3

LANGUAGE: js
CODE:
```
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

export const supabase = createClient(supabaseUrl, supabaseAnonKey)
```

----------------------------------------

TITLE: Configure Essential Supabase Environment Secrets in .env File
DESCRIPTION: Outlines critical environment variables in `./docker/.env` that must be updated from their defaults for a secure Supabase deployment. This includes `POSTGRES_PASSWORD`, `JWT_SECRET`, `SITE_URL`, SMTP credentials, and `POOLER_TENANT_ID`, all of which necessitate a service restart to take effect.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/self-hosting/docker.mdx#_snippet_12

LANGUAGE: APIDOC
CODE:
```
POSTGRES_PASSWORD: The password for the 'postgres' role.
JWT_SECRET: Used by PostgREST and GoTrue, among others.
SITE_URL: The base URL of your site.
SMTP_*: Mail server credentials (any SMTP server).
POOLER_TENANT_ID: The tenant-id used by Supavisor pooler for connection strings.
```

----------------------------------------

TITLE: Handling OAuth Callback and Session Exchange in Next.js
DESCRIPTION: This Next.js API route (app/auth/callback/route.ts) processes the OAuth callback. It extracts the authorization code from the URL, exchanges it for a user session using supabase.auth.exchangeCodeForSession, and then redirects the user to their intended destination or an error page. It also handles potential x-forwarded-host headers for production environments.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/oauth_pkce_flow.mdx#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { NextResponse } from 'next/server'
// The client you created from the Server-Side Auth instructions
import { createClient } from '@/utils/supabase/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  // if "next" is in param, use it as the redirect URL
  let next = searchParams.get('next') ?? '/'
  if (!next.startsWith('/')) {
    // if "next" is not a relative URL, use the default
    next = '/'
  }

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) {
      const forwardedHost = request.headers.get('x-forwarded-host') // original origin before load balancer
      const isLocalEnv = process.env.NODE_ENV === 'development'
      if (isLocalEnv) {
        // we can be sure that there is no load balancer in between, so no need to watch for X-Forwarded-Host
        return NextResponse.redirect(`${origin}${next}`)
      } else if (forwardedHost) {
        return NextResponse.redirect(`https://${forwardedHost}${next}`)
      } else {
        return NextResponse.redirect(`${origin}${next}`)
      }
    }
  }

  // return the user to an error page with instructions
  return NextResponse.redirect(`${origin}/auth/auth-code-error`)
}
```

----------------------------------------

TITLE: Creating a Basic Users Table with Integer Primary Key
DESCRIPTION: This SQL snippet demonstrates how to create a `users` table in PostgreSQL. It enables the `citext` extension for case-insensitive email addresses, defines an `id` column as an integer primary key, and includes `email` and `name` columns. A unique B-tree index is also created on the `email` column to enforce uniqueness.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-09-08-choosing-a-postgres-primary-key.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
-- Let's enable access to case-insensitive text
CREATE EXTENSION IF NOT EXISTS citext;

-- Heres a basic users table
CREATE TABLE users (
  id integer PRIMARY KEY,
  email citext NOT NULL CHECK (LENGTH(email) < 255),
  name text NOT NULL
);

-- Let's assume we don't want two users with the exact same email
CREATE UNIQUE INDEX users_email_uniq ON users USING BTREE (email);
```

----------------------------------------

TITLE: Create Supabase client utility functions for Next.js
DESCRIPTION: Provides utility functions to initialize Supabase clients for different execution environments. It includes a client for browser-side (Client Components) and a server-side client for Server Components, Server Actions, and Route Handlers, handling cookie management for user sessions.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/nextjs.mdx#_snippet_2

LANGUAGE: ts
CODE:
```
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

LANGUAGE: ts
CODE:
```
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        }
      }
    }
  )
}
```

----------------------------------------

TITLE: Fetch Data Client-Side in Next.js Client Components
DESCRIPTION: This snippet illustrates how to fetch data directly on the client side within a Next.js Client Component using `useQuery`. It includes handling loading and error states, demonstrating a common pattern for client-initiated data retrieval when server-side pre-fetching is not utilized or data is not found in the cache.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-01-12-react-query-nextjs-app-router-cache-helpers.mdx#_snippet_11

LANGUAGE: TSX
CODE:
```
'use client'

import useSupabaseBrowser from '@/utils/supabase-browser'
import { getCountryById } from '@/queries/get-country-by-id'
import { useQuery } from '@supabase-cache-helpers/postgrest-react-query'

export default function CountryPage({ params }: { params: { id: number } }) {
  const supabase = useSupabaseBrowser()
  const { data: country, isLoading, isError } = useQuery(getCountryById(supabase, params.id))

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (isError || !country) {
    return <div>Error</div>
  }

  return (
    <div>
      <h1>{country.name}</h1>
    </div>
  )
}
```

----------------------------------------

TITLE: Supabase Edge Function to Proxy Private Storage
DESCRIPTION: This TypeScript code defines a Supabase Edge Function (Deno) that acts as a proxy for a private Supabase Storage bucket. It enforces CORS policies by checking allowed origins and adds the necessary `SUPABASE_SERVICE_ROLE_KEY` to access files in the private bucket. It handles `OPTIONS` preflight requests and forwards `GET` requests to the storage API.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-06-19-self-host-maps-storage-protomaps.mdx#_snippet_2

LANGUAGE: ts
CODE:
```
const ALLOWED_ORIGINS = ['http://localhost:8000']
const corsHeaders = {
  'Access-Control-Allow-Origin': ALLOWED_ORIGINS.join(','),
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type, range, if-match',
  'Access-Control-Expose-Headers': 'range, accept-ranges, etag',
  'Access-Control-Max-Age': '300',
}

Deno.serve((req) => {
  // This is needed if you're planning to invoke your function from a browser.
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  // Check origin
  const origin = req.headers.get('Origin')

  if (!origin || !ALLOWED_ORIGINS.includes(origin)) {
    return new Response('Not Allowed', { status: 405 })
  }

  const reqUrl = new URL(req.url)
  const url = `${Deno.env.get('SUPABASE_URL')}/storage/v1/object/authenticated${reqUrl.pathname}`

  const { method, headers } = req
  // Add Auth header
  const modHeaders = new Headers(headers)
  modHeaders.append('authorization', `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!}`)
  return fetch(url, { method, headers: modHeaders })
})
```

----------------------------------------

TITLE: Flutter Supabase MFA Enrollment Page Implementation
DESCRIPTION: This Flutter StatefulWidget (`MFAEnrollPage`) manages the entire process of enrolling a user in Multi-Factor Authentication (MFA) using the Supabase Flutter SDK. It initiates the MFA enrollment, displays the generated QR code and secret key for TOTP setup, provides functionality to copy the secret, and includes an input field for the user to enter the verification code. Upon successful verification, the user's session is refreshed, and they are navigated to the home page. The snippet also incorporates robust error handling for Supabase authentication exceptions and other unexpected issues.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-05-04-flutter-multi-factor-authentication.mdx#_snippet_9

LANGUAGE: Dart
CODE:
```
import 'package:flutter_svg/flutter_svg.dart';
import 'package:go_router/go_router.dart';
import 'package:mfa_app/main.dart';
import 'package:mfa_app/pages/auth/register_page.dart';
import 'package:mfa_app/pages/home_page.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class MFAEnrollPage extends StatefulWidget {
  static const route = '/mfa/enroll';
  const MFAEnrollPage({super.key});

  @override
  State<MFAEnrollPage> createState() => _MFAEnrollPageState();
}

class _MFAEnrollPageState extends State<MFAEnrollPage> {
  final _enrollFuture = supabase.auth.mfa.enroll();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Setup MFA'),
        actions: [
          TextButton(
            onPressed: () {
              supabase.auth.signOut();
              context.go(RegisterPage.route);
            },
            child: Text(
              'Logout',
              style: TextStyle(color: Theme.of(context).colorScheme.onPrimary),
            ),
          ),
        ],
      ),
      body: FutureBuilder(
        future: _enrollFuture,
        builder: (context, snapshot) {
          if (snapshot.hasError) {
            return Center(child: Text(snapshot.error.toString()));
          }
          if (!snapshot.hasData) {
            return const Center(child: CircularProgressIndicator());
          }

          final response = snapshot.data!;
          final qrCodeUrl = response.totp.qrCode;
          final secret = response.totp.secret;
          final factorId = response.id;

          return ListView(
            padding: const EdgeInsets.symmetric(
              horizontal: 20,
              vertical: 24,
            ),
            children: [
              const Text(
                'Open your authentication app and add this app via QR code or by pasting the code below.',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 16),
              SvgPicture.string(
                qrCodeUrl,
                width: 150,
                height: 150,
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: Text(
                      secret,
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 18,
                      ),
                    ),
                  ),
                  IconButton(
                    onPressed: () {
                      Clipboard.setData(ClipboardData(text: secret));
                      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                          content: Text('Copied to your clip board')));
                    },
                    icon: const Icon(Icons.copy),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              const Text('Enter the code shown in your authentication app.'),
              const SizedBox(height: 16),
              TextFormField(
                decoration: const InputDecoration(
                  hintText: '000000',
                ),
                style: const TextStyle(fontSize: 24),
                textAlign: TextAlign.center,
                keyboardType: TextInputType.number,
                onChanged: (value) async {
                  if (value.length != 6) return;

                  // kick off the verification process once 6 characters are entered
                  try {
                    final challenge =
                        await supabase.auth.mfa.challenge(factorId: factorId);
                    await supabase.auth.mfa.verify(
                      factorId: factorId,
                      challengeId: challenge.id,
                      code: value,
                    );
                    await supabase.auth.refreshSession();
                    if (mounted) {
                      context.go(HomePage.route);
                    }
                  } on AuthException catch (error) {
                    ScaffoldMessenger.of(context)
                        .showSnackBar(SnackBar(content: Text(error.message)));
                  } catch (error) {
                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                        content: Text('Unexpected error occurred')));
                  }
                },
              ),
            ],
          );
        },
      ),
    );
  }
}
```

----------------------------------------

TITLE: Demonstrating PostgreSQL Permission Denied Error
DESCRIPTION: This snippet shows an attempt by a `junior_dev` user to execute the `add` function after its `EXECUTE` privilege was revoked from the `public` role. The resulting `ERROR: permission denied` message confirms that the privilege revocation was effective, preventing unauthorized function execution.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-04-11-postgres-roles-and-privileges.mdx#_snippet_46

LANGUAGE: sql
CODE:
```
# as junior_dev
postgres=> select add(1, 2);
```

LANGUAGE: console
CODE:
```
ERROR:  permission denied for function add
```

----------------------------------------

TITLE: Create Users via Supabase Admin API with SQL edge.exec
DESCRIPTION: This snippet demonstrates how to create new user accounts using the Supabase Admin API's `createUser` method. The JavaScript code is executed within a SQL `select edge.exec` statement, allowing server-side user management. It requires an email, password, and optionally user metadata.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-11-13-supabase-dynamic-functions.mdx#_snippet_14

LANGUAGE: SQL
CODE:
```
select edge.exec(
$js$

const { data, error } = await supabase.auth.admin.createUser({
  email: 'user@email.com',
  password: 'password',
  user_metadata: { name: 'Yoda' }
});

$js$));
```

----------------------------------------

TITLE: Implement Internationalized Email Templates with Postmark
DESCRIPTION: This JavaScript snippet provides a comprehensive framework for sending internationalized email templates using Postmark. It defines subject lines and HTML body templates for various email types (e.g., signup, recovery, invite) across multiple languages (English, Spanish, French), demonstrating a structured approach to multi-language content delivery.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/send-email-hook.mdx#_snippet_14

LANGUAGE: javascript
CODE:
```
import { Webhook } from 'https://esm.sh/standardwebhooks@1.0.0'
import { readAll } from 'https://deno.land/std/io/read_all.ts'

const postmarkEndpoint = 'https://api.postmarkapp.com/email'
// Replace this with your email
const FROM_EMAIL = 'myemail@gmail.com'

// Email Subjects
const subjects = {
  en: {
    signup: 'Confirm Your Email',
    recovery: 'Reset Your Password',
    invite: 'You have been invited',
    magic_link: 'Your Magic Link',
    email_change: 'Confirm Email Change',
    email_change_new: 'Confirm New Email Address',
    reauthentication: 'Confirm Reauthentication',
  },
  es: {
    signup: 'Confirma tu correo electrónico',
    recovery: 'Restablece tu contraseña',
    invite: 'Has sido invitado',
    magic_link: 'Tu enlace mágico',
    email_change: 'Confirma el cambio de correo electrónico',
    email_change_new: 'Confirma la Nueva Dirección de Correo',
    reauthentication: 'Confirma la reautenticación',
  },
  fr: {
    signup: 'Confirmez votre adresse e-mail',
    recovery: 'Réinitialisez votre mot de passe',
    invite: 'Vous avez été invité',
    magic_link: 'Votre Lien Magique',
    email_change: 'Confirmez le changement d’adresse e-mail',
    email_change_new: 'Confirmez la nouvelle adresse e-mail',
    reauthentication: 'Confirmez la réauthentification',
  },
}

// HTML Body
const templates = {
  en: {
    signup: `<h2>Confirm your email</h2><p>Follow this link to confirm your email:</p><p><a href="{{confirmation_url}}">Confirm your email address</a></p><p>Alternatively, enter the code: {{token}}</p>`,
    recovery: `<h2>Reset password</h2><p>Follow this link to reset the password for your user:</p><p><a href="{{confirmation_url}}">Reset password</a></p><p>Alternatively, enter the code: {{token}}</p>`,
    invite: `<h2>You have been invited</h2><p>You have been invited to create a user on {{site_url}}. Follow this link to accept the invite:</p><p><a href="{{confirmation_url}}">Accept the invite</a></p><p>Alternatively, enter the code: {{token}}</p>`,
    magic_link: `<h2>Magic Link</h2><p>Follow this link to login:</p><p><a href="{{confirmation_url}}">Log In</a></p><p>Alternatively, enter the code: {{token}}</p>`,
    email_change: `<h2>Confirm email address change</h2><p>Follow this link to confirm the update of your email address from {{old_email}} to {{new_email}}:</p><p><a href="{{confirmation_url}}">Change email address</a></p><p>Alternatively, enter the codes: {{token}} and {{new_token}}</p>`,
    email_change_new: `<h2>Confirm New Email Address</h2><p>Follow this link to confirm your new email address:</p><p><a href="{{confirmation_url}}">Confirm new email address</a></p><p>Alternatively, enter the code: {{new_token}}</p>`,
    reauthentication: `<h2>Confirm reauthentication</h2><p>Enter the code: {{token}}</p>`,
  },
  es: {
    signup: `<h2>Confirma tu correo electrónico</h2><p>Sigue este enlace para confirmar tu correo electrónico:</p><p><a href="{{confirmation_url}}">Confirma tu correo electrónico</a></p><p>Alternativamente, ingresa el código: {{token}}</p>`
  }
}
```

----------------------------------------

TITLE: Implement Apple Sign-In with Expo and Supabase
DESCRIPTION: This TypeScript React Native component demonstrates how to integrate Apple Sign-In using `expo-apple-authentication` and `supabase-js`. It handles the authentication flow, including requesting user scopes, obtaining the identity token, and signing in with Supabase Auth. Error handling for user cancellation and other issues is also included.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-apple.mdx#_snippet_5

LANGUAGE: tsx
CODE:
```
import { Platform } from 'react-native'
import * as AppleAuthentication from 'expo-apple-authentication'
import { supabase } from 'app/utils/supabase'

export function Auth() {
  if (Platform.OS === 'ios')
    return (
      <AppleAuthentication.AppleAuthenticationButton
        buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
        buttonStyle={AppleAuthentication.AppleAuthenticationButtonStyle.BLACK}
        cornerRadius={5}
        style={{ width: 200, height: 64 }}
        onPress={async () => {
          try {
            const credential = await AppleAuthentication.signInAsync({
              requestedScopes: [
                AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
                AppleAuthentication.AppleAuthenticationScope.EMAIL,
              ],
            })
            // Sign in via Supabase Auth.
            if (credential.identityToken) {
              const {
                error,
                data: { user },
              } = await supabase.auth.signInWithIdToken({
                provider: 'apple',
                token: credential.identityToken,
              })
              console.log(JSON.stringify({ error, user }, null, 2))
              if (!error) {
                // User is signed in.
              }
            } else {
              throw new Error('No identityToken.')
            }
          } catch (e) {
            if (e.code === 'ERR_REQUEST_CANCELED') {
              // handle that the user canceled the sign-in flow
            } else {
              // handle other errors
            }
          }
        }}
      />
    )
  return <>{/* Implement Android Auth options. */}</>
}
```

----------------------------------------

TITLE: Creating Partitioned Parent Tables in PostgreSQL
DESCRIPTION: This SQL snippet defines the schema for `app.chats` and `app.chat_messages` tables, designed for range partitioning by `created_at`. Both tables utilize composite primary keys, including the `created_at` column, which is crucial for efficient partitioning. It also includes a composite foreign key from `chat_messages` to `chats` and necessary indexes to optimize lookups, addressing the structural requirements for partitioned tables.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-10-03-postgres-dynamic-table-partitioning.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
BEGIN;
CREATE SCHEMA app;

CREATE TABLE app.chats(
    id bigserial,
    created_at timestamptz NOT NULL DEFAULT now(),
    PRIMARY KEY (id, created_at)  -- the partition column must be part of pk
    ) PARTITION BY RANGE (created_at);

CREATE INDEX "chats_created_at" ON app.chats (created_at);

CREATE TABLE app.chat_messages(
    id bigserial,
    created_at timestamptz NOT NULL,
    chat_id bigint NOT NULL,
    chat_created_at timestamptz NOT NULL,
    message text NOT NULL,
    PRIMARY KEY (id, created_at),
    FOREIGN KEY (chat_id, chat_created_at)   -- multicolumn fk to ensure
        REFERENCES app.chats(id, created_at)
    ) PARTITION BY RANGE (created_at);

CREATE INDEX "chat_messages_created_at" ON app.chat_messages (created_at);
--
-- need this index on the fk source to lookup messages by parent
--
CREATE INDEX "chat_messages_chat_id_chat_created_at"
    ON app.chat_messages (chat_id, chat_created_at);
```

----------------------------------------

TITLE: Return rows after data manipulation (insert, upsert, update, delete)
DESCRIPTION: Demonstrates how to explicitly return rows after performing data manipulation operations like `insert()`, `upsert()`, `update()`, or `delete()`. Previously, rows were returned by default; now, a `.select()` call is required to retrieve them.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/v1/upgrade-guide.mdx#_snippet_12

LANGUAGE: ts
CODE:
```
// To return rows with the new behavior
const { data, error } = await supabase.from('countries').insert({ name: 'France' }).select()
```

----------------------------------------

TITLE: Deno HTTP Server with Kysely and Postgres Query
DESCRIPTION: This snippet demonstrates how to create a Deno HTTP server that connects to a PostgreSQL database using the Kysely ORM. It sets up a database connection pool, defines table interfaces, initializes Kysely with a custom Deno Postgres driver, and executes a select query on incoming HTTP requests, returning the results as JSON.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/kysely-postgres.mdx#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { serve } from 'https://deno.land/std@0.175.0/http/server.ts'
import { Pool } from 'https://deno.land/x/postgres@v0.17.0/mod.ts'
import {
  Kysely,
  Generated,
  PostgresAdapter,
  PostgresIntrospector,
  PostgresQueryCompiler,
} from 'https://esm.sh/kysely@0.23.4'
import { PostgresDriver } from './DenoPostgresDriver.ts'

console.log(`Function "kysely-postgres" up and running!`)

interface AnimalTable {
  id: Generated<bigint>
  animal: string
  created_at: Date
}

// Keys of this interface are table names.
interface Database {
  animals: AnimalTable
}

// Create a database pool with one connection.
const pool = new Pool(
  {
    tls: { caCertificates: [Deno.env.get('DB_SSL_CERT')!] },
    database: 'postgres',
    hostname: Deno.env.get('DB_HOSTNAME'),
    user: 'postgres',
    port: 5432,
    password: Deno.env.get('DB_PASSWORD'),
  },
  1
)

// You'd create one of these when you start your app.
const db = new Kysely<Database>({
  dialect: {
    createAdapter() {
      return new PostgresAdapter()
    },
    createDriver() {
      return new PostgresDriver({ pool })
    },
    createIntrospector(db: Kysely<unknown>) {
      return new PostgresIntrospector(db)
    },
    createQueryCompiler() {
      return new PostgresQueryCompiler()
    },
  },
})

serve(async (_req) => {
  try {
    // Run a query
    const animals = await db.selectFrom('animals').select(['id', 'animal', 'created_at']).execute()

    // Neat, it's properly typed \o/
    console.log(animals[0].created_at.getFullYear())

    // Encode the result as pretty printed JSON
    const body = JSON.stringify(
      animals,
      (key, value) => (typeof value === 'bigint' ? value.toString() : value),
      2
    )

    // Return the response with the correct content type header
    return new Response(body, {
      status: 200,
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
      },
    })
  } catch (err) {
    console.error(err)
    return new Response(String(err?.message ?? err), { status: 500 })
  }
})
```

----------------------------------------

TITLE: Flutter Supabase User Registration and Auth State Listener
DESCRIPTION: This Dart code snippet implements a `RegisterPage` in Flutter that integrates with Supabase for user registration. It demonstrates how to listen to Supabase's `onAuthStateChange` stream to handle user redirection, specifically waiting for email confirmation before navigating to the main application page. It also includes the `_signUp` method for user registration and form validation.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-11-22-flutter-authorization-with-rls.mdx#_snippet_17

LANGUAGE: Dart
CODE:
```
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:my_chat_app/pages/login_page.dart';
import 'package:my_chat_app/pages/rooms_page.dart';
import 'package:my_chat_app/utils/constants.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class RegisterPage extends StatefulWidget {
  const RegisterPage(
      {Key? key, required this.isRegistering})
      : super(key: key);

  static Route<void> route({bool isRegistering = false}) {
    return MaterialPageRoute(
      builder: (context) =>
          RegisterPage(isRegistering: isRegistering),
    );
  }

  final bool isRegistering;

  @override
  State<RegisterPage> createState() => _RegisterPageState();
}

class _RegisterPageState extends State<RegisterPage> {
  final bool _isLoading = false;

  final _formKey = GlobalKey<FormState>();

  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _usernameController = TextEditingController();

  late final StreamSubscription<AuthState>
      _authSubscription;

  @override
  void initState() {
    super.initState();

    bool haveNavigated = false;
    // Listen to auth state to redirect user when the user clicks on confirmation link
    _authSubscription =
        supabase.auth.onAuthStateChange.listen((data) {
      final session = data.session;
      if (session != null && !haveNavigated) {
        haveNavigated = true;
        Navigator.of(context)
            .pushReplacement(RoomsPage.route());
      }
    });
  }

  @override
  void dispose() {
    super.dispose();

    // Dispose subscription when no longer needed
    _authSubscription.cancel();
  }

  Future<void> _signUp() async {
    final isValid = _formKey.currentState!.validate();
    if (!isValid) {
      return;
    }
    final email = _emailController.text;
    final password = _passwordController.text;
    final username = _usernameController.text;
    try {
      await supabase.auth.signUp(
        email: email,
        password: password,
        data: {'username': username},
        emailRedirectTo: 'io.supabase.chat://login',
      );
      context.showSnackBar(
          message:
              'Please check your inbox for confirmation email.');
    } on AuthException catch (error) {
      context.showErrorSnackBar(message: error.message);
    } catch (error) {
      debugPrint(error.toString());
      context.showErrorSnackBar(
          message: unexpectedErrorMessage);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Register'),
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: formPadding,
          children: [
            TextFormField(
              controller: _emailController,
              decoration: const InputDecoration(
                label: Text('Email'),
              ),
              validator: (val) {
                if (val == null || val.isEmpty) {
                  return 'Required';
                }
                return null;
              },
              keyboardType: TextInputType.emailAddress,
            ),
            spacer,
            TextFormField(
              controller: _passwordController,
              obscureText: true,
              decoration: const InputDecoration(
                label: Text('Password'),
              ),
              validator: (val) {
                if (val == null || val.isEmpty) {
                  return 'Required';
                }
                if (val.length < 6) {
                  return '6 characters minimum';
                }
                return null;
              },
            ),
            spacer,
            TextFormField(
              controller: _usernameController,
              decoration: const InputDecoration(
                label: Text('Username'),
              ),
              validator: (val) {
                if (val == null || val.isEmpty) {
                  return 'Required';
                }
                final isValid =
                    RegExp(r'^[A-Za-z0-9_]{3,24}$')
                        .hasMatch(val);
                if (!isValid) {
                  return '3-24 long with alphanumeric or underscore';
                }

```

----------------------------------------

TITLE: Observe PostgreSQL Database Connections with pg_stat_activity
DESCRIPTION: This SQL query retrieves detailed information about active and idle connections to your PostgreSQL database, including process ID, SSL usage, database name, connected role, application name, client IP, last executed query, query start time, connection state, and backend start time. It's useful for identifying connection sources and their states.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/monitor-supavisor-postgres-connections.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
SELECT
   pg_stat_activity.pid,
   ssl AS ssl_connection,
   datname AS database,
   usename AS connected_role,
   application_name,
   client_addr,
   query,
   query_start,
   state,
   backend_start
FROM pg_stat_ssl
JOIN pg_stat_activity
 ON pg_stat_ssl.pid = pg_stat_activity.pid;
```

----------------------------------------

TITLE: Define Supabase Tables, Replica Identity, and User Boards Function (SQL)
DESCRIPTION: This SQL snippet defines the schema for `boards`, `lists`, `cards`, `users`, and `user_boards` tables in a Supabase Postgres database. It also sets `replica identity full` for `cards` and `lists` to enable realtime updates on deleted rows, and creates a `get_boards_for_authenticated_user` function to retrieve board IDs associated with the authenticated user, which is crucial for Row Level Security.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-24-building-a-realtime-trello-board-with-supabase-and-angular.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
drop table if exists user_boards;
drop table if exists cards;
drop table if exists lists;
drop table if exists boards;
drop table if exists users;

-- Create boards table
create table boards (
  id bigint generated by default as identity primary key,
  creator uuid references auth.users not null default auth.uid(),
  title text default 'Untitled Board',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create lists table
create table lists (
  id bigint generated by default as identity primary key,
  board_id bigint references boards ON DELETE CASCADE not null,
  title text default '',
  position int not null default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create Cards table
create table cards (
  id bigint generated by default as identity primary key,
  list_id bigint references lists ON DELETE CASCADE not null,
  board_id bigint references boards ON DELETE CASCADE not null,
  position int not null default 0,
  title text default '',
  description text check (char_length(description) > 0),
  assigned_to uuid references auth.users,
  done boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Many to many table for user <-> boards relationship
create table user_boards (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users ON DELETE CASCADE not null default auth.uid(),
  board_id bigint references boards ON DELETE CASCADE
);

-- User ID lookup table
create table users (
  id uuid not null primary key,
  email text
);

-- Make sure deleted records are included in realtime
alter table cards replica identity full;
alter table lists replica identity full;

-- Function to get all user boards
create or replace function get_boards_for_authenticated_user()
returns setof bigint
language sql
security definer
set search_path = ''
stable
as $$
    select board_id
    from public.user_boards
    where user_id = auth.uid()
$$;
```

----------------------------------------

TITLE: Create Index for ORDER BY Clause
DESCRIPTION: This SQL command creates an index on the 'date_of_purchase' column in the 'orders' table. An index on an 'ORDER BY' column can significantly optimize sorting operations, particularly when a query includes a 'LIMIT' clause, as it allows the database to retrieve sorted data more efficiently.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/query-optimization.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create index idx_orders_date_of_purchase on orders (date_of_purchase);
```

----------------------------------------

TITLE: Generating TypeScript Types for Remote Project
DESCRIPTION: Generates TypeScript type definitions for a remote Supabase project, outputting them to `database.types.ts`. This command requires a project ID and specifies the database schema (e.g., `public`) from which to generate types.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/api/rest/generating-types.mdx#_snippet_3

LANGUAGE: bash
CODE:
```
npx supabase gen types typescript --project-id "$PROJECT_REF" --schema public > database.types.ts
```

----------------------------------------

TITLE: Link Supabase Project and Pull Database Schema Locally
DESCRIPTION: These commands link your local Supabase CLI to a remote project using its reference ID, which can be found in the project's dashboard URL. After linking, the 'db pull' command synchronizes the remote database schema to your local environment, facilitating local development.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/project_setup.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
supabase link --project-ref <project-id>
# You can get <project-id> from your project's dashboard URL: https://supabase.com/dashboard/project/<project-id>
supabase db pull
```

----------------------------------------

TITLE: Set up Supabase Client for Server-Side in SvelteKit
DESCRIPTION: This snippet demonstrates how to configure the Supabase client for server-side operations in SvelteKit. It shows the setup for both older (0.8.x) and newer (0.9.0) versions, highlighting the shift from `src/lib/db.ts` to `src/hooks.server.ts` and the introduction of `safeGetSession` for JWT validation.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/sveltekit.mdx#_snippet_17

LANGUAGE: javascript
CODE:
```
// src/lib/db.ts
import { createClient } from '@supabase/auth-helpers-sveltekit'
import { env } from '$env/dynamic/public'
// or use the static env

// import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public';

export const supabaseClient = createClient(env.PUBLIC_SUPABASE_URL, env.PUBLIC_SUPABASE_ANON_KEY)
```

LANGUAGE: typescript
CODE:
```
// src/hooks.server.ts
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public'
import { createSupabaseServerClient } from '@supabase/auth-helpers-sveltekit'
import type { Handle } from '@sveltejs/kit'

export const handle: Handle = async ({ event, resolve }) => {
  event.locals.supabase = createSupabaseServerClient({
    supabaseUrl: PUBLIC_SUPABASE_URL,
    supabaseKey: PUBLIC_SUPABASE_ANON_KEY,
    event,
  })

  /**
   * Unlike `supabase.auth.getSession`, which is unsafe on the server because it
   * doesn't validate the JWT, this function validates the JWT by first calling
   * `getUser` and aborts early if the JWT signature is invalid.
   */
  event.locals.safeGetSession = async () => {
    const {
      data: { user },
      error,
    } = await event.locals.supabase.auth.getUser()
    if (error) return { session: null, user: null }

    const {
      data: { session },
    } = await event.locals.supabase.auth.getSession()
    return { session, user }
  }

  return resolve(event, {
    filterSerializedResponseHeaders(name) {
      return name === 'content-range' || name === 'x-supabase-api-version'
    },
  })
}
```

----------------------------------------

TITLE: Configure Supabase environment variables for SSR
DESCRIPTION: Set your Supabase project URL and anonymous key as environment variables, adapting to the specific naming conventions required by different JavaScript frameworks and environments for SSR.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/creating-a-client.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

LANGUAGE: bash
CODE:
```
PUBLIC_SUPABASE_URL=your_supabase_project_url
PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

LANGUAGE: bash
CODE:
```
PUBLIC_SUPABASE_URL=your_supabase_project_url
PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

LANGUAGE: bash
CODE:
```
SUPABASE_URL=your_supabase_project_url
SUPABASE_ANON_KEY=your_supabase_anon_key
```

LANGUAGE: bash
CODE:
```
SUPABASE_URL=your_supabase_project_url
SUPABASE_ANON_KEY=your_supabase_anon_key
```

LANGUAGE: bash
CODE:
```
SUPABASE_URL=your_supabase_project_url
SUPABASE_ANON_KEY=your_supabase_anon_key
```

----------------------------------------

TITLE: Supabase Auth: Enforcing Row Level Security with SQL Policy
DESCRIPTION: This SQL policy demonstrates how Supabase Auth leverages PostgreSQL's Row Level Security (RLS) to restrict data access. It ensures that users can only view documents where their 'user_id' matches the authenticated user's UID, providing robust database-level authorization.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_alternatives/supabase-vs-auth0.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create policy "Users can only view their own documents."
on docs for select
using ( (select auth.uid()) = user_id );
```

----------------------------------------

TITLE: Install Supabase Auth UI and Client Libraries
DESCRIPTION: Instructions to install the necessary npm packages for integrating Supabase Auth UI into a React project, including `@supabase/supabase-js` for client interaction, `@supabase/auth-ui-react` for the UI component, and `@supabase/auth-ui-shared` for shared utilities and themes.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/auth-ui.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
npm install @supabase/supabase-js @supabase/auth-ui-react @supabase/auth-ui-shared
```

----------------------------------------

TITLE: Add Supabase Flutter dependency
DESCRIPTION: Configuration to add the `supabase_flutter` package to your `pubspec.yaml` file, specifying version `^2.0.0`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-flutter.mdx#_snippet_1

LANGUAGE: yaml
CODE:
```
supabase_flutter: ^2.0.0
```

----------------------------------------

TITLE: Initialize a new Flutter project
DESCRIPTION: Command to create a new Flutter application named `supabase_quickstart` from the command line.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-flutter.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
flutter create supabase_quickstart
```

----------------------------------------

TITLE: Granting Table Permissions in Custom API Schema (SQL)
DESCRIPTION: These SQL statements demonstrate how to grant specific data manipulation permissions on tables within the `api` schema. For example, `anon` users might get `SELECT` access, while `authenticated` users receive `SELECT`, `INSERT`, `UPDATE`, and `DELETE` privileges, ensuring granular control over data access via the Data API.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/hardening-data-api.mdx#_snippet_2

LANGUAGE: SQL
CODE:
```
grant select on table api.<your_table> to anon;
grant select, insert, update, delete on table api.<your_table> to authenticated;
```

----------------------------------------

TITLE: Loading Paginated Data with Supabase `range` in React
DESCRIPTION: This React component illustrates how to implement client-side pagination using Supabase's `range` method. It manages `offset` and `isLoading` states, fetches data in chunks (`PAGE_COUNT`), and merges new tickets with previously loaded ones. The `fetchTickets` function demonstrates the Supabase query with `select`, `range`, and `order`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-04-04-infinite-scroll-with-nextjs-framer-motion.mdx#_snippet_4

LANGUAGE: jsx
CODE:
```
export default function TicketsPage() {
  const PAGE_COUNT = 20
  const [offset, setOffset] = useState(1)
  const [isLoading, setIsLoading] = useState(false)
  const [isInView, setIsInView] = useState(false)

  useEffect(() => {
    if (isInView) {
      loadMoreTickets(offset)
    }
  }, [isInView])

  const loadMoreTickets = async (offset: number) => {
    setIsLoading(true)
    // Every time we fetch, we want to increase
    // the offset to load fresh tickets
    setOffset((prev) => prev + 1)
    const { data: newTickets } = await fetchTickets(offset, PAGE_COUNT)
    // Merge new tickets with all previously loaded
    setLoadedTickets((prevTickets) => [...prevTickets, ...newTickets])
    setIsLoading(false)
  }

  const fetchTickets = async (offset, limit) => {
    const from = offset * PAGE_COUNT
    const to = from + PAGE_COUNT - 1

    const { data } = await supabase!
        .from('my_tickets_table')
        .select('*')
        .range(from, to)
        .order('createdAt', { ascending: false })


    return data
  }
}
```

----------------------------------------

TITLE: Install Supabase JavaScript client
DESCRIPTION: Install the official Supabase JavaScript client library using npm, which is required to interact with your Supabase project.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/realtime/postgres-changes.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
npm install @supabase/supabase-js
```

----------------------------------------

TITLE: Install the Supabase client library
DESCRIPTION: The fastest way to get started is to use the `supabase-js` client library which provides a convenient interface for working with Supabase from a SolidJS app.

Navigate to the SolidJS app and install `supabase-js`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/quickstarts/solidjs.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
cd my-app && npm install @supabase/supabase-js
```

----------------------------------------

TITLE: Create instruments table and insert sample data (SQL)
DESCRIPTION: This SQL snippet creates an 'instruments' table with 'id' and 'name' columns, inserts sample data ('violin', 'viola', 'cello'), and enables row-level security on the table. It can be run in Supabase's SQL Editor.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/_partials/quickstart_db_setup.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
-- Create the table
create table instruments (
  id bigint primary key generated always as identity,
  name text not null
);
-- Insert some sample data into the table
insert into instruments (name)
values
  ('violin'),
  ('viola'),
  ('cello');

alter table instruments enable row level security;
```

----------------------------------------

TITLE: Migrating PostgreSQL Role Passwords to SCRAM-SHA-256 (SQL)
DESCRIPTION: These SQL statements are used after a Supabase upgrade to identify PostgreSQL roles that still utilize the deprecated MD5 hashing method and to migrate their passwords to the more secure SCRAM-SHA-256 authentication method. This ensures that custom roles can continue to connect to the database post-upgrade.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/platform/upgrading.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
-- List roles using md5 hashing method
SELECT
  rolname
FROM pg_authid
WHERE rolcanlogin = true
  AND rolpassword LIKE 'md5%';

-- Migrate a role's password to scram-sha-256
ALTER ROLE <role_name> WITH PASSWORD '<password>';
```

----------------------------------------

TITLE: Create SQL Function for Password Verification Hook with Rate Limiting
DESCRIPTION: SQL PL/pgSQL function `public.hook_password_verification_attempt` that implements rate limiting for password verification. It checks if a password is valid, and if not, queries the `password_failed_verification_attempts` table to determine if the user has attempted too quickly, returning a rejection with HTTP 429 if so.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/password-verification-hook.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
create function public.hook_password_verification_attempt(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    last_failed_at timestamp;
  begin
    if event->'valid' is true then
      -- password is valid, accept it
      return jsonb_build_object('decision', 'continue');
    end if;

    select last_failed_at into last_failed_at
      from public.password_failed_verification_attempts
      where
        user_id = event->'user_id';

    if last_failed_at is not null and now() - last_failed_at < interval '10 seconds' then
      -- last attempt was done too quickly
      return jsonb_build_object(
        'error', jsonb_build_object(
          'http_code', 429,
```

----------------------------------------

TITLE: Supabase Postgres Row Level Security and Storage Setup
DESCRIPTION: This SQL script defines the `profiles` table, enabling row-level security policies to control access: public viewability, and allowing users to insert and update only their own profiles. It also configures Realtime for the `profiles` table and sets up a storage bucket named 'avatars' with public access policies for image uploads.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/react-user-management/README.md#_snippet_1

LANGUAGE: SQL
CODE:
```
-- Create a table for Public Profiles
create table
  profiles (
    id uuid references auth.users not null,
    updated_at timestamp
    with
      time zone,
      username text unique,
      avatar_url text,
      website text,
      primary key (id),
      unique (username),
      constraint username_length check (char_length(username) >= 3)
  );

alter table
  profiles enable row level security;

create policy "Public profiles are viewable by everyone." on profiles for
select
  using (true);

create policy "Users can insert their own profile." on profiles for insert
with
  check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles for
update
  using ((select auth.uid()) = id);

-- Set up Realtime!
begin;

drop
  publication if exists supabase_realtime;

create publication supabase_realtime;

commit;

alter
  publication supabase_realtime add table profiles;

-- Set up Storage!
insert into
  storage.buckets (id, name)
values
  ('avatars', 'avatars');

create policy "Avatar images are publicly accessible." on storage.objects for
select
  using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects for insert
with
  check (bucket_id = 'avatars');
```

----------------------------------------

TITLE: Configure Supabase Row Level Security Policies (SQL)
DESCRIPTION: SQL script to enable Row Level Security (RLS) on `users`, `groups`, and `messages` tables and define policies for read, insert, and delete operations, differentiating between authenticated and unauthenticated access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-11-08-authentication-in-ionic-angular.mdx#_snippet_1

LANGUAGE: SQL
CODE:
```
-- Secure tables
alter table users enable row level security;
alter table groups enable row level security;
alter table messages enable row level security;

-- User Policies
create policy "Users can read the user email." on users
  for select using (true);

-- Group Policies
create policy "Groups are viewable by everyone." on groups
  for select using (true);

create policy "Authenticated users can create groups." on groups for
  insert to authenticated with check (true);

create policy "The owner can delete a group." on groups for
    delete using ((select auth.uid()) = creator);

-- Message Policies
create policy "Authenticated users can read messages." on messages
  for select to authenticated using (true);

create policy "Authenticated users can create messages." on messages
  for insert to authenticated with check (true);
```

----------------------------------------

TITLE: Applying RLS Policies with `authorize` Function in PostgreSQL
DESCRIPTION: These SQL statements define RLS policies for `public.channels` and `public.messages` tables, allowing authenticated users to perform delete operations. The policies leverage the `public.authorize` function to ensure that the user's role has the specific `channels.delete` or `messages.delete` permission before allowing the action.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_5

LANGUAGE: sql
CODE:
```
create policy "Allow authorized delete access" on public.channels for delete to authenticated using ( (SELECT authorize('channels.delete')) );
create policy "Allow authorized delete access" on public.messages for delete to authenticated using ( (SELECT authorize('messages.delete')) );
```

----------------------------------------

TITLE: Serve Supabase Edge Functions Locally
DESCRIPTION: After the Supabase server is running, use this command to start a dedicated local server for your Edge Functions. This enables you to test and debug them in isolation within your development environment.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/unit-test.mdx#_snippet_3

LANGUAGE: bash
CODE:
```
supabase functions serve
```

----------------------------------------

TITLE: Protect API Routes with Supabase Server Client in Next.js
DESCRIPTION: This snippet demonstrates how to create a server-side Supabase client within a Next.js API route to check for an authenticated user session. If no user is found, it returns a 401 error; otherwise, it proceeds to query data with Row Level Security (RLS).
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_11

LANGUAGE: JavaScript
CODE:
```
import { createPagesServerClient } from '@supabase/auth-helpers-nextjs'

const ProtectedRoute = async (req, res) => {
  // Create authenticated Supabase Client
  const supabase = createPagesServerClient({ req, res })
  // Check if we have a user
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user)
    return res.status(401).json({
      error: 'not_authenticated',
      description: 'The user does not have an active session or is not authenticated',
    })

  // Run queries with RLS on the server
  const { data } = await supabase.from('test').select('*')
  res.json(data)
}

export default ProtectedRoute
```

LANGUAGE: TypeScript
CODE:
```
import { NextApiHandler } from 'next'
import { createPagesServerClient } from '@supabase/auth-helpers-nextjs'

const ProtectedRoute: NextApiHandler = async (req, res) => {
  // Create authenticated Supabase Client
  const supabase = createPagesServerClient({ req, res })
  // Check if we have a session
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user)
    return res.status(401).json({
      error: 'not_authenticated',
      description: 'The user does not have an active session or is not authenticated',
    })

  // Run queries with RLS on the server
  const { data } = await supabase.from('test').select('*')
  res.json(data)
}

export default ProtectedRoute
```

----------------------------------------

TITLE: Define hybrid_search function for combined full-text and semantic queries
DESCRIPTION: Implements the `hybrid_search` SQL function, which performs a combined full-text and semantic search. It accepts `query_text`, `query_embedding`, and `match_count` as primary parameters, along with optional weights for full-text and semantic contributions, and an RRF smoothing constant. The function returns a set of `documents` records, fusing results from both search methods using Reciprocal Rank Fusion.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/hybrid-search.mdx#_snippet_2

LANGUAGE: SQL
CODE:
```
create or replace function hybrid_search(
  query_text text,
  query_embedding vector(512),
  match_count int,
  full_text_weight float = 1,
  semantic_weight float = 1,
  rrf_k int = 50
)
returns setof documents
language sql
as $$
with full_text as (
  select
    id,
    -- Note: ts_rank_cd is not indexable but will only rank matches of the where clause
    -- which shouldn't be too big
    row_number() over(order by ts_rank_cd(fts, websearch_to_tsquery(query_text)) desc) as rank_ix
  from
    documents
  where
    fts @@ websearch_to_tsquery(query_text)
  order by rank_ix
  limit least(match_count, 30) * 2
),
semantic as (
  select
    id,
    row_number() over (order by embedding <#> query_embedding) as rank_ix
  from
    documents
  order by rank_ix
  limit least(match_count, 30) * 2
)
select
  documents.*
from
  full_text
  full outer join semantic
    on full_text.id = semantic.id
  join documents
    on coalesce(full_text.id, semantic.id) = documents.id
order by
  coalesce(1.0 / (rrf_k + full_text.rank_ix), 0.0) * full_text_weight +
  coalesce(1.0 / (rrf_k + semantic.rank_ix), 0.0) * semantic_weight
  desc
limit
  least(match_count, 30)
$$;
```

----------------------------------------

TITLE: Querying On-Demand ETL (QETL) with SQL Wrappers
DESCRIPTION: This SQL query illustrates an On-demand ETL (QETL) approach using Foreign Data Wrappers. It directly queries purchase data from a `warehouse.orders` foreign table and joins it with `auth.users` to retrieve order IDs for a specific user. This method provides real-time access to analytical data, integrating large datasets with operational data without prior data movement.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/extensions/wrappers/overview.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- Get all purchases for a user from your data warehouse:
select
  auth.users.id as user_id,
  warehouse.orders.id as order_id
from
  warehouse.orders
join 
  auth.users on auth.users.id = warehouse.orders.user_id
where 
  auth.users.id = '<some_user_id>';
```

----------------------------------------

TITLE: Supabase Auto-generated CRUD API Endpoints
DESCRIPTION: Documentation of the automatically generated REST API endpoints for a 'customers' table, including GET, POST, PATCH, and DELETE operations, demonstrating instant API availability from database schema.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-05-17-simplify-backend-with-data-api.mdx#_snippet_0

LANGUAGE: APIDOC
CODE:
```
GET /customers: Fetch rows
POST /customers: Insert rows
PATCH /customers?id=eq.123: Update rows by ID
DELETE /customers?id=eq.123: Remove rows by ID
```

----------------------------------------

TITLE: Fetch Data Server-Side in Next.js Server Components
DESCRIPTION: This snippet demonstrates how to pre-fetch data on the server using `prefetchQuery` from `@supabase-cache-helpers/postgrest-react-query` within a Next.js Server Component. It initializes a `QueryClient` and uses `dehydrate` with `HydrationBoundary` to pass the pre-fetched data to client components, ensuring data is available immediately upon render.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-01-12-react-query-nextjs-app-router-cache-helpers.mdx#_snippet_9

LANGUAGE: TSX
CODE:
```
import { dehydrate, HydrationBoundary, QueryClient } from '@tanstack/react-query'
import { prefetchQuery } from '@supabase-cache-helpers/postgrest-react-query'
import useSupabaseServer from '@/utils/supabase-server'
import { cookies } from 'next/headers'
import Country from '../country'
import { getCountryById } from '@/queries/get-country-by-id'

export default async function CountryPage({ params }: { params: { id: number } }) {
  const queryClient = new QueryClient()
  const cookieStore = cookies()
  const supabase = useSupabaseServer(cookieStore)

  await prefetchQuery(queryClient, getCountryById(supabase, params.id))

  return (
    // Neat! Serialization is now as easy as passing props.
    // HydrationBoundary is a Client Component, so hydration will happen there.
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Country id={params.id} />
    </HydrationBoundary>
  )
}
```

----------------------------------------

TITLE: Analyze Query Plan with EXPLAIN
DESCRIPTION: This SQL command demonstrates how to use the 'EXPLAIN' statement to analyze the execution plan of a query. Understanding the query plan helps identify performance bottlenecks, such as 'Sequential Scans' or high-cost operations, allowing for targeted optimization efforts. If an index does not reduce the query plan's cost, it should be removed.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/query-optimization.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
explain select * from customers where sign_up_date > 25;
```

----------------------------------------

TITLE: Apply Supabase Migrations with CLI
DESCRIPTION: This command applies local database migrations to a linked remote Supabase database. It's used for syncing schema changes from a local development environment to a staging or production project.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/deployment/managing-environments.mdx#_snippet_15

LANGUAGE: bash
CODE:
```
supabase db push
```

----------------------------------------

TITLE: Supabase Database Schema and Storage Setup
DESCRIPTION: This SQL script defines the 'profiles' table, including 'id', 'updated_at', 'username', 'avatar_url', and 'website' fields, with primary key and unique constraints. It implements row-level security policies to control access: public read, user-specific insert, and user-specific update. Additionally, it configures Supabase Realtime for the 'profiles' table and sets up a storage bucket named 'avatars' with policies allowing public access and uploads.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/user-management/swift-user-management/README.md#_snippet_0

LANGUAGE: sql
CODE:
```
-- Create a table for public "profiles"
create table profiles (
  id uuid references auth.users not null,
  updated_at timestamp with time zone,
  username text unique,
  avatar_url text,
  website text,

  primary key (id),
  unique(username),
  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( (select auth.uid()) = id );

create policy "Users can update own profile."
  on profiles for update
  using ( (select auth.uid()) = id );

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- Set up Storage!
insert into storage.buckets (id, name)
values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible."
  on storage.objects for select
  using ( bucket_id = 'avatars' );

create policy "Anyone can upload an avatar."
  on storage.objects for insert
  with check ( bucket_id = 'avatars' );
```

----------------------------------------

TITLE: Implement Server-Side Rendering (SSR) with Supabase Auth in Next.js
DESCRIPTION: This example demonstrates how to perform server-side rendering in Next.js with Supabase authentication. It creates an authenticated Supabase client in `getServerSideProps` to retrieve the user session and redirect if no user is found.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_8

LANGUAGE: JavaScript
CODE:
```
import { createPagesServerClient } from '@supabase/auth-helpers-nextjs'

export default function Profile({ user }) {
  return <div>Hello {user.name}</div>
}

export const getServerSideProps = async (ctx) => {
  // Create authenticated Supabase Client
  const supabase = createPagesServerClient(ctx)
  // Check if we have a user
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user)
    return {
      redirect: {
        destination: '/',
        permanent: false,
      },
    }

  return {
    props: {
      user,
    },
  }
}
```

----------------------------------------

TITLE: Postgres PL/pgSQL Function for Pushing Data Changes (push)
DESCRIPTION: This PL/pgSQL function, `push`, handles incoming data changes from the client. It receives a JSONB object containing `created`, `deleted`, and `updated` entries for various data models (e.g., profiles). The function iterates through these changes, performing corresponding `INSERT`, `UPDATE`, or `DELETE` operations on the database, and requires extension for each new data object.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-10-08-react-native-offline-first-watermelon-db.mdx#_snippet_5

LANGUAGE: sql
CODE:
```
create or replace function push(changes jsonb) returns void as $$
declare new_profile jsonb;
declare updated_profile jsonb;
begin
-- create profiles
for new_profile in
select jsonb_array_elements((changes->'profiles'->'created')) loop perform create_profile(
        (new_profile->>'id')::uuid,
        (new_profile->>'user_id')::uuid,
        (new_profile->>'name'),
        (new_profile->>'website'),
        epoch_to_timestamp(new_profile->>'created_at'),
        epoch_to_timestamp(new_profile->>'updated_at')
    );
end loop;
-- delete profiles
with changes_data as (
    select jsonb_array_elements_text(changes->'profiles'->'deleted')::uuid as deleted
)
-- update profiles
update profiles
set deleted_at = now(),
    last_modified_at = now()
from changes_data
where profiles.id = changes_data.deleted;
end;
$$ language plpgsql;
```

----------------------------------------

TITLE: Handle Streaming LLM Responses in Supabase Edge Function
DESCRIPTION: This code demonstrates how to use Supabase.ai.Session to interact with an LLM (Mistral in this case) within a Deno Edge Function, specifically handling streaming responses. It shows how to get a prompt from the request, run the session, and stream the output back as a server-sent event (text/event-stream).
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-04-16-ai-inference-now-available-in-supabase-edge-functions.mdx#_snippet_1

LANGUAGE: TypeScript
CODE:
```
const session = new Supabase.ai.Session('mistral')

Deno.serve(async (req: Request) => {
  // Get the prompt from the query string
  const params = new URL(req.url).searchParams
  const prompt = params.get('prompt') ?? ''

  // Get the output as a stream
  const output = await session.run(prompt, { stream: true })

  // Create a stream
  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder()
      for await (const chunk of output) {
        controller.enqueue(encoder.encode(chunk.response ?? ''))
      }
    },
  })

  // Return the stream to the user
  return new Response(stream, {
    headers: new Headers({
      'Content-Type': 'text/event-stream',
      Connection: 'keep-alive'
    })
  })
})
```

----------------------------------------

TITLE: Initialize Supabase Server Client in Next.js
DESCRIPTION: This asynchronous function initializes a Supabase client for server-side operations in Next.js. It correctly handles cookies via `next/headers` and implements the required `getAll`/`setAll` pattern for cookie management with `@supabase/ssr`. This client is essential for server components, API routes, and middleware that need to interact with Supabase securely.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/nextjs-supabase-auth.md#_snippet_3

LANGUAGE: typescript
CODE:
```
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        }
      }
    }
  )
}
```

----------------------------------------

TITLE: Supabase RLS: Create UPDATE Policy for User Profiles
DESCRIPTION: This snippet illustrates how to create an UPDATE policy by combining 'using' and 'with check' expressions. The 'using' clause verifies ownership of the existing row, while 'with check' ensures the updated row still adheres to the ownership condition, preventing users from changing the 'user_id' to a different value.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_7

LANGUAGE: sql
CODE:
```
-- 1. Create table
create table profiles (
  id uuid primary key,
  user_id uuid references auth.users,
  avatar_url text
);

-- 2. Enable RLS
alter table profiles enable row level security;

-- 3. Create Policy
create policy "Users can update their own profile."
on profiles for update
to authenticated                    -- the Postgres Role (recommended)
using ( (select auth.uid()) = user_id )       -- checks if the existing row complies with the policy expression
with check ( (select auth.uid()) = user_id ); -- checks if the new row complies with the policy expression
```

----------------------------------------

TITLE: Implement Route Protection with Supabase and SvelteKit Hooks
DESCRIPTION: This code demonstrates how to implement centralized route protection in SvelteKit using the `handle` hook and Supabase authentication. It sets up a Supabase client, provides a `safeGetSession` helper to validate user sessions, and then applies authorization logic to specific route patterns (e.g., `/protected-routes` for GET, `/protected-posts` for POST) to redirect or throw errors if the user is not signed in. It leverages SvelteKit's `sequence` helper to combine the Supabase client setup and authorization logic.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/sveltekit.mdx#_snippet_12

LANGUAGE: JavaScript
CODE:
```
// src/hooks.server.js
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public'
import { createSupabaseServerClient } from '@supabase/auth-helpers-sveltekit'
import { redirect, error } from '@sveltejs/kit'
import { sequence } from '@sveltejs/kit/hooks'

async function supabase({ event, resolve }) {
  event.locals.supabase = createSupabaseServerClient({
    supabaseUrl: PUBLIC_SUPABASE_URL,
    supabaseKey: PUBLIC_SUPABASE_ANON_KEY,
    event,
  })

  /**
   * Unlike `supabase.auth.getSession`, which is unsafe on the server because it
   * doesn't validate the JWT, this function validates the JWT by first calling
   * `getUser` and aborts early if the JWT signature is invalid.
   */
  event.locals.safeGetSession = async () => {
    const {
      data: { user },
      error,
    } = await event.locals.supabase.auth.getUser()
    if (error) return { session: null, user: null }

    const {
      data: { session },
    } = await event.locals.supabase.auth.getSession()
    return { session, user }
  }

  return resolve(event, {
    filterSerializedResponseHeaders(name) {
      return name === 'content-range' || name === 'x-supabase-api-version'
    },
  })
}

async function authorization({ event, resolve }) {
  // protect requests to all routes that start with /protected-routes
  if (event.url.pathname.startsWith('/protected-routes') && event.request.method === 'GET') {
    const { session } = await event.locals.safeGetSession()
    if (!session) {
      // the user is not signed in
      redirect(303, '/')
    }
  }

  // protect POST requests to all routes that start with /protected-posts
  if (event.url.pathname.startsWith('/protected-posts') && event.request.method === 'POST') {
    const { session } = await event.locals.safeGetSession()
    if (!session) {
      // the user is not signed in
      throw error(303, '/')
    }
  }

  return resolve(event)
}

export const handle = sequence(supabase, authorization)
```

LANGUAGE: TypeScript
CODE:
```
// src/hooks.server.ts
import { type Handle, redirect, error } from '@sveltejs/kit'
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_ANON_KEY } from '$env/static/public'
import { createSupabaseServerClient } from '@supabase/auth-helpers-sveltekit'
import { sequence } from '@sveltejs/kit/hooks'

async function supabase({ event, resolve }) {
  event.locals.supabase = createSupabaseServerClient({
    supabaseUrl: PUBLIC_SUPABASE_URL,
    supabaseKey: PUBLIC_SUPABASE_ANON_KEY,
    event,
  })

  /**
   * Unlike `supabase.auth.getSession`, which is unsafe on the server because it
   * doesn't validate the JWT, this function validates the JWT by first calling
   * `getUser` and aborts early if the JWT signature is invalid.
   */
  event.locals.safeGetSession = async () => {
    const {
      data: { user },
      error,
    } = await event.locals.supabase.auth.getUser()
    if (error) return { session: null, user: null }

    const {
      data: { session },
    } = await event.locals.supabase.auth.getSession()
    return { session, user }
  }

  return resolve(event, {
    filterSerializedResponseHeaders(name) {
      return name === 'content-range' || name === 'x-supabase-api-version'
    },
  })
}

async function authorization({ event, resolve }) {
  // protect requests to all routes that start with /protected-routes
  if (event.url.pathname.startsWith('/protected-routes') && event.request.method === 'GET') {
    const { session } = await event.locals.safeGetSession()
    if (!session) {
      // the user is not signed in
      redirect(303, '/')
    }
  }

  // protect POST requests to all routes that start with /protected-posts
  if (event.url.pathname.startsWith('/protected-posts') && event.request.method === 'POST') {
    const { session } = await event.locals.safeGetSession()
    if (!session) {
      // the user is not signed in
      throw error(303, '/')
    }
  }

  return resolve(event)
}

export const handle: Handle = sequence(supabase, authorization)
```

----------------------------------------

TITLE: Bypass RLS on Related Tables Using Security Definer Functions
DESCRIPTION: Employ security definer functions to query data from other tables without triggering their RLS policies. This is particularly useful for joined tables where the RLS might otherwise cause performance overhead. Ensure proper security measures for functions exposed via API.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-performance-and-best-practices-Z5Jjwv.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
exists (select 1 from roles_table where auth.uid() = user_id and role = 'good_role')
```

LANGUAGE: sql
CODE:
```
(select has_role())
```

LANGUAGE: plpgsql
CODE:
```
CREATE OR REPLACE FUNCTION has_role()
    RETURNS boolean as
$$
begin
    return exists (select 1 from roles_table where auth.uid() = user_id and role = 'good_role')
end;
$$ language plpgsql security definer;
```

----------------------------------------

TITLE: Next.js Server Component for Supabase User Authentication
DESCRIPTION: This snippet illustrates a Next.js server component that integrates with Supabase to verify user authentication. It fetches the user session and, if the user is not authenticated or an error occurs, redirects them to the '/login' page. Authenticated users are greeted with their email.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/nextjs.mdx#_snippet_9

LANGUAGE: TypeScript
CODE:
```
import { redirect } from 'next/navigation'

import { createClient } from '@/utils/supabase/server'

export default async function PrivatePage() {
  const supabase = await createClient()

  const { data, error } = await supabase.auth.getUser()
  if (error || !data?.user) {
    redirect('/login')
  }

  return <p>Hello {data.user.email}</p>
}
```

----------------------------------------

TITLE: Generate Signed Upload URL for Supabase Storage in Next.js API Route
DESCRIPTION: This Next.js API route generates a signed upload URL for Supabase Storage. It authenticates the user session and uses the Supabase Admin client to create a unique, temporary URL for a user's avatar, allowing secure client-side uploads without exposing service role keys. The URL is returned as JSON.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-06-18-calcom-platform-starter-kit-nextjs-supabase.mdx#_snippet_3

LANGUAGE: ts
CODE:
```
import { auth } from '@/auth'
import { env } from '@/env'
import { createClient } from '@supabase/supabase-js'

export const dynamic = 'force-dynamic' // defaults to auto
export async function GET(request: Request) {
  try {
    const session = await auth()
    if (!session || !session.user.id) {
      return new Response('Unauthorized', { status: 401 })
    }
    const {
      user: { id },
    } = session
    // Generate signed upload url to use on client.
    const supabaseAdmin = createClient(env.NEXT_PUBLIC_SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY)

    const { data, error } = await supabaseAdmin.storage
      .from('avatars')
      .createSignedUploadUrl(id, { upsert: true })
    console.log(error)
    if (error) throw error

    return new Response(JSON.stringify(data), {
      status: 200,
    })
  } catch (e) {
    console.error(e)
    return new Response('Internal Server Error', { status: 500 })
  }
}
```

----------------------------------------

TITLE: Enable PostgreSQL Vector Extension
DESCRIPTION: SQL command to enable the 'pgvector' extension in PostgreSQL, which is necessary to work with vector data types and operations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-02-03-openai-embeddings-postgres-vector.mdx#_snippet_0

LANGUAGE: sql
CODE:
```
create extension vector;
```

----------------------------------------

TITLE: Optimize Supabase RLS Join Queries with IN/ANY
DESCRIPTION: This snippet demonstrates how to optimize Row Level Security (RLS) join queries in Supabase PostgreSQL for better performance. Instead of comparing a row column directly within the RLS policy's WHERE clause, it's more efficient to pre-fetch relevant IDs into an array and use an IN or ANY operation. Additionally, moving complex join logic to a security definer function can further enhance performance by avoiding RLS on the join table itself, especially when dealing with large datasets where the 'in' list should ideally not exceed 10K items.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-performance-and-best-practices-Z5Jjwv.mdx#_snippet_4

LANGUAGE: SQL
CODE:
```
auth.uid() in (select user_id from team_user where team_user.team_id = table.team_id)
```

LANGUAGE: SQL
CODE:
```
team_id in (select team_id from team_user where user_id = auth.uid())
```

LANGUAGE: SQL
CODE:
```
team_id in (select user_teams())
```

----------------------------------------

TITLE: Query Data with Custom JWT RLS Enforcement
DESCRIPTION: Executes a `SELECT` query on `document_sections`. When accessed via the Supabase REST API with a custom JWT, RLS automatically filters results based on the JWT's `sub` claim, ensuring only the current user's document sections are returned.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/rag-with-permissions.mdx#_snippet_13

LANGUAGE: SQL
CODE:
```
-- Only document sections owned by the user are returned
select *
from document_sections
where document_sections.embedding <#> embedding < -match_threshold
order by document_sections.embedding <#> embedding;
```

----------------------------------------

TITLE: Integrate Web Worker for Embedding Generation and Search in React (JavaScript)
DESCRIPTION: This React component (`App.jsx`) demonstrates how to integrate the web worker for embedding generation and perform the semantic search. It uses `useEffect` to initialize and manage the web worker, setting up event listeners to handle messages (e.g., `complete` status triggers the `search` function). It also uses `useCallback` to define a function for posting messages to the worker, ensuring efficient communication and state management.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-08-29-in-browser-semantic-search-pglite.mdx#_snippet_9

LANGUAGE: JavaScript
CODE:
```
import { getDB, initSchema, countRows, seedDb, search } from './utils/db'
import { useState, useEffect, useRef, useCallback } from 'react'

export default function App() {
  // Keep track of the classification result and the model loading status.
  const [input, setInput] = useState('')
  const [content, setContent] = useState([])
  const [result, setResult] = useState(null)
  const [ready, setReady] = useState(null)
  const initailizing = useRef(false)

  // [...]

  // We use the `useEffect` hook to set up the worker as soon as the `App` component is mounted.
  useEffect(() => {
    if (!worker.current) {
      // Create the worker if it does not yet exist.
      worker.current = new Worker(new URL('./worker.js', import.meta.url), {
        type: 'module',
      })
    }

    // Create a callback function for messages from the worker thread.
    const onMessageReceived = async (e) => {
      switch (e.data.status) {
        case 'initiate':
          setReady(false)
          break
        case 'ready':
          setReady(true)
          break
        case 'complete':
          // Inner product search
          const searchResults = await search(db.current, e.data.embedding)
          console.log({ searchResults })
          setResult(searchResults.map((x) => x.content))
          break
      }
    }

    // Attach the callback function as an event listener.
    worker.current.addEventListener('message', onMessageReceived)

    // Define a cleanup function for when the component is unmounted.
    return () => worker.current.removeEventListener('message', onMessageReceived)
  })

  const classify = useCallback((text) => {
    if (worker.current) {
      worker.current.postMessage({ text })
    }
  }, [])

  // [...]
}
```

----------------------------------------

TITLE: SQL: Initial RLS Policy for Role-Based Access
DESCRIPTION: Defines a Row Level Security policy on `test_table` for authenticated users, checking if their `user_id` exists in `roles_table` with a 'good_role'. This policy involves a subquery to `roles_table`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/row-level-security.mdx#_snippet_18

LANGUAGE: SQL
CODE:
```
create policy "rls_test_select" on test_table
to authenticated
using (
  exists (
    select 1 from roles_table
    where (select auth.uid()) = user_id and role = 'good_role'
  )
);
```

----------------------------------------

TITLE: Efficiently Change Column Type on Large PostgreSQL Table
DESCRIPTION: Provides a three-step alternative to directly altering a column's data type on a large PostgreSQL table, which can be slow and disruptive. This method involves adding a new column with the desired type, copying data, and then dropping the old column, minimizing transaction time and disruption.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/slow-execution-of-alter-table-on-large-table-when-changing-column-type-qmZRpZ.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
ALTER TABLE "table_name" ADD COLUMN "new_column_name" new_data_type;
```

LANGUAGE: SQL
CODE:
```
UPDATE "table_name" SET "old_column_name" = "new_column_name"::new_data_type;
```

LANGUAGE: SQL
CODE:
```
ALTER TABLE "table_name" DROP COLUMN "old_column_name";
```

----------------------------------------

TITLE: Create Tables for Many-to-Many Relationship (Movies, Actors, Performances)
DESCRIPTION: This SQL example illustrates how to set up tables for a many-to-many relationship between 'movies' and 'actors'. It defines 'movies' and 'actors' tables, and then creates a 'performances' join table that links movies and actors using foreign keys, allowing an actor to be in multiple movies and a movie to have multiple actors.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/tables.mdx#_snippet_7

LANGUAGE: SQL
CODE:
```
create table movies (
  id bigint generated by default as identity primary key,
  name text,
  description text
);

create table actors (
  id bigint generated by default as identity primary key,
  name text
);

create table performances (
  id bigint generated by default as identity primary key,
  movie_id bigint not null references movies,
  actor_id bigint not null references actors
);
```

----------------------------------------

TITLE: Handle Supabase Edge Function Invocation Errors in JavaScript
DESCRIPTION: This JavaScript code demonstrates how to catch and handle different error types (`FunctionsHttpError`, `FunctionsRelayError`, `FunctionsFetchError`) that can occur when invoking Supabase Edge Functions using the `supabase-js` library. It shows how to access error context for detailed messages.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/development-tips.mdx#_snippet_4

LANGUAGE: js
CODE:
```
import { FunctionsHttpError, FunctionsRelayError, FunctionsFetchError } from '@supabase/supabase-js'

const { data, error } = await supabase.functions.invoke('hello', {
  headers: { 'my-custom-header': 'my-custom-header-value' },
  body: { foo: 'bar' }
})

if (error instanceof FunctionsHttpError) {
  const errorMessage = await error.context.json()
  console.log('Function returned an error', errorMessage)
} else if (error instanceof FunctionsRelayError) {
  console.log('Relay error:', error.message)
} else if (error instanceof FunctionsFetchError) {
  console.log('Fetch error:', error.message)
}
```

----------------------------------------

TITLE: SQL Function to Handle User Profile Updates
DESCRIPTION: This PostgreSQL function, `public.update_user`, is intended to be triggered when a user's information is updated in the `auth.users` table. It updates the corresponding `email` in the `public.profiles` table based on the user's `id`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/prisma/prisma-troubleshooting.mdx#_snippet_6

LANGUAGE: sql
CODE:
```
-- Function to handle the updating of a user's information in the 'profiles' table
create function public.update_user()
returns trigger
language plpgsql
security definer set search_path = ''
as
$$
begin
  -- Update the user's data in the 'profiles' table
  update public.profiles
  set email = new.email     -- Update the 'email' field
  where id = new.id;        -- Match the 'id' field with the new record

  return new;  -- Return the new record
end;
$$;
```

----------------------------------------

TITLE: SQL Function to Handle New User Insertion into Profiles
DESCRIPTION: This PostgreSQL function, `public.handle_new_user`, is designed to be triggered after a new user is inserted into the `auth.users` table. It inserts the new user's `id` and `email` into the `public.profiles` table, ensuring data duplication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/prisma/prisma-troubleshooting.mdx#_snippet_5

LANGUAGE: sql
CODE:
```
-- Function to handle the insertion of a new user into the 'profiles' table
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = ''
as $$
begin

  -- Insert the new user's data into the 'profiles' table
  insert into public.profiles (id, email)
  values (new.id, new.email);

  return new;     -- Return the new record
end;
$$;
```

----------------------------------------

TITLE: Migrating Supabase Auth signIn method
DESCRIPTION: This snippet demonstrates the transition from the deprecated `supabase.auth.signIn()` method (v1.0) to the new `supabase.auth.signInWithPassword()` (v2.0) for explicit password-based authentication. The older method is being removed in favor of more specific functions like `signInWithPassword()`, `signInWithOtp()`, and `signInWithOAuth()`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/release-notes.mdx#_snippet_7

LANGUAGE: TypeScript
CODE:
```
const { data } = await supabase.auth.signIn({
  email: 'hello@example',
  password: 'pass',
})
```

LANGUAGE: TypeScript
CODE:
```
const { data } = await supabase.auth.signInWithPassword({
  email: 'hello@example',
  password: 'pass',
})
```

----------------------------------------

TITLE: Install Supabase packages for Next.js
DESCRIPTION: Installs the @supabase/supabase-js and @supabase/ssr packages. These are essential dependencies for integrating Supabase authentication into your Next.js project.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/server-side/nextjs.mdx#_snippet_0

LANGUAGE: sh
CODE:
```
npm install @supabase/supabase-js @supabase/ssr
```

----------------------------------------

TITLE: Install Ionic CLI and Supabase JS
DESCRIPTION: Commands to set up a new Ionic Vue project, install the Ionic CLI globally, navigate into the project directory, and add the Supabase JavaScript client library as a dependency.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-ionic-vue.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
npm install -g @ionic/cli
ionic start supabase-ionic-vue blank --type vue
cd supabase-ionic-vue
npm install @supabase/supabase-js
```

----------------------------------------

TITLE: Supabase Edge Function for Ollama Streaming Inference
DESCRIPTION: Implements a Supabase Edge Function that interacts with a local Ollama server using Supabase.ai.Session. It processes user prompts and streams AI-generated responses back to the client.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/ai-models.mdx#_snippet_8

LANGUAGE: ts
CODE:
```
import 'jsr:@supabase/functions-js/edge-runtime.d.ts'
const session = new Supabase.ai.Session('mistral')

Deno.serve(async (req: Request) => {
  const params = new URL(req.url).searchParams
  const prompt = params.get('prompt') ?? ''

  // Get the output as a stream
  const output = await session.run(prompt, { stream: true })

  const headers = new Headers({
    'Content-Type': 'text/event-stream',
    Connection: 'keep-alive'
  })

  // Create a stream
  const stream = new ReadableStream({
    async start(controller) {
      const encoder = new TextEncoder()

      try {
        for await (const chunk of output) {
          controller.enqueue(encoder.encode(chunk.response ?? ''))
        }
      } catch (err) {
        console.error('Stream error:', err)
      } finally {
        controller.close()
      }
    }
  })

  // Return the stream to the user
  return new Response(stream, {
    headers
  })
})
```

----------------------------------------

TITLE: Supabase PKCE Auth Flow Configuration for Sign Up
DESCRIPTION: This TypeScript snippet illustrates how to configure the `signUp` function for Supabase authentication to correctly implement the PKCE (Proof Key for Code Exchange) flow. It's crucial to set the `emailRedirectTo` option to the designated code exchange route handler for proper authentication redirection.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/sveltekit.mdx#_snippet_16

LANGUAGE: TypeScript
CODE:
```
await supabase.auth.signUp({
  email: 'valid.email@supabase.io',
  password: 'sup3rs3cur3',
  options: {
    emailRedirectTo: 'http://localhost:3000/auth/callback',
  },
})
```

----------------------------------------

TITLE: Query Supabase data from Next.js Server Components
DESCRIPTION: Demonstrates how to fetch data from a Supabase table (`instruments`) within a Next.js Server Component (`app/instruments/page.tsx`) and display it. It also includes the utility function (`utils/supabase/server.ts`) for creating a Supabase client with server-side cookie handling.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/quickstarts/nextjs.mdx#_snippet_2

LANGUAGE: ts
CODE:
```
import { createClient } from '@/utils/supabase/server';

export default async function Instruments() {
  const supabase = await createClient();
  const { data: instruments } = await supabase.from("instruments").select();

  return <pre>{JSON.stringify(instruments, null, 2)}</pre>
}
```

LANGUAGE: ts
CODE:
```
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        }
      }
    }
  )
}
```

----------------------------------------

TITLE: PostgreSQL EXPLAIN Output Components Reference
DESCRIPTION: A detailed reference for understanding the various components and metrics presented in the output of the PostgreSQL EXPLAIN command. This includes descriptions of plan types, cost estimations, row counts, data width, applied filters, and actual execution time.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/understanding-postgresql-explain-output-Un9dqX.mdx#_snippet_2

LANGUAGE: APIDOC
CODE:
```
Plan type:
  - Seq Scan: A sequential scan that reads all rows from a table. Often seen in the absence of indexes that can be used for the query.
  - Index Scan: Uses an index to find rows quickly. This indicates that the query is able to use an index to efficiently locate data.
  - Bitmap Heap Scan: Uses a bitmap index to find rows quickly and then retrieves the actual rows from the table. This type of scan is efficient when retrieving a moderate number of rows.
Cost:
  - Format: cost=0.00..19.00 (first number is start-up cost, second is total cost)
  - Start-up Cost: The cost incurred before returning the first row.
  - Total Cost: The estimated total cost of the operation.
Rows:
  - Format: rows=1
  - Description: An estimate of the number of rows the query will return. Accurate row estimates depend on updated statistics.
Width:
  - Format: width=240
  - Description: The average number of bytes expected for the output rows. This indicates the expected data volume.
Filters:
  - Format: Filter: (user_id = 1)
  - Description: Any conditions applied post-scan. A high number of rows being filtered out could indicate a need for better indexing.
Execution time:
  - Format: Execution Time: 0.069 ms
  - Description: Measures how long it took to actually execute the query, including retrieving the data, performing any sorts, joins, or other operations. Measured in milliseconds.
```

----------------------------------------

TITLE: Example SQL RLS Policy for Insert
DESCRIPTION: This snippet demonstrates a basic CREATE POLICY statement for an INSERT operation on the 'books' table. It shows the use of FOR INSERT, TO authenticated, and a USING clause with auth.uid() to restrict inserts to authenticated users matching the author_id.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/database-rls-policies.md#_snippet_0

LANGUAGE: SQL
CODE:
```
CREATE POLICY "My descriptive policy." ON books FOR INSERT to authenticated USING ( (select auth.uid()) = author_id ) WITH ( true );
```

----------------------------------------

TITLE: Redirecting to Supabase OAuth Authorize URL with PKCE (TypeScript)
DESCRIPTION: This TypeScript snippet demonstrates how to initiate the Supabase OAuth 2.0 authorization flow. It constructs the authorization URL, generates a PKCE `codeVerifier`, stores it in the user's session, and then redirects the user to the Supabase authorization endpoint. This is a crucial step for obtaining user consent and initiating the token exchange process.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/integrations/build-a-supabase-integration.mdx#_snippet_0

LANGUAGE: TypeScript
CODE:
```
router.get('/connect-supabase/login', async (ctx) => {
  // Construct the URL for the authorization redirect and get a PKCE codeVerifier.
  const { uri, codeVerifier } = await oauth2Client.code.getAuthorizationUri()
  console.log(uri.toString())
  // console.log: https://api.supabase.com/v1/oauth/authorize?response_type=code&client_id=7673bde9-be72-4d75-bd5e-b0dba2c49b38&redirect_uri=http%3A%2F%2Flocalhost%3A54321%2Ffunctions%2Fv1%2Fconnect-supabase%2Foauth2%2Fcallback&scope=all&code_challenge=jk06R69S1bH9dD4td8mS5kAEFmEbMP5P0YrmGNAUVE0&code_challenge_method=S256

  // Store the codeVerifier in the user session (cookie).
  ctx.state.session.flash('codeVerifier', codeVerifier)

  // Redirect the user to the authorization endpoint.
  ctx.response.redirect(uri)
})
```

----------------------------------------

TITLE: Initialize Supabase CLI Locally
DESCRIPTION: Ensure the Supabase CLI is installed, then initialize a new Supabase project and start the local development stack.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/quickstarts/generate-text-embeddings.mdx#_snippet_0

LANGUAGE: shell
CODE:
```
supabase init
supabase start
```

----------------------------------------

TITLE: Create Account Page Widget in Flutter with Supabase
DESCRIPTION: This Dart code defines a `StatefulWidget` for an account management page. It integrates with Supabase to fetch user profiles, update user details (username, website), and handle user sign-out. It includes controllers for text fields, state management for loading indicators, and error handling for Supabase operations.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-flutter.mdx#_snippet_5

LANGUAGE: Dart
CODE:
```
import 'package:flutter/material.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:supabase_quickstart/main.dart';
import 'package:supabase_quickstart/pages/login_page.dart';

class AccountPage extends StatefulWidget {
  const AccountPage({super.key});

  @override
  State<AccountPage> createState() => _AccountPageState();
}

class _AccountPageState extends State<AccountPage> {
  final _usernameController = TextEditingController();
  final _websiteController = TextEditingController();

  String? _avatarUrl;
  var _loading = true;

  /// Called once a user id is received within `onAuthenticated()`
  Future<void> _getProfile() async {
    setState(() {
      _loading = true;
    });

    try {
      final userId = supabase.auth.currentSession!.user.id;
      final data =
          await supabase.from('profiles').select().eq('id', userId).single();
      _usernameController.text = (data['username'] ?? '') as String;
      _websiteController.text = (data['website'] ?? '') as String;
      _avatarUrl = (data['avatar_url'] ?? '') as String;
    } on PostgrestException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    } finally {
      if (mounted) {
        setState(() {
          _loading = false;
        });
      }
    }
  }

  /// Called when user taps `Update` button
  Future<void> _updateProfile() async {
    setState(() {
      _loading = true;
    });
    final userName = _usernameController.text.trim();
    final website = _websiteController.text.trim();
    final user = supabase.auth.currentUser;
    final updates = {
      'id': user!.id,
      'username': userName,
      'website': website,
      'updated_at': DateTime.now().toIso8601String(),
    };
    try {
      await supabase.from('profiles').upsert(updates);
      if (mounted) context.showSnackBar('Successfully updated profile!');
    } on PostgrestException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    } finally {
      if (mounted) {
        setState(() {
          _loading = false;
        });
      }
    }
  }

  Future<void> _signOut() async {
    try {
      await supabase.auth.signOut();
    } on AuthException catch (error) {
      if (mounted) context.showSnackBar(error.message, isError: true);
    } catch (error) {
      if (mounted) {
        context.showSnackBar('Unexpected error occurred', isError: true);
      }
    } finally {
      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (_) => const LoginPage()),
        );
      }
    }
  }

  @override
  void initState() {
    super.initState();
    _getProfile();
  }

  @override
  void dispose() {
    _usernameController.dispose();
    _websiteController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: ListView(
        padding: const EdgeInsets.symmetric(vertical: 18, horizontal: 12),
        children: [
          TextFormField(
            controller: _usernameController,
            decoration: const InputDecoration(labelText: 'User Name'),
          ),
          const SizedBox(height: 18),
          TextFormField(
            controller: _websiteController,
            decoration: const InputDecoration(labelText: 'Website'),
          ),
          const SizedBox(height: 18),
          ElevatedButton(
            onPressed: _loading ? null : _updateProfile,
            child: Text(_loading ? 'Saving...' : 'Update'),
          ),
          const SizedBox(height: 18),
          TextButton(onPressed: _signOut, child: const Text('Sign Out')),
        ],
      ),
    );
  }
}
```

----------------------------------------

TITLE: Create Functional HNSW Index on Sub-Vectors
DESCRIPTION: This SQL snippet creates an HNSW functional index on the 'documents' table. It uses the `sub_vector` function to index a 512-dimension subset of the original embeddings, optimizing for faster initial pass queries. The index is configured with specific `m` and `ef_construction` parameters for performance.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-02-13-matryoshka-embeddings.mdx#_snippet_12

LANGUAGE: SQL
CODE:
```
create index on documents
using hnsw ((sub_vector(embedding, 512)::vector(512)) vector_ip_ops)
with (m = 32, ef_construction = 400);
```

----------------------------------------

TITLE: Connect to Supabase Vecs Database in Python
DESCRIPTION: This Python code snippet demonstrates how to establish a connection to a Supabase Vecs database using the `vecs` library. It defines the database connection string and initializes a vector store client. Users must replace placeholder values with their actual database credentials and ensure the connection string starts with `postgresql://`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/quickstarts/hello-world.mdx#_snippet_0

LANGUAGE: python
CODE:
```
import vecs

DB_CONNECTION = "postgresql://<user>:<password>@<host>:<port>/<db_name>"

# create vector store client
vx = vecs.create_client(DB_CONNECTION)
```

----------------------------------------

TITLE: Group Supabase Edge Log Errors by Path and Status Code using SQL
DESCRIPTION: This SQL query groups error logs (status codes >= 400) from the Supabase Database API by their `path` and `status_code`. It counts the reoccurrence for each unique combination, ordering results by the count to highlight the most frequent errors.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/discovering-and-interpreting-api-errors-in-the-logs-7xREI9.mdx#_snippet_14

LANGUAGE: sql
CODE:
```
select
  status_code,
  path,
  count(path) as reoccurrence_per_path
from
  edge_logs
  cross join unnest(metadata) as metadata
  cross join unnest(response) as response
  cross join unnest(request) as request
where
  -- find all errors
  status_code >= 400
  and regexp_contains(path, '^/rest/v1/') -- only look at DB API
group by path, status_code
order by reoccurrence_per_path;
```

----------------------------------------

TITLE: Jetpack Compose Authentication UI Components
DESCRIPTION: This snippet demonstrates how to create a user interface for authentication using Jetpack Compose. It includes `OutlinedTextField` for email and password input, and `Button` and `OutlinedButton` for various sign-in and sign-up actions. The UI elements are designed to integrate with a ViewModel for handling input changes and authentication logic, and utilize `LocalSoftwareKeyboardController` for keyboard management. It also shows a Snackbar for feedback.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-kotlin.mdx#_snippet_32

LANGUAGE: Kotlin
CODE:
```
                    )
                },
                maxLines = 1,
                shape = RoundedCornerShape(32),
                modifier = modifier.fillMaxWidth(),
                value = email.value,
                onValueChange = {
                    viewModel.onEmailChange(it)
                },
            )
            androidx.compose.material.OutlinedTextField(
                label = {
                    Text(
                        text = "Password",
                        color = MaterialTheme.colorScheme.primary,
                        style = MaterialTheme.typography.titleMedium
                    )
                },
                maxLines = 1,
                shape = RoundedCornerShape(32),
                modifier = modifier
                    .fillMaxWidth()
                    .padding(top = 12.dp),
                value = password.value,
                onValueChange = {
                    viewModel.onPasswordChange(it)
                },
            )
            val localSoftwareKeyboardController = LocalSoftwareKeyboardController.current
            Button(modifier = modifier
                .fillMaxWidth()
                .padding(top = 12.dp),
                onClick = {
                    localSoftwareKeyboardController?.hide()
                    viewModel.onGoogleSignIn()
                }) {
                Text("Sign in with Google")
            }
            Button(modifier = modifier
                .fillMaxWidth()
                .padding(top = 12.dp),
                onClick = {
                    localSoftwareKeyboardController?.hide()
                    viewModel.onSignIn()
                    coroutineScope.launch {
                        snackBarHostState.showSnackbar(
                            message = "Sign in successfully !",
                            duration = SnackbarDuration.Long
                        )
                    }
                }) {
                Text("Sign in")
            }
            OutlinedButton(modifier = modifier
                .fillMaxWidth()
                .padding(top = 12.dp), onClick = {
                navController.navigate(SignUpDestination.route)
            }) {
                Text("Sign up")
            }
        }
    }
}
```

----------------------------------------

TITLE: OpenAI API Integration in Edge Function
DESCRIPTION: This Deno Edge Function demonstrates integrating the OpenAI API to create a chat completion. It initializes the OpenAI client using an API key from environment variables and processes a query from the incoming request body to generate a response using the 'gpt-3.5-turbo' model.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-09-12-edge-functions-faster-smaller.mdx#_snippet_1

LANGUAGE: jsx
CODE:
```
import OpenAI from 'npm:openai@4.57.3'

const client = new OpenAI({
  apiKey: Deno.env.get('OPEN_AI_KEY'),
})

Deno.serve(async (req) => {
  const { query } = await req.json()

  const chatCompletion = await client.chat.completions.create({
    messages: [{ role: 'user', content: 'Say this is a test' }],
    model: 'gpt-3.5-turbo',
  })

  return new Response(chatCompletion)
})
```

----------------------------------------

TITLE: Verifying HTTP Hook Payload with Standard Webhooks (Deno/JavaScript)
DESCRIPTION: This Deno (JavaScript) code snippet demonstrates how to verify an incoming HTTP hook payload using the `standardwebhooks` library. It retrieves the secret from environment variables, extracts necessary headers, and then uses the `Webhook` class to verify the payload's integrity before proceeding with business logic. This ensures that only legitimate webhook requests are processed.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks.mdx#_snippet_2

LANGUAGE: javascript
CODE:
```
import { Webhook } from 'https://esm.sh/standardwebhooks@1.0.0'

Deno.serve(async (req) => {
  const payload = await req.text()
  const hookSecret = Deno.env.get('SEND_SMS_HOOK_SECRETS').replace('v1,whsec_', '')
  // Extract headers and security specific fields
  const headers = Object.fromEntries(req.headers)
  const wh = new Webhook(hookSecret)
  const data = wh.verify(payload, headers)

  // Payload data is verified, continue with business logic here
  // ...
})
```

----------------------------------------

TITLE: Supabase Auth Sign Up with Email Redirect
DESCRIPTION: Demonstrates how to use the `signUp` function with the Supabase client, setting the `emailRedirectTo` option to the new `/auth/callback` route handler for PKCE flow compatibility in Next.js Auth Helpers v0.7.x.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_19

LANGUAGE: jsx
CODE:
```
supabase.auth.signUp({
  email: 'valid.email@supabase.io',
  password: 'sup3rs3cur3',
  options: {
    emailRedirectTo: 'http://localhost:3000/auth/callback'
  }
})
```

----------------------------------------

TITLE: RLS Policy: Allow Permanent Users to Create Posts
DESCRIPTION: This Row Level Security policy restricts `INSERT` operations on the `public.posts` table, allowing only non-anonymous authenticated users to create new posts by checking the `is_anonymous` claim in the JWT.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-04-17-anonymous-sign-ins.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create policy "Only permanent users can create posts"
on public.posts
for insert
to authenticated -- Note: user is still authenticated
with check (
  (select auth.jwt() ->> 'is_anonymous')::boolean is false
);
```

----------------------------------------

TITLE: Upload a file to Supabase Storage
DESCRIPTION: This snippet demonstrates how to upload a file to a Supabase storage bucket. It shows examples for uploading from the Dashboard, a browser using JavaScript, and programmatically using Dart.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/quickstart.mdx#_snippet_1

LANGUAGE: Dashboard
CODE:
```
1. Go to the [Storage](https://supabase.com/dashboard/project/_/storage/buckets) page in the Dashboard.
2. Select the bucket you want to upload the file to.
3. Click **Upload File**.
4. Select the file you want to upload.
```

LANGUAGE: JavaScript
CODE:
```
const avatarFile = event.target.files[0]
const { data, error } = await supabase.storage
  .from('avatars')
  .upload('public/avatar1.png', avatarFile)
```

LANGUAGE: Dart
CODE:
```
void main() async {
  final supabase = SupabaseClient('supabaseUrl', 'supabaseKey');

  // Create file `example.txt` and upload it in `public` bucket
  final file = File('example.txt');
  file.writeAsStringSync('File content');
  final storageResponse = await supabase
      .storage
      .from('public')
      .upload('example.txt', file);
}
```

----------------------------------------

TITLE: Initialize Supabase Project Locally
DESCRIPTION: Command to create a new Supabase project in the current directory using the Supabase CLI, setting up the necessary project structure.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/examples/elevenlabs-generate-speech-stream.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
supabase init
```

----------------------------------------

TITLE: Link Supabase Project to Local Environment
DESCRIPTION: Links your local development environment to a Supabase project using its reference ID. The project reference ID can be found in the Supabase dashboard URL or project settings.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/quickstart.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
supabase link --project-ref your-project-ref
```

----------------------------------------

TITLE: Cloudflare Turnstile Server-Side Validation Edge Function (Deno/TypeScript)
DESCRIPTION: Deno TypeScript code for a Supabase Edge Function that validates Cloudflare Turnstile tokens. This function handles CORS, extracts the token and client IP from the request, and sends a POST request to Cloudflare's /siteverify API endpoint for verification, returning 'success' or 'failure' based on the outcome.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/examples/cloudflare-turnstile.mdx#_snippet_1

LANGUAGE: typescript
CODE:
```
import { corsHeaders } from '../_shared/cors.ts'

console.log('Hello from Cloudflare Trunstile!')

function ips(req: Request) {
  return req.headers.get('x-forwarded-for')?.split(/\s*,\s*/)
}

Deno.serve(async (req) => {
  // This is needed if you're planning to invoke your function from a browser.
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  const { token } = await req.json()
  const clientIps = ips(req) || ['']
  const ip = clientIps[0]

  // Validate the token by calling the
  // "/siteverify" API endpoint.
  let formData = new FormData()
  formData.append('secret', Deno.env.get('CLOUDFLARE_SECRET_KEY') ?? '')
  formData.append('response', token)
  formData.append('remoteip', ip)

  const url = 'https://challenges.cloudflare.com/turnstile/v0/siteverify'
  const result = await fetch(url, {
    body: formData,
    method: 'POST',
  })

  const outcome = await result.json()
  console.log(outcome)
  if (outcome.success) {
    return new Response('success', { headers: corsHeaders })
  }
  return new Response('failure', { headers: corsHeaders })
})
```

----------------------------------------

TITLE: Handle Google Sign-in Callback with Nonce for Supabase
DESCRIPTION: This TypeScript function extends the Google sign-in callback to include a nonce for enhanced security. The nonce, which should be randomly generated, is passed to `supabase.auth.signInWithIdToken` along with the provider and token. This is an optional but recommended security measure.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-google.mdx#_snippet_7

LANGUAGE: ts
CODE:
```
async function handleSignInWithGoogle(response) {
  const { data, error } = await supabase.auth.signInWithIdToken({
    provider: 'google',
    token: response.credential,
    nonce: '<NONCE>',
  })
}
```

----------------------------------------

TITLE: Enable Row Level Security and Public Read Policy for Places Table
DESCRIPTION: Enables Row Level Security (RLS) on the public.places table and creates a policy that grants public read access to all users. This makes the places data publicly available for consumption.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2024-06-26-postgis-generate-vector-tiles.mdx#_snippet_4

LANGUAGE: sql
CODE:
```
ALTER TABLE "public"."places" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable read access for all users" ON "public"."places" FOR SELECT USING (true);
```

----------------------------------------

TITLE: Implement Supabase File Upload with Dropzone Component
DESCRIPTION: This TypeScript React snippet demonstrates how to integrate the Dropzone component with Supabase Storage for file uploads. It utilizes the `useSupabaseUpload` hook to configure the target bucket, path, allowed MIME types, and limits on file size and count. The component renders a Dropzone with an empty state and content areas for user interaction.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/ui-library/content/docs/nextjs/dropzone.mdx#_snippet_0

LANGUAGE: tsx
CODE:
```
'use client'

import { Dropzone, DropzoneContent, DropzoneEmptyState } from '@/components/dropzone'
import { useSupabaseUpload } from '@/hooks/use-supabase-upload'

const FileUploadDemo = () => {
  const props = useSupabaseUpload({
    bucketName: 'test',
    path: 'test',
    allowedMimeTypes: ['image/*'],
    maxFiles: 2,
    maxFileSize: 1000 * 1000 * 10, // 10MB,
  })

  return (
    <div className="w-[500px]">
      <Dropzone {...props}>
        <DropzoneEmptyState />
        <DropzoneContent />
      </Dropzone>
    </div>
  )
}

export { FileUploadDemo }
```

----------------------------------------

TITLE: Supabase Auth: Retrieve User JWT Claims
DESCRIPTION: This API documentation describes the `auth.jwt()` function, which allows retrieval of the current user's JSON Web Token (JWT) claims. It also notes the upcoming deprecation of `auth.email()` and `auth.role()` in favor of this new function.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-07-05-beta-update-june-2022.mdx#_snippet_1

LANGUAGE: APIDOC
CODE:
```
auth.jwt()
  Description: Returns the current user's JWT claims.
  Note: Deprecates auth.email() and auth.role() functions.
```

----------------------------------------

TITLE: Create Stripe Products Foreign Table
DESCRIPTION: Defines a foreign table `stripe.stripe_products` to connect to Stripe's products, specifying columns such as ID, name, active status, price, description, creation/update timestamps, and additional attributes. It connects to the `stripe_fdw_server` and maps to the 'products' object with 'id' as the row ID column.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/extensions/wrappers/overview.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create foreign table stripe.stripe_products (
  id text,
  name text,
  active bool,
  default_price text,
  description text,
  created timestamp,
  updated timestamp,
  attrs jsonb
)
  server stripe_fdw_server
  options (
    object 'products',
    rowid_column 'id'
  );
```

----------------------------------------

TITLE: Seeding Initial Role Permissions in SQL
DESCRIPTION: This SQL insert statement populates the `role_permissions` table with initial data, defining which permissions are granted to the 'admin' and 'moderator' roles. It assigns 'channels.delete' and 'messages.delete' to 'admin', and only 'messages.delete' to 'moderator', establishing the base access control rules.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/postgres/custom-claims-and-role-based-access-control-rbac.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
insert into public.role_permissions (role, permission)
values
  ('admin', 'channels.delete'),
  ('admin', 'messages.delete'),
  ('moderator', 'messages.delete');
```

----------------------------------------

TITLE: Create Public Profiles Table with RLS and Auth Users Reference
DESCRIPTION: This SQL snippet demonstrates how to create a `public.profiles` table that references the `auth.users` table with `on delete cascade` and enables Row Level Security (RLS). This allows secure access to user data via the API while maintaining data integrity with Supabase's authentication system.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/managing-user-data.mdx#_snippet_0

LANGUAGE: SQL
CODE:
```
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  first_name text,
  last_name text,

  primary key (id)
);

alter table public.profiles enable row level security;
```

----------------------------------------

TITLE: Initialize Supabase client in Flutter
DESCRIPTION: Open `lib/main.dart` and edit the main function to initialize Supabase using your project URL and public API (anon) key.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/quickstarts/flutter.mdx#_snippet_2

LANGUAGE: dart
CODE:
```
import 'package:supabase_flutter/supabase_flutter.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Supabase.initialize(
    url: 'YOUR_SUPABASE_URL',
    anonKey: 'YOUR_SUPABASE_ANON_KEY',
  );
  runApp(MyApp());
}
```

----------------------------------------

TITLE: Understanding RLS USING Clause Appending to WHERE
DESCRIPTION: Illustrates how the Row-Level Security (RLS) `USING` clause implicitly appends its condition to an existing SQL `WHERE` statement, filtering rows based on criteria like user ID (e.g., `auth.uid()`). This ensures only authorized rows are visible to the query.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-simplified-BJTcS8.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
-- Your Using condition
USING (
  (select auth.uid()) = user_id
);

-- Your query without RLS:
SELECT * FROM some_table
WHERE id = 5 OR id = 6;

-- Your query after RLS
SELECT * FROM some_table
WHERE
  (id = 5 OR id = 6)
    AND
  (select auth.uid()) = user_id) -- <--- added by the USING clause;
```

----------------------------------------

TITLE: Supabase Client Mapping for Migration from Auth Helpers to SSR
DESCRIPTION: This section provides a direct mapping of client creation functions from the `@supabase/auth-helpers-nextjs` package to their equivalent utility functions in the `@supabase/ssr` package. This helps developers quickly identify the correct replacement for various Next.js environments during migration.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/how-to-migrate-from-supabase-auth-helpers-to-ssr-package-5NRunM.mdx#_snippet_8

LANGUAGE: APIDOC
CODE:
```
createMiddlewareClient → createServerClient
createClientComponentClient → createBrowserClient
createServerComponentClient → createServerClient
createRouteHandlerClient → createServerClient
```

----------------------------------------

TITLE: Create PostgreSQL Full-Text Search Column and GIN Index
DESCRIPTION: This snippet outlines the process of adding a `tsvector` column named `fts` to a PostgreSQL table (e.g., `books`). It leverages PostgreSQL's generated columns feature to automatically populate and update the `fts` column based on the content of other columns like `title` and `description`. Additionally, it demonstrates how to create a GIN index on the `fts` column to optimize full-text search query performance.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/database/full-text-search.mdx#_snippet_15

LANGUAGE: SQL
CODE:
```
alter table
  books
add column
  fts tsvector generated always as (to_tsvector('english', description || ' ' || title)) stored;

create index books_fts on books using gin (fts); -- generate the index

select id, fts
from books;
```

----------------------------------------

TITLE: Creating Supabase Client in Client Components
DESCRIPTION: Illustrates the usage of `createClientComponentClient` from `@supabase/auth-helpers-nextjs` within a React Client Component. This function now returns a singleton instance of the Supabase client by default, simplifying client management.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_21

LANGUAGE: jsx
CODE:
```
"use client";

import { createClientComponentClient } from "@supabase/auth-helpers-nextjs";

export default function() {
  const supabase = createClientComponentClient();
  return ...
}
```

----------------------------------------

TITLE: React Component to Conditionally Show Supabase MFA Challenge
DESCRIPTION: This React component, `AppWithMFA`, wraps the main application logic to check the user's Authenticator Assurance Level (AAL) using `supabase.auth.mfa.getAuthenticatorAssuranceLevel()`. If the current AAL can be upgraded to 'aal2', it conditionally renders the `AuthMFA` component for the challenge; otherwise, it renders the main `App` component. A `readyToShow` state ensures the AAL check completes before any UI is displayed.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-mfa/totp.mdx#_snippet_3

LANGUAGE: tsx
CODE:
```
function AppWithMFA() {
  const [readyToShow, setReadyToShow] = useState(false)
  const [showMFAScreen, setShowMFAScreen] = useState(false)

  useEffect(() => {
    ;(async () => {
      try {
        const { data, error } = await supabase.auth.mfa.getAuthenticatorAssuranceLevel()
        if (error) {
          throw error
        }

        console.log(data)

        if (data.nextLevel === 'aal2' && data.nextLevel !== data.currentLevel) {
          setShowMFAScreen(true)
        }
      } finally {
        setReadyToShow(true)
      }
    })()
  }, [])

  if (readyToShow) {
    if (showMFAScreen) {
      return <AuthMFA />
    }

    return <App />
  }

  return <></>
}
```

----------------------------------------

TITLE: Example MCP Tool Definition Schema
DESCRIPTION: This JSON schema illustrates the standard format for defining a tool within the Model Context Protocol (MCP). It specifies the tool's name, a descriptive purpose, and its parameters, including their types and whether they are required, enabling LLMs to understand and invoke the tool.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-04-04-mcp-server.mdx#_snippet_1

LANGUAGE: APIDOC
CODE:
```
{
  "name": "get_weather",
  "description": "Get the current weather for a specific location",
  "parameters": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "The city and state/country, e.g. 'San Francisco, CA' or 'Paris, France'"
      }
    },
    "required": ["location"]
  }
}
```

----------------------------------------

TITLE: Initialize Next.js Project with Supabase SSR
DESCRIPTION: Demonstrates how to initialize a new Next.js project with Supabase SSR support, compatible with Next.js 14. This command uses the `create-next-app` utility with the `with-supabase` example to set up the project with the necessary configurations for server-side authentication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-11-06-beta-update-october-2023.mdx#_snippet_0

LANGUAGE: Shell
CODE:
```
npx create-next-app -e with-supabase
```

----------------------------------------

TITLE: Kotlin Product Details ViewModel with Hilt and StateFlow
DESCRIPTION: This Hilt-annotated ViewModel manages the state and logic for a product details screen. It uses `MutableStateFlow` to expose product data, handles fetching product details from a repository, and provides functions for updating product name, price, and saving changes, including image handling. It also includes a mapping function from DTO to domain model.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-kotlin.mdx#_snippet_20

LANGUAGE: kotlin
CODE:
```
@HiltViewModel
class ProductDetailsViewModel @Inject constructor(
    private val productRepository: ProductRepository,
    savedStateHandle: SavedStateHandle,
    ) : ViewModel() {

    private val _product = MutableStateFlow<Product?>(null)
    val product: Flow<Product?> = _product

    private val _name = MutableStateFlow("")
    val name: Flow<String> = _name

    private val _price = MutableStateFlow(0.0)
    val price: Flow<Double> = _price

    private val _imageUrl = MutableStateFlow("")
    val imageUrl: Flow<String> = _imageUrl

    init {
        val productId = savedStateHandle.get<String>(ProductDetailsDestination.productId)
        productId?.let {
            getProduct(productId = it)
        }
    }

    private fun getProduct(productId: String) {
        viewModelScope.launch {
           val result = productRepository.getProduct(productId).asDomainModel()
            _product.emit(result)
            _name.emit(result.name)
            _price.emit(result.price)
        }
    }

    fun onNameChange(name: String) {
        _name.value = name
    }

    fun onPriceChange(price: Double) {
        _price.value = price
    }

    fun onSaveProduct(image: ByteArray) {
        viewModelScope.launch {
            productRepository.updateProduct(
                id = _product.value?.id,
                price = _price.value,
                name = _name.value,
                imageFile = image,
                imageName = "image_${_product.value.id}",
            )
        }
    }

    fun onImageChange(url: String) {
        _imageUrl.value = url
    }

    private fun ProductDto.asDomainModel(): Product {
        return Product(
            id = this.id,
            name = this.name,
            price = this.price,
            image = this.image
        )
    }
}
```

----------------------------------------

TITLE: Implement SvelteKit Server-Side Logic for Account Page
DESCRIPTION: This TypeScript file (src/routes/account/+page.server.ts) handles the backend operations for the account page. It includes a load function to fetch the user's profile data from Supabase and actions to process form submissions for profile updates and user sign-out. It integrates with Supabase for data persistence and authentication, using SvelteKit's fail and redirect for flow control.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-sveltekit.mdx#_snippet_16

LANGUAGE: typescript
CODE:
```
import { fail, redirect } from '@sveltejs/kit'
import type { Actions, PageServerLoad } from './$types'

export const load: PageServerLoad = async ({ locals: { supabase, safeGetSession } }) => {
  const { session } = await safeGetSession()

  if (!session) {
    redirect(303, '/')
  }

  const { data: profile } = await supabase
    .from('profiles')
    .select(`username, full_name, website, avatar_url`)
    .eq('id', session.user.id)
    .single()

  return { session, profile }
}

export const actions: Actions = {
  update: async ({ request, locals: { supabase, safeGetSession } }) => {
    const formData = await request.formData()
    const fullName = formData.get('fullName') as string
    const username = formData.get('username') as string
    const website = formData.get('website') as string
    const avatarUrl = formData.get('avatarUrl') as string

    const { session } = await safeGetSession()

    const { error } = await supabase.from('profiles').upsert({
      id: session?.user.id,
      full_name: fullName,
      username,
      website,
      avatar_url: avatarUrl,
      updated_at: new Date(),
    })

    if (error) {
      return fail(500, {
        fullName,
        username,
        website,
        avatarUrl,
      })
    }

    return {
      fullName,
      username,
      website,
      avatarUrl,
    }
  },
  signout: async ({ locals: { supabase, safeGetSession } }) => {
    const { session } = await safeGetSession()
    if (session) {
      await supabase.auth.signOut()
      redirect(303, '/')
    }
  },
}
```

----------------------------------------

TITLE: Handle User Logout in Next.js Route Handler with Supabase
DESCRIPTION: This code defines a Next.js API route handler for user logout. It uses `createRouteHandlerClient` to access the Supabase client, signs out the user, and then redirects them to the login page. It demonstrates how to manage user sessions securely on the server side.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_7

LANGUAGE: JavaScript
CODE:
```
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

export async function POST(request) {
  const requestUrl = new URL(request.url)
  const cookieStore = cookies()
  const supabase = createRouteHandlerClient({ cookies: () => cookieStore })

  await supabase.auth.signOut()

  return NextResponse.redirect(`${requestUrl.origin}/login`, {
    status: 301,
  })
}
```

LANGUAGE: TypeScript
CODE:
```
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

import type { Database } from '@/lib/database.types'

export async function POST(request: Request) {
  const requestUrl = new URL(request.url)
  const cookieStore = cookies()
  const supabase = createRouteHandlerClient<Database>({ cookies: () => cookieStore })

  await supabase.auth.signOut()

  return NextResponse.redirect(`${requestUrl.origin}/login`, {
    status: 301,
  })
}
```

----------------------------------------

TITLE: Deno Hook for Conditional WhatsApp/SMS Messaging with Twilio
DESCRIPTION: This TypeScript code implements a Deno serverless function that acts as a webhook. It integrates with Twilio to send messages, dynamically selecting between WhatsApp and SMS based on the recipient's country code. Numbers identified as Latin American receive WhatsApp messages, while all others receive SMS. The hook verifies incoming requests using `standardwebhooks` and manages the Twilio API calls for message dispatch, including error handling and response formatting.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-hooks/send-sms-hook.mdx#_snippet_11

LANGUAGE: TypeScript
CODE:
```
import { Webhook } from "https://esm.sh/standardwebhooks@1.0.0";
import { readAll } from "https://deno.land/std/io/read_all.ts";
import * as base64 from "https://denopkg.com/chiefbiiko/base64/mod.ts";

const accountSid: string | undefined = Deno.env.get("TWILIO_ACCOUNT_SID");
const authToken: string | undefined = Deno.env.get("TWILIO_AUTH_TOKEN");
const fromNumber: string = Deno.env.get("TWILIO_WHATSAPP_NUMBER");
const smsFromNumber: string = Deno.env.get("TWILIO_SMS_NUMBER");

const latinAmericanCountryCodes = ['54', '55', '56', '57', '58', '501', '502', '503', '504', '505', '506', '507', '508', '509', '51', '52', '53', '591', '592', '593', '594', '595', '596', '597', '598', '599'];

const sendMessage = async (
    messageBody: string,
    accountSid: string | undefined,
    authToken: string | undefined,
    fromNumber: string,
    toNumber: string,
    useWhatsApp: boolean,
): Promise < any > => {
    if (!accountSid || !authToken) {
        console.log("Your Twilio account credentials are missing. Please add them.");
        return;
    }
    const url: string = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;

    const encodedCredentials: string = base64.fromUint8Array(
        new TextEncoder().encode(`${accountSid}:${authToken}`),
    );

    const body: URLSearchParams = new URLSearchParams({
        To: useWhatsApp ? `whatsapp:${toNumber}` : toNumber,
        From: useWhatsApp ? `whatsapp:${fromNumber}` : smsFromNumber,
        Body: messageBody,
    });

    const response = await fetch(url, {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            "Authorization": `Basic ${encodedCredentials}`,
        },
        body,
    });

    return response.json();
};

Deno.serve(async (req) => {
    const payload = await req.text();
    const base64_secret = Deno.env.get("SEND_SMS_HOOK_SECRET").replace('v1,whsec_', '');
    const headers = Object.fromEntries(req.headers);
    const wh = new Webhook(base64_secret);
    try {
        const {
            user,
            sms
        } = wh.verify(payload, headers);
        const messageBody = `Your OTP is: ${sms.otp}`;
        const userPhoneNumber = user.phone;
        const countryCode = userPhoneNumber.substring(1, userPhoneNumber.indexOf(userPhoneNumber.match(/\d/)!));

        const useWhatsApp = latinAmericanCountryCodes.includes(countryCode);

        const response = await sendMessage(
            messageBody,
            accountSid,
            authToken,
            fromNumber,
            userPhoneNumber,
            useWhatsApp,
        );

        if (response.status !== "queued") {
            return new Response(
                JSON.stringify({
                    error: `Failed to send message, Error Code: ${response.code} ${response.message} ${response.more_info}`,
                }), {
                    status: response.status,
                    headers: {
                        "Content-Type": "application/json"
                    }
                },
            );
        }
        return new Response(
            JSON.stringify({
                message: "Message sent successfully."
            }), {
                headers: {
                    "Content-Type": "application/json"
                }
            },
        );
    } catch (error) {
        return new Response(
            JSON.stringify({
                error: `Failed to process the request: ${error}`
            }), {
                status: 500,
                headers: {
                    "Content-Type": "application/json"
                }
            },
        );
    }
});
```

----------------------------------------

TITLE: Apply Migrations to Local Database
DESCRIPTION: Apply all migration scripts to your local database. This command recreates your local database from scratch and applies all scripts under the `supabase/migrations` directory, ensuring your local database is up to date.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/deployment/managing-environments.mdx#_snippet_6

LANGUAGE: bash
CODE:
```
supabase db reset
```

----------------------------------------

TITLE: Sign Out User Across Multiple Languages with Supabase
DESCRIPTION: This snippet demonstrates the fundamental process of signing out a user using the Supabase client library. The `signOut` method terminates the active session and clears associated authentication data from the local storage medium, ensuring a complete logout regardless of the initial sign-in method.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/signout.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('https://your-project-id.supabase.co', 'your-anon-key')

// ---cut---
async function signOut() {
  const { error } = await supabase.auth.signOut()
}
```

LANGUAGE: Dart
CODE:
```
Future<void> signOut() async {
   await supabase.auth.signOut();
}
```

LANGUAGE: Swift
CODE:
```
try await supabase.auth.signOut()
```

LANGUAGE: Kotlin
CODE:
```
suspend fun logout() {
	supabase.auth.signOut()
}
```

LANGUAGE: Python
CODE:
```
supabase.auth.sign_out()
```

----------------------------------------

TITLE: Sign out from Supabase session
DESCRIPTION: This code demonstrates how to sign out a user from their current Supabase session. It removes the user from the browser session and clears any related objects from local storage, ensuring a complete logout.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/social-login/auth-discord.mdx#_snippet_1

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('https://your-project-id.supabase.co', 'your-anon-key')

async function signOut() {
  const { error } = await supabase.auth.signOut()
}
```

LANGUAGE: Dart
CODE:
```
Future<void> signOut() async {
  await supabase.auth.signOut();
}
```

LANGUAGE: Kotlin
CODE:
```
suspend fun signOut() {
	supabase.auth.signOut()
}
```

----------------------------------------

TITLE: Sign up user with email and password using Implicit Flow
DESCRIPTION: Demonstrates how to sign up a new user using their email and password with the implicit flow. This flow is typically used for client-only applications where the access token is directly received after email confirmation. Optionally, a redirect URL can be specified for post-confirmation redirection, which must be configured in the Supabase dashboard or configuration file.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/passwords.mdx#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { createClient } from '@supabase/supabase-js'
const supabase = createClient('https://your-project.supabase.co', 'your-anon-key')

// ---cut---
async function signUpNewUser() {
  const { data, error } = await supabase.auth.signUp({
    email: 'valid.email@supabase.io',
    password: 'example-password',
    options: {
      emailRedirectTo: 'https://example.com/welcome',
    },
  })
}
```

LANGUAGE: Dart
CODE:
```
Future<void> signUpNewUser() async {
  final AuthResponse res = await supabase.auth.signUp(
    email: 'valid.email@supabase.io',
    password: 'example-password'
  );
}
```

LANGUAGE: Swift
CODE:
```
let response = try await supabase.auth.signUp(
  email: "valid.email@supabase.io",
  password: "example-password",
  redirectTo: URL(string: "https://example.com/welcome")
)
```

LANGUAGE: Kotlin
CODE:
```
suspend fun signUpNewUser() {
	supabase.auth.signUpWith(Email) {
		email = "valid.email@supabase.io"
		password = "example-password"
	}
}
```

LANGUAGE: Python
CODE:
```
data = await supabase.auth.sign_up({
  'email': 'valid.email@supabase.io',
  'password': 'example-password',
  'options': {
    'email_redirect_to': 'https://example.com/welcome',
  },
})
```

----------------------------------------

TITLE: Implement WebSocket Server in Deno and Node.js
DESCRIPTION: Examples demonstrating how to set up basic WebSocket servers using Deno and Node.js APIs within Edge Functions, handling connection upgrades, messages, errors, and closures for bi-directional communication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/functions/websockets.mdx#_snippet_0

LANGUAGE: typescript
CODE:
```
Deno.serve((req) => {
  const upgrade = req.headers.get('upgrade') || ''

  if (upgrade.toLowerCase() != 'WebSocket') {
    return new Response("request isn't trying to upgrade to WebSocket.", { status: 400 })
  }

  const { socket, response } = Deno.upgradeWebSocket(req)

  socket.onopen = () => console.log('socket opened')
  socket.onmessage = (e) => {
    console.log('socket message:', e.data)
    socket.send(new Date().toString())
  }

  socket.onerror = (e) => console.log('socket errored:', e.message)
  socket.onclose = () => console.log('socket closed')

  return response
})
```

LANGUAGE: typescript
CODE:
```
import { createServer } from "node:http";
import { WebSocketServer } from "npm:ws";

const server = createServer();
// Since we manually created the HTTP server,
// turn on the noServer mode.
const wss = new WebSocketServer({ noServer: true });

wss.on("connection", ws => {
console.log("socket opened");
ws.on("message", (data /** Buffer \*/, isBinary /** bool \*/) => {
if (isBinary) {
console.log("socket message:", data);
} else {
console.log("socket message:", data.toString());
}

        ws.send(new Date().toString());
    });

    ws.on("error", err => {
        console.log("socket errored:", err.message);
    });

    ws.on("close", () => console.log("socket closed"));

});

server.on("upgrade", (req, socket, head) => {
wss.handleUpgrade(req, socket, head, ws => {
wss.emit("connection", ws, req);
});
});

server.listen(8080);
```

----------------------------------------

TITLE: Enable pgvector extension in Supabase
DESCRIPTION: Adds the `pgvector` extension to the public schema of the database. This extension is essential for enabling vector similarity search capabilities within PostgreSQL.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/examples/nextjs-vector-search.mdx#_snippet_2

LANGUAGE: sql
CODE:
```
-- Enable pgvector extension
create extension if not exists vector with schema public;
```

----------------------------------------

TITLE: Implement Android MainActivity with Jetpack Compose Navigation
DESCRIPTION: This code snippet shows the `MainActivity` implementation for an Android application using Jetpack Compose. It sets up a `NavHost` to manage navigation between different screens, including product listing, authentication, sign-up, adding products, and product details. The `NavHost` defines composable routes for each destination, allowing the app to navigate seamlessly between different UI flows. It also demonstrates dependency injection with `@Inject` for `SupabaseClient`.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-kotlin.mdx#_snippet_33

LANGUAGE: Kotlin
CODE:
```
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @Inject
    lateinit var supabaseClient: SupabaseClient

    @OptIn(ExperimentalMaterial3Api::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ManageProductsTheme {
                // A surface container using the 'background' color from the theme
                val navController = rememberNavController()
                val currentBackStack by navController.currentBackStackEntryAsState()
                val currentDestination = currentBackStack?.destination
                Scaffold { innerPadding ->
                    NavHost(
                        navController,
                        startDestination = ProductListDestination.route,
                        Modifier.padding(innerPadding)
                    ) {
                        composable(ProductListDestination.route) {
                            ProductListScreen(
                                navController = navController
                            )
                        }

                        composable(AuthenticationDestination.route) {
                            SignInScreen(
                                navController = navController
                            )
                        }

                        composable(SignUpDestination.route) {
                            SignUpScreen(
                                navController = navController
                            )
                        }

                        composable(AddProductDestination.route) {
                            AddProductScreen(
                                navController = navController
                            )
                        }

                        composable(
                            route = "${ProductDetailsDestination.route}/{${ProductDetailsDestination.productId}}",
                            arguments = ProductDetailsDestination.arguments
                        ) { navBackStackEntry ->
                            val productId =
                                navBackStackEntry.arguments?.getString(ProductDetailsDestination.productId)
                            ProductDetailsScreen(
                                productId = productId,
                                navController = navController,
                            )
                        }
                    }
                }
            }
        }
    }
}
```

----------------------------------------

TITLE: Fetch Data in Next.js Server Component with Supabase
DESCRIPTION: This snippet demonstrates how to fetch data from Supabase within a Next.js Server Component. It uses `createServerComponentClient` to initialize the Supabase client with `next/headers` cookies, allowing for server-side data retrieval from a 'todos' table.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs.mdx#_snippet_12

LANGUAGE: jsx
CODE:
```
import { cookies } from 'next/headers'
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'

export default async function Page() {
  const cookieStore = cookies()
  const supabase = createServerComponentClient({ cookies: () => cookieStore })
  const { data } = await supabase.from('todos').select()
  return <pre>{JSON.stringify(data, null, 2)}</pre>
}
```

LANGUAGE: tsx
CODE:
```
import { cookies } from 'next/headers'
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs'

import type { Database } from '@/lib/database.types'

export default async function ServerComponent() {
  const cookieStore = cookies()
  const supabase = createServerComponentClient<Database>({ cookies: () => cookieStore })
  const { data } = await supabase.from('todos').select()
  return <pre>{JSON.stringify(data, null, 2)}</pre>
}
```

----------------------------------------

TITLE: Configure Supabase Environment Variables
DESCRIPTION: Before running the application, rename the example environment file and update it with your specific Supabase project URL and anonymous key. These variables are crucial for connecting your Next.js app to your Supabase backend.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/auth/nextjs/README.md#_snippet_2

LANGUAGE: plaintext
CODE:
```
NEXT_PUBLIC_SUPABASE_URL=[INSERT SUPABASE PROJECT URL]
NEXT_PUBLIC_SUPABASE_ANON_KEY=[INSERT SUPABASE PROJECT API ANON KEY]
```

----------------------------------------

TITLE: Set up the Postgres connection details
DESCRIPTION: This step guides you through setting up the database connection. After creating a Supabase project and obtaining the Session Pooler connection string, you export it as the `DATABASE_URL` environment variable. This variable is crucial for Rails to connect to your Supabase Postgres database, ensuring secure and proper communication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/quickstarts/ruby-on-rails.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
export DATABASE_URL=postgres://postgres.xxxx:password@xxxx.pooler.supabase.com:5432/postgres
```

----------------------------------------

TITLE: Supabase Data Service for Board Operations
DESCRIPTION: This TypeScript service, `DataService`, provides methods for interacting with Supabase. It initializes a Supabase client using environment variables. Key functionalities include `startBoard()` to insert a new, empty board into the `boards` table and `getBoards()` to retrieve user-specific boards from `user_boards`, joining with `boards` to fetch titles and IDs. It also defines constants for various table names.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-08-24-building-a-realtime-trello-board-with-supabase-and-angular.mdx#_snippet_20

LANGUAGE: ts
CODE:
```
import { Injectable } from '@angular/core'
import { SupabaseClient, createClient } from '@supabase/supabase-js'
import { environment } from 'src/environments/environment'

export const BOARDS_TABLE = 'boards'
export const USER_BOARDS_TABLE = 'user_boards'
export const LISTS_TABLE = 'lists'
export const CARDS_TABLE = 'cards'
export const USERS_TABLE = 'users'

@Injectable({
  providedIn: 'root',
})
export class DataService {
  private supabase: SupabaseClient

  constructor() {
    this.supabase = createClient(environment.supabaseUrl, environment.supabaseKey)
  }

  async startBoard() {
    // Minimal return will be the default in the next version and can be removed here!
    return await this.supabase.from(BOARDS_TABLE).insert({}, { returning: 'minimal' })
  }

  async getBoards() {
    const boards = await this.supabase.from(USER_BOARDS_TABLE).select(`
    boards:board_id ( title, id )
  `)
    return boards.data || []
  }
}
```

----------------------------------------

TITLE: Implement Edge Function Request Handler for Embeddings
DESCRIPTION: Modify the Edge Function's request handler to process a POST request. It extracts an `input` string from the JSON body, generates a normalized and mean-pooled text embedding using the `session.run()` method, and returns the embedding as a JSON response.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/ai/quickstarts/generate-text-embeddings.mdx#_snippet_3

LANGUAGE: ts
CODE:
```
Deno.serve(async (req) => {
  // Extract input string from JSON body
  const { input } = await req.json();

  // Generate the embedding from the user input
  const embedding = await session.run(input, {
    mean_pool: true,
    normalize: true,
  });

  // Return the embedding
  return new Response(
    JSON.stringify({ embedding }),
    { headers: { 'Content-Type': 'application/json' } }
  );
});
```

----------------------------------------

TITLE: Define Todos Table and Row Level Security Policies in Postgres
DESCRIPTION: This SQL snippet defines a 'todos' table with columns for ID, user ID, task, completion status, and insertion timestamp. It then enables Row Level Security (RLS) on the table and establishes four policies: allowing individuals to create, view, update, and delete only their own todo items based on their authenticated user ID (auth.uid()).
SOURCE: https://github.com/supabase/supabase/blob/master/examples/todo-list/nextjs-todo-list/README.md#_snippet_1

LANGUAGE: SQL
CODE:
```
create table todos (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  task text check (char_length(task) > 3),
  is_complete boolean default false,
  inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table todos enable row level security;

create policy "Individuals can create todos." on todos for
    insert with check ((select auth.uid()) = user_id);

create policy "Individuals can view their own todos. " on todos for
    select using ((select auth.uid()) = user_id);

create policy "Individuals can update their own todos." on todos for
    update using ((select auth.uid()) = user_id);

create policy "Individuals can delete their own todos." on todos for
    delete using ((select auth.uid()) = user_id);
```

----------------------------------------

TITLE: Postgres Row Level Security Policies for Todos Table
DESCRIPTION: Defines the `todos` table schema including `id`, `user_id`, `task`, `is_complete`, and `inserted_at` columns. It then enables Row Level Security and establishes four policies: allowing individuals to create, view, update, and delete only their own todo items by checking `auth.uid()` against the `user_id` column.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/todo-list/sveltejs-todo-list/README.md#_snippet_0

LANGUAGE: SQL
CODE:
```
create table todos (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  task text check (char_length(task) > 3),
  is_complete boolean default false,
  inserted_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table todos enable row level security;

create policy "Individuals can create todos." on todos for
    insert with check ((select auth.uid()) = user_id);

create policy "Individuals can view their own todos. " on todos for
    select using ((select auth.uid()) = user_id);

create policy "Individuals can update their own todos." on todos for
    update using ((select auth.uid()) = user_id);

create policy "Individuals can delete their own todos." on todos for
    delete using ((select auth.uid()) = user_id);
```

----------------------------------------

TITLE: Calling a Supabase Edge Function with Fetch
DESCRIPTION: This code demonstrates how to invoke a Supabase Edge Function from a client-side application using the JavaScript `fetch` API. It includes setting the content type, passing an authorization token, and sending a JSON payload.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2025-05-17-simplify-backend-with-data-api.mdx#_snippet_6

LANGUAGE: tsx
CODE:
```
const customerId = 'uuid-of-customer' // Replace with actual customer ID
const projectRef = 'your-project-ref' // e.g. abcdefg.supabase.co
const functionName = 'send-discount'

const response = await fetch(`https://${projectRef}.functions.supabase.co/${functionName}`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: `Bearer your-access-token`, // From Supabase Auth
  },
  body: JSON.stringify({
    customer_id: customerId,
  }),
})
```

----------------------------------------

TITLE: Call optimized object listing function
DESCRIPTION: Examples demonstrating how to invoke the custom `list_objects` Postgres function to retrieve objects from a specified bucket with pagination. This can be done directly via SQL or using the Supabase JavaScript SDK's `rpc` method.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/storage/production/scaling.mdx#_snippet_1

LANGUAGE: sql
CODE:
```
select * from list_objects('bucket_id', '', 100, 0);
```

LANGUAGE: js
CODE:
```
const { data, error } = await supabase.rpc('list_objects', {
  bucketid: 'yourbucket',
  prefix: '',
  limit: 100,
  offset: 0,
})
```

----------------------------------------

TITLE: Call Postgres Function from Browser with supabase-js
DESCRIPTION: This JavaScript snippet shows how to invoke the `match_images` Postgres function directly from a web browser using the `supabase-js` client library's `rpc` method. It passes the `query_embedding`, `match_threshold`, and `match_count` parameters and retrieves the matching image data.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-08-07-hugging-face-supabase.mdx#_snippet_6

LANGUAGE: js
CODE:
```
let { data: images, error } = await supabase.rpc('match_images', {
  query_embedding,
  match_threshold,
  match_count,
})
```

----------------------------------------

TITLE: Listen to Postgres Database Changes with Supabase Realtime in Dart (v1 vs v2)
DESCRIPTION: Supabase v2 replaces the generic `.on()` method with `.onPostgresChanges()` for listening to database changes. This new method enforces strong typing for filters, accepting an object instead of a string, and provides a strictly typed `PostgresChangePayload` object in the callback, which includes `oldRecord` and `newRecord` properties for direct data access.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/dart/upgrade-guide.mdx#_snippet_13

LANGUAGE: dart
CODE:
```
supabase.channel('my_channel').on(
  RealtimeListenTypes.postgresChanges,
  ChannelFilter(
    event: '*',
    schema: 'public',
    table: 'messages',
    filter: 'room_id=eq.200',
  ),
  (dynamic payload, [ref]) {
    final Map<String, dynamic> newRecord = payload['new'];
    final Map<String, dynamic> oldRecord = payload['old'];
  },
).subscribe();
```

LANGUAGE: dart
CODE:
```
supabase.channel('my_channel')
  .onPostgresChanges(
    event: PostgresChangeEvent.all,
    schema: 'public',
    table: 'messages',
    filter: PostgresChangeFilter(
      type: PostgresChangeFilterType.eq,
      column: 'room_id',
      value: 200,
    ),
    callback: (PostgresChangePayload payload) {
      final Map<String, dynamic> newRecord = payload.newRecord;
      final Map<String, dynamic> oldRecord = payload.oldRecord;
    })
  .subscribe();
```

----------------------------------------

TITLE: Complete Refine AuthProvider Configuration for Supabase Magic Link
DESCRIPTION: This code defines the full `authProvider` object for a Refine application, integrating Supabase for authentication. It includes `login` (using `signInWithOtp`), `logout`, `onError`, `check` (to verify session status), and `getIdentity` methods, providing a comprehensive authentication solution.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-refine.mdx#_snippet_7

LANGUAGE: ts
CODE:
```
import { AuthBindings } from '@refinedev/core'

import { supabaseClient } from './utility'

const authProvider: AuthBindings = {
  login: async ({ email }) => {
    try {
      const { error } = await supabaseClient.auth.signInWithOtp({ email })

      if (!error) {
        alert('Check your email for the login link!')
        return {
          success: true,
        }
      }

      throw error
    } catch (e: any) {
      alert(e.message)
      return {
        success: false,
        e,
      }
    }
  },
  logout: async () => {
    const { error } = await supabaseClient.auth.signOut()

    if (error) {
      return {
        success: false,
        error,
      }
    }

    return {
      success: true,
      redirectTo: '/',
    }
  },
  onError: async (error) => {
    console.error(error)
    return { error }
  },
  check: async () => {
    try {
      const { data } = await supabaseClient.auth.getSession()
      const { session } = data

      if (!session) {
        return {
          authenticated: false,
          error: {
            message: 'Check failed',
            name: 'Session not found',
          },
          logout: true,
          redirectTo: '/login',
        }
      }
    } catch (error: any) {
      return {
        authenticated: false,
        error: error || {
          message: 'Check failed',
          name: 'Not authenticated',
        },
        logout: true,
        redirectTo: '/login',
      }
    }

    return {
      authenticated: true,
    }
  },
  getIdentity: async () => {
    const { data } = await supabaseClient.auth.getUser()

    if (data?.user) {
      return {
        ...data.user,
        name: data.user.email,
      }
    }

    return null
  },
}

export default authProvider
```

----------------------------------------

TITLE: Update and return data with Supabase
DESCRIPTION: Illustrates how to update existing data in a Supabase table. The 'Before' example performs a basic update, and the 'After' example adds '.select()' to return the updated rows.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/docs/ref/javascript/v1/upgrade-guide.mdx#_snippet_14

LANGUAGE: ts
CODE:
```
const { data, error } = await supabase
  .from('my_table')
  .update({ new_data })
  .eq('id', id)
```

LANGUAGE: ts
CODE:
```
const { data, error } = await supabase
  .from('my_table')
  .update({ new_data })
  .eq('id', id)
  .select()
```

----------------------------------------

TITLE: Assign 'authenticated' role in Cognito Pre-Token Generation Trigger (Node.js)
DESCRIPTION: This Node.js AWS Lambda function is designed to be used as a Cognito Pre-Token Generation Trigger. It modifies the JWT claims by adding or overriding the 'role' claim with the value 'authenticated'. This ensures that when the JWT is sent to a Supabase project, the correct 'authenticated' Postgres role is assigned, enabling access to application logic.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/third-party/aws-cognito.mdx#_snippet_2

LANGUAGE: javascript
CODE:
```
export const handler = async (event) => {
  event.response = {
    claimsOverrideDetails: {
      claimsToAddOrOverride: {
        role: 'authenticated',
      },
    },
  }

  return event
}
```

----------------------------------------

TITLE: Create Supabase Client for Server (JavaScript)
DESCRIPTION: This asynchronous JavaScript utility function, `createClient`, sets up a Supabase client for server-side environments like Server Components, Server Actions, and Route Handlers. It uses `@supabase/ssr`'s `createServerClient` and integrates with `next/headers` cookies to manage user sessions, handling potential errors when setting cookies from Server Components.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-nextjs.mdx#_snippet_5

LANGUAGE: JavaScript
CODE:
```
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  // Create a server's supabase client with newly configured cookie,
  // which could be used to maintain user's session
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        }
      }
    }
  )
}
```

----------------------------------------

TITLE: Utilize Node.js Built-in APIs in Supabase Edge Functions
DESCRIPTION: This snippet illustrates how to incorporate Node.js built-in APIs, specifically `node:crypto` for generating random bytes and `node:http` for creating a server, within a Supabase Edge Function. It demonstrates importing Node modules using the `node:` specifier and setting up a basic HTTP server.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/prompts/edge-functions.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
import { randomBytes } from "node:crypto";
import { createServer } from "node:http";
import process from "node:process";

const generateRandomString = (length) => {
    const buffer = randomBytes(length);
    return buffer.toString('hex');
};

const randomString = generateRandomString(10);
console.log(randomString);

const server = createServer((req, res) => {
    const message = `Hello`;
    res.end(message);
});

server.listen(9999);
```

----------------------------------------

TITLE: Creating RLS Policy for UPDATE with USING and WITH CHECK
DESCRIPTION: Demonstrates how to create a comprehensive Row-Level Security (RLS) policy for `UPDATE` operations, combining both `USING` to filter rows that can be updated and `WITH CHECK` to validate the new values being added to the table. This ensures only authorized users can modify their own data and that modified data adheres to specific rules.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/troubleshooting/rls-simplified-BJTcS8.mdx#_snippet_3

LANGUAGE: sql
CODE:
```
create policy "Allow user to edit their stuff"
on "public"."<SOME TABLE NAME>"
as RESTRICTIVE
for UPDATE
to authenticated
using (
  (select auth.uid()) = user_id
)
with check(
  (select auth.uid()) = user_id
);
```

----------------------------------------

TITLE: Implement LargeSecureStore for Encrypted Supabase Auth Storage
DESCRIPTION: This TypeScript code defines a `LargeSecureStore` class that acts as a custom storage solution for the Supabase client. It encrypts session data using `aes-js` and stores the encryption key in `Expo SecureStore` while the encrypted data resides in `AsyncStorage`, bypassing SecureStore's size limits. The class includes `_encrypt`, `_decrypt`, `getItem`, `removeItem`, and `setItem` methods, and is then passed to the `createClient` function for Supabase authentication.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-11-16-react-native-authentication.mdx#_snippet_3

LANGUAGE: ts
CODE:
```
import 'react-native-url-polyfill/auto'
import { createClient } from '@supabase/supabase-js'
import AsyncStorage from '@react-native-async-storage/async-storage'
import * as SecureStore from 'expo-secure-store'
import * as aesjs from 'aes-js'
import 'react-native-get-random-values'

// As Expo's SecureStore does not support values larger than 2048
// bytes, an AES-256 key is generated and stored in SecureStore, while
// it is used to encrypt/decrypt values stored in AsyncStorage.
class LargeSecureStore {
  private async _encrypt(key: string, value: string) {
    const encryptionKey = crypto.getRandomValues(new Uint8Array(256 / 8))

    const cipher = new aesjs.ModeOfOperation.ctr(encryptionKey, new aesjs.Counter(1))
    const encryptedBytes = cipher.encrypt(aesjs.utils.utf8.toBytes(value))

    await SecureStore.setItemAsync(key, aesjs.utils.hex.fromBytes(encryptionKey))

    return aesjs.utils.hex.fromBytes(encryptedBytes)
  }

  private async _decrypt(key: string, value: string) {
    const encryptionKeyHex = await SecureStore.getItemAsync(key)
    if (!encryptionKeyHex) {
      return encryptionKeyHex
    }

    const cipher = new aesjs.ModeOfOperation.ctr(
      aesjs.utils.hex.toBytes(encryptionKeyHex),
      new aesjs.Counter(1)
    )
    const decryptedBytes = cipher.decrypt(aesjs.utils.hex.toBytes(value))

    return aesjs.utils.utf8.fromBytes(decryptedBytes)
  }

  async getItem(key: string) {
    const encrypted = await AsyncStorage.getItem(key)
    if (!encrypted) {
      return encrypted
    }

    return await this._decrypt(key, encrypted)
  }

  async removeItem(key: string) {
    await AsyncStorage.removeItem(key)
    await SecureStore.deleteItemAsync(key)
  }

  async setItem(key: string, value: string) {
    const encrypted = await this._encrypt(key, value)

    await AsyncStorage.setItem(key, encrypted)
  }
}

const supabaseUrl = YOUR_REACT_NATIVE_SUPABASE_URL
const supabaseAnonKey = YOUR_REACT_NATIVE_SUPABASE_ANON_KEY

const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: new LargeSecureStore(),
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  }
})
```

----------------------------------------

TITLE: React Component for Supabase MFA Enrollment and Verification
DESCRIPTION: This React component, `EnrollMFA`, demonstrates the complete flow for enrolling and verifying a new Multi-Factor Authentication (MFA) factor for the current user using Supabase. It utilizes `supabase.auth.mfa.enroll()` to start enrollment, `supabase.auth.mfa.challenge()` to generate a verification code, and `supabase.auth.mfa.verify()` to submit and validate the user's code. Callbacks `onEnrolled` and `onCancelled` handle completion or cancellation of the enrollment process.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-mfa/phone.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
export function EnrollMFA({
  onEnrolled,
  onCancelled,
}: {
  onEnrolled: () => void
  onCancelled: () => void
}) {
  const [phoneNumber, setPhoneNumber] = useState('')
  const [factorId, setFactorId] = useState('')
  const [verifyCode, setVerifyCode] = useState('')
  const [error, setError] = useState('')
  const [challengeId, setChallengeId] = useState('')

  const onEnableClicked = () => {
    setError('')
    ;(async () => {
      const verify = await auth.mfa.verify({
        factorId,
        challengeId,
        code: verifyCode,
      })
      if (verify.error) {
        setError(verify.error.message)
        throw verify.error
      }

      onEnrolled()
    })()
  }
  const onEnrollClicked = async () => {
    setError('')
    try {
      const factor = await auth.mfa.enroll({
        phone: phoneNumber,
        factorType: 'phone',
      })
      if (factor.error) {
        setError(factor.error.message)
        throw factor.error
      }

      setFactorId(factor.data.id)
    } catch (error) {
      setError('Failed to Enroll the Factor.')
    }
  }

  const onSendOTPClicked = async () => {
    setError('')
    try {
      const challenge = await auth.mfa.challenge({ factorId })
      if (challenge.error) {
        setError(challenge.error.message)
        throw challenge.error
      }

      setChallengeId(challenge.data.id)
    } catch (error) {
      setError('Failed to resend the code.')
    }
  }

  return (
    <>
      {error && <div className="error">{error}</div>}
      <input
        type="text"
        placeholder="Phone Number"
        value={phoneNumber}
        onChange={(e) => setPhoneNumber(e.target.value.trim())}
      />
      <input
        type="text"
        placeholder="Verification Code"
        value={verifyCode}
        onChange={(e) => setVerifyCode(e.target.value.trim())}
      />
      <input type="button" value="Enroll" onClick={onEnrollClicked} />
      <input type="button" value="Submit Code" onClick={onEnableClicked} />
      <input type="button" value="Send OTP Code" onClick={onSendOTPClicked} />
      <input type="button" value="Cancel" onClick={onCancelled} />
    </>
  )
}
```

----------------------------------------

TITLE: Flutter Supabase User Login Page Implementation
DESCRIPTION: This Dart code defines a Flutter `LoginPage` widget. It provides UI elements for email and password input, handles user authentication using `supabase.auth.signInWithPassword()`, and navigates to the MFA verification page upon successful login. Error handling for authentication exceptions is also included.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2023-05-04-flutter-multi-factor-authentication.mdx#_snippet_10

LANGUAGE: dart
CODE:
```
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:mfa_app/main.dart';
import 'package:mfa_app/pages/mfa/verify_page.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class LoginPage extends StatefulWidget {
  static const route = '/auth/login';

  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: ListView(
        padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 24),
        children: [
          TextFormField(
            controller: _emailController,
            decoration: const InputDecoration(
              label: Text('Email'),
            ),
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: _passwordController,
            decoration: const InputDecoration(
              label: Text('Password'),
            ),
            obscureText: true,
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: () async {
              try {
                final email = _emailController.text.trim();
                final password = _passwordController.text.trim();
                await supabase.auth.signInWithPassword(
                  email: email,
                  password: password,
                );
                if (mounted) {
                  context.go(MFAVerifyPage.route);
                }
              } on AuthException catch (error) {
                ScaffoldMessenger.of(context)
                    .showSnackBar(SnackBar(content: Text(error.message)));
              } catch (error) {
                ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('Unexpected error occurred')));
              }
            },
            child: const Text('Login'),
          ),
        ],
      ),
    );
  }
}
```

----------------------------------------

TITLE: Exchange Supabase Auth Token for Session in Next.js (JavaScript)
DESCRIPTION: This server-side GET handler for `/auth/confirm` retrieves the `token_hash` and `type` from the URL query parameters. It uses the Supabase client to verify the OTP, exchanges the token for a user session, and then redirects the user to the `/account` page upon success or `/error` on failure. The `token_hash` and `type` are removed from the redirect URL for security.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/getting-started/tutorials/with-nextjs.mdx#_snippet_10

LANGUAGE: JavaScript
CODE:
```
import { NextResponse } from 'next/server'

import { createClient } from '@/utils/supabase/server'

// Creating a handler to a GET request to route /auth/confirm
export async function GET(request) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type')
  const next = '/account'

  // Create redirect link without the secret token
  const redirectTo = request.nextUrl.clone()
  redirectTo.pathname = next
  redirectTo.searchParams.delete('token_hash')
  redirectTo.searchParams.delete('type')

  if (token_hash && type) {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })
    if (!error) {
      redirectTo.searchParams.delete('next')
      return NextResponse.redirect(redirectTo)
    }
  }

  // return the user to an error page with some instructions
  redirectTo.pathname = '/error'
  return NextResponse.redirect(redirectTo)
}
```

----------------------------------------

TITLE: Configuring Supabase Production Environment Variables
DESCRIPTION: This snippet defines the public Supabase URL and anonymous key for a production environment. These variables are crucial for client-side applications to connect to the Supabase project and perform operations securely.
SOURCE: https://github.com/supabase/supabase/blob/master/examples/slack-clone/nextjs-slack-clone-dotenvx/README.md#_snippet_5

LANGUAGE: dotenv
CODE:
```
NEXT_PUBLIC_SUPABASE_URL=https://<your-project>.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=<your-project-apikey>
```

----------------------------------------

TITLE: Migrate `withMiddlewareAuth` to `createMiddlewareClient` for Next.js Middleware
DESCRIPTION: The `withMiddlewareAuth` higher-order function is deprecated. This snippet demonstrates how to update Next.js middleware by replacing `withMiddlewareAuth` with `createMiddlewareClient`. The new approach involves creating an authenticated Supabase client within the middleware function, checking authentication conditions, and manually handling responses or redirects.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/auth/auth-helpers/nextjs-pages.mdx#_snippet_17

LANGUAGE: tsx
CODE:
```
import { withMiddlewareAuth } from '@supabase/auth-helpers-nextjs'

export const middleware = withMiddlewareAuth({
  redirectTo: '/',
  authGuard: {
    isPermitted: async (user) => {
      return user.email?.endsWith('@gmail.com') ?? false
    },
    redirectTo: '/insufficient-permissions',
  },
})

export const config = {
  matcher: '/middleware-protected',
}
```

LANGUAGE: tsx
CODE:
```
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  // We need to create a response and hand it to the supabase client to be able to modify the response headers.
  const res = NextResponse.next()
  // Create authenticated Supabase Client.
  const supabase = createMiddlewareClient({ req, res })
  // Check if we have a session
  const {
    data: { user },
  } = await supabase.auth.getUser()

  // Check auth condition
  if (user?.email?.endsWith('@gmail.com')) {
    // Authentication successful, forward request to protected route.
    return res
  }

  // Auth condition not met, redirect to home page.
  const redirectUrl = req.nextUrl.clone()
  redirectUrl.pathname = '/'
  redirectUrl.searchParams.set(`redirectedFrom`, req.nextUrl.pathname)
  return NextResponse.redirect(redirectUrl)
}

export const config = {
  matcher: '/middleware-protected',
}
```

----------------------------------------

TITLE: Handle User Redirection with Splash Page in Flutter/Dart
DESCRIPTION: This snippet defines a `SplashPage` in Flutter that serves as an initial entry point for users. It fetches the current authentication session from Supabase and redirects users to either the `ChatPage` (if signed in) or `RegisterPage` (if not signed in). The `_redirect()` method handles this logic asynchronously after the widget mounts.
SOURCE: https://github.com/supabase/supabase/blob/master/apps/www/_blog/2022-06-30-flutter-tutorial-building-a-chat-app.mdx#_snippet_7

LANGUAGE: dart
CODE:
```
import 'package:flutter/material.dart';
import 'package:my_chat_app/pages/chat_page.dart';
import 'package:my_chat_app/pages/register_page.dart';
import 'package:my_chat_app/utils/constants.dart';

/// Page to redirect users to the appropriate page depending on the initial auth state
class SplashPage extends StatefulWidget {
  const SplashPage({Key? key}) : super(key: key);

  @override
  SplashPageState createState() => SplashPageState();
}

class SplashPageState extends State<SplashPage> {
  @override
  void initState() {
    super.initState();
    _redirect();
  }

  Future<void> _redirect() async {
    // await for for the widget to mount
    await Future.delayed(Duration.zero);

    final session = supabase.auth.currentSession;
    if (session == null) {
      Navigator.of(context)
          .pushAndRemoveUntil(RegisterPage.route(), (route) => false);
    } else {
      Navigator.of(context)
          .pushAndRemoveUntil(ChatPage.route(), (route) => false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return const Scaffold(body: preloader);
  }
}
```